
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Stellar</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/default.min.css">
    <script src="/marked.min.js"></script>
    <script src="/turndown.js"></script>
    <script src="/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
        integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"
        integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd"
        crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
        integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk"
        crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
        <!-- CodeMirror Editor Library -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/dracula.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/python/python.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/css/css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>

    <style>
       
.code-controls .run-code-btn {
    background-color: rgba(30, 180, 100, 0.2); 
    color: #4ef0a1; 
    border: 1px solid rgba(30, 180, 100, 0.4);
}
.code-controls .run-code-btn:hover {
    background-color: rgba(30, 180, 100, 0.3);
    color: #ffffff;
    border-color: rgba(30, 180, 100, 0.6);
}
.code-controls .run-code-btn.running {
    cursor: not-allowed;
    background-color: rgba(255, 165, 0, 0.3); 
    color: #ffc966;
    border-color: rgba(255, 165, 0, 0.5);
    animation: pulse-run 1.5s infinite;
}
@keyframes pulse-run {
    0% { filter: brightness(1); }
    50% { filter: brightness(1.3); }
    100% { filter: brightness(1); }
}

#forge-editor-tabs .forge-tab-btn {
    padding: 8px 16px;
    border: 1px solid var(--input-border);
    border-bottom: none;
    background-color: var(--stellar-msg-bg);
    color: var(--secondary-text-color);
    cursor: pointer;
    border-radius: 6px 6px 0 0;
    transition: background-color 0.2s ease, color 0.2s ease;
}

#forge-editor-tabs .forge-tab-btn:hover {
    background-color: var(--stellar-msg-hover-bg);
    color: var(--primary-text-color);
}

#forge-editor-tabs .forge-tab-btn.active {
    background-color: var(--code-bg);
    color: var(--primary-text-color);
    border-color: var(--model-color-border);
}
.code-output-container {
    margin-top: -1.2em; 
    padding-top: 10px;
    animation: slideInFromTop 0.3s ease-out;
}
.code-output-panel {
    background-color: #1a1a2e; 
    border: 1px solid var(--code-border);
    border-top: none; 
    border-radius: 0 0 8px 8px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    overflow: hidden; 
}
.code-output-header {
    background-color: rgba(0,0,0,0.2);
    padding: 6px 12px;
    padding-top: 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.85rem;
    color: var(--secondary-text-color);
}
.code-output-header .status-text {
    font-family: 'Fira Code', monospace; 
}
.code-output-header .close-output-btn {
    background: none;
    border: none;
    color: var(--secondary-text-color);
    font-size: 1.2rem;
    cursor: pointer;
    line-height: 1;
    padding: 2px;
}
.code-output-header .close-output-btn:hover {
    color: var(--primary-text-color);
}
.code-output-content {
    padding: 12px;
    max-height: 300px; 
    overflow-y: auto;
    font-family: 'Fira Code', monospace;
    font-size: 0.9rem;
    white-space: pre-wrap; 
    word-wrap: break-word;
    line-height: 1.6;
}
.code-output-content .output-line {
    display: block; 
}
.code-output-content .output-line.error {
    color: #ff8e8e; 
}
@keyframes slideInFromTop {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

        #tokenCountBar { display: none !important; }
        :root {
            --model-color-start: #7b61ff;
            --model-color-end: #b554ff;
            --model-color-border: rgba(181, 84, 255, 0.5);
            --model-color-shadow: rgba(123, 97, 255, 0.3);
            --model-color-shadow-inset: rgba(123, 97, 255, 0.2);
            --model-hover-color-start: #b554ff;
            --model-hover-color-end: #7b61ff;
            --model-hover-color-border: rgba(123, 97, 255, 0.7);
            --model-hover-color-shadow: rgba(123, 97, 255, 0.5);
            --model-hover-color-shadow-inset: rgba(123, 97, 255, 0.3);
            --model-hover-shadow-strong: rgba(123, 97, 255, 0.4);
            --title-shadow-color: var(--model-color-shadow);
            --body-bg-color1: #0f0c29;
            --body-bg-color2: #302b63;
            --body-bg-color3: #24243e;
            --body-bg-color4: #302b63;
            --primary-text-color: #f0f0f0;
            --secondary-text-color: #a9a3c7;
            --header-bg: rgba(20, 16, 50, 0.3);
            --header-border: rgba(181, 84, 255, 0.15);
            --input-bg: rgba(20, 16, 50, 0.4);
            --input-border: rgba(181, 84, 255, 0.1);
            --input-focus-bg: rgba(30, 26, 60, 0.5);
            --input-focus-border: var(--model-color-border);
            --user-msg-bg: rgba(123, 97, 255, 0.15);
            --user-msg-border: rgba(123, 97, 255, 0.3);
            --user-msg-hover-bg: rgba(123, 97, 255, 0.2);
            --stellar-msg-bg: rgba(0, 0, 0, 0.25);
            --stellar-msg-border: rgba(123, 97, 255, 0.2);
            --stellar-msg-hover-bg: rgba(0, 0, 0, 0.35);
            --nebula-msg-bg: rgba(10, 25, 45, 0.4);
            --nebula-msg-border: rgba(79, 172, 254, 0.3);
            --nebula-msg-hover-bg: rgba(15, 35, 55, 0.5);
            --link-color: var(--model-color-start);
            --link-hover-color: var(--model-hover-color-start);
            --scrollbar-thumb-start: var(--model-color-start);
            --scrollbar-thumb-end: var(--model-color-end);
            --scrollbar-thumb-border: var(--model-color-border);
            --scrollbar-thumb-hover-start: var(--model-hover-color-start);
            --scrollbar-thumb-hover-end: var(--model-hover-color-end);
            --scrollbar-thumb-hover-border: var(--model-hover-color-border);
            --scrollbar-track-bg: rgba(36, 36, 62, 0.6);
            --table-border-color: rgba(123, 97, 255, 0.3);
            --code-bg: rgba(10, 10, 25, 0.85);
            --code-border: rgba(123, 97, 255, 0.4);
            --code-text-color: #f5f5f5;
            --inline-code-bg: rgba(0, 0, 0, 0.3);
            --inline-code-text-color: var(--model-color-end);
            --status-bar-bg: rgba(123, 97, 255, 0.2);
            --status-bar-color: #e0d9ff;
            --status-bar-shadow: rgba(123, 97, 255, 0.4);
            --status-bar-idle-color: var(--secondary-text-color);
            --status-bar-idle-bg: rgba(0, 0, 0, 0.2);
            --code-btn-bg: rgba(50, 50, 50, 0.7); /* Change from rgba(255, 255, 255, 0.1) to a darker, more opaque background */
            --code-btn-hover-bg: rgba(70, 70, 70, 0.8); /* Change from rgba(255, 255, 255, 0.2) to a slightly lighter, more opaque background on hover */
            --code-btn-color: #ffffff; /* Change from #c5bfff to pure white for better contrast */
            --code-btn-hover-color: #ffffff; /* Change from #f5f5f5 to pure white on hover */
                --code-btn-border: 1px solid black;
    --code-btn-hover-border: 1px solid black;
            --copy-btn-copied-bg: var(--model-color-start);
            --copy-btn-copied-color: #ffffff;
            --preview-btn-bg: var(--code-btn-bg);
            --preview-btn-hover-bg: var(--code-btn-hover-bg);
            --preview-btn-color: var(--code-btn-color);
            --preview-btn-hover-color: var(--code-btn-hover-color);
            --transition-duration-fast: 0.2s;
            --transition-duration-medium: 0.3s;
            --transition-duration-slow: 0.5s;
            --transition-timing-function: ease;
            --transition-cubic-bezier: cubic-bezier(0.25, 0.8, 0.25, 1);
            --nebula-confirm-start: #00c292;
            --nebula-confirm-end: #00a77d;
            --nebula-regenerate-start: #ff8e8e;
            --nebula-regenerate-end: #ff6b6b;
            --nebula-button-shadow: rgba(0, 0, 0, 0.2);
            --nebula-button-hover-brightness: 1.1;
            --output-copy-btn-bg: rgba(50, 50, 50, 0.7);
            --output-copy-btn-hover-bg: rgba(70, 70, 70, 0.8);
            --output-copy-btn-color: #d1d5db;
            --output-copy-btn-hover-color: #ffffff;
            --output-copy-btn-copied-bg: #20a375;
            --output-copy-btn-copied-color: #ffffff;
            --tooltip-bg: rgba(30, 30, 30, 0.9);
            --tooltip-color: #ffffff;
            --tooltip-transition-duration: 0.15s;
            --auth-form-bg: rgba(20, 16, 50, 0.7);
            --auth-input-bg: rgba(0, 0, 0, 0.3);
            --auth-input-border: rgba(181, 84, 255, 0.2);
            --auth-button-bg: linear-gradient(45deg, var(--model-color-start), var(--model-color-end));
            --auth-button-shadow: 0 4px 10px var(--model-color-shadow);
            --auth-link-color: var(--link-color);
            --auth-message-success: #00c292;
            --auth-message-error: #ff6b6b;
            --sidebar-bg: rgba(20, 16, 50, 0.7);
            --sidebar-border: rgba(181, 84, 255, 0.2);
            --chat-item-hover: rgba(255, 255, 255, 0.05);
            --chat-item-active: rgba(123, 97, 255, 0.2);
            --chat-item-active-border: rgba(123, 97, 255, 0.5);
            --token-bar-bg: rgba(0, 0, 0, 0.2);
            --token-bar-fill-low: #00c292;
            --token-bar-fill-medium: #fabd2f;
            --token-bar-fill-high: #ff6b6b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .file-upload-label-button {
            background: rgba(255, 255, 255, 0.07);
            color: var(--secondary-text-color);
            padding: 0;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 1px solid transparent;
            margin-right: 8px;
            width: 36px;
            height: 36px;
            font-size: 1rem;
        }
        .file-upload-label-button svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }
        .file-upload-label-button:hover {
             background: rgba(255, 255, 255, 0.1);
             color: var(--primary-text-color);
             transform: translateY(-1px);
             box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        #analysis-progress-area {
            position: fixed;
            bottom: 130px;
            left: 50%;
            transform: translateX(-50%);
            width: calc(100% - 40px);
            max-width: 1200px;
            max-height: 150px;
            overflow-y: auto;
            display: none;
            flex-direction: column-reverse;
            gap: 8px;
            z-index: 90;
            padding: 5px;
            scrollbar-width: thin;
            scrollbar-color: var(--scrollbar-thumb-start) var(--scrollbar-track-bg);
        }
        #analysis-progress-area::-webkit-scrollbar { width: 5px; }
        #analysis-progress-area::-webkit-scrollbar-track { background: var(--scrollbar-track-bg); border-radius: 10px; }
        #analysis-progress-area::-webkit-scrollbar-thumb { background: linear-gradient(var(--scrollbar-thumb-start), var(--scrollbar-thumb-end)); border-radius: 10px; border: 1px solid var(--scrollbar-thumb-border); }
        #analysis-progress-area::-webkit-scrollbar-thumb:hover { background: linear-gradient(var(--scrollbar-thumb-hover-start), var(--scrollbar-thumb-hover-end)); border: 1px solid var(--scrollbar-thumb-hover-border); }

        .file-progress-item {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
            border: 1px solid var(--stellar-msg-border);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            color: var(--secondary-text-color);
            transition: border-color 0.3s ease, background-color 0.3s ease, opacity 0.5s ease;
            animation: progressIn 0.3s ease forwards;
            opacity: 0;
            transform: translateY(10px);
        }
        @keyframes progressIn { to { opacity: 1; transform: translateY(0); } }

        .file-progress-item .summary { cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .file-progress-item .summary strong { color: var(--primary-text-color); margin-right: 10px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 70%; }
        .file-progress-item .summary .status { font-style: italic; white-space: nowrap; }
        .file-progress-item .details { display: none; padding-top: 5px; margin-top: 5px; border-top: 1px dashed rgba(255, 255, 255, 0.15); font-size: 0.8rem; max-height: 80px; overflow-y: auto; scrollbar-width: thin; scrollbar-color: var(--scrollbar-thumb-start) var(--scrollbar-track-bg); }
        .file-progress-item.status-success { border-color: var(--nebula-confirm-start); background-color: rgba(0, 194, 146, 0.1); }
        .file-progress-item.status-success .summary .status { color: var(--nebula-confirm-start); font-style: normal; }
        .file-progress-item.status-error { border-color: var(--nebula-regenerate-start); background-color: rgba(211, 16, 39, 0.1); }
        .file-progress-item.status-error .summary .status { color: var(--nebula-regenerate-start); font-style: normal; }
        .file-progress-item.status-finished, .file-progress-item.status-ended { border-color: var(--model-color-border); background-color: rgba(123, 97, 255, 0.1); }

        .placeholder-message .message-content { font-style: italic; color: var(--secondary-text-color); }
        .placeholder-status.clickable { cursor: pointer; text-decoration: underline dotted; }
        .analysis-indicator.clickable { cursor: pointer; text-decoration: underline dotted; margin-left: 10px; font-size: 0.85em; color: var(--secondary-text-color); }
        .analysis-content { font-size: 0.9em; line-height: 1.4; display: none; margin-top: 10px; padding-top: 10px; border-top: 1px dashed var(--stellar-msg-border); }
        .analysis-content small { display: block; margin-bottom: 5px; color: var(--secondary-text-color); }
        .formatted-analysis-context ul { list-style: disc; margin-left: 20px; margin-top: 5px; margin-bottom: 10px; }
        .formatted-analysis-context li { margin-bottom: 8px; }
        .formatted-analysis-context pre { margin-top: 5px; padding: 8px; font-size: 0.85em; background-color: rgba(0,0,0,0.2); border: 1px solid rgba(255,255,255,0.1); white-space: pre-wrap; word-wrap: break-word; border-radius: 4px; }
        .formatted-analysis-context details { border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; margin-bottom: 10px; background-color: rgba(0, 0, 0, 0.1); }
        .formatted-analysis-context summary { padding: 8px; cursor: pointer; font-weight: bold; color: var(--primary-text-color); background-color: rgba(255, 255, 255, 0.03); border-radius: 4px 4px 0 0; display: block; }
        .formatted-analysis-context summary:hover { background-color: rgba(255, 255, 255, 0.05); }
        .formatted-analysis-context details > div, .formatted-analysis-context details > pre { padding: 10px; border-top: 1px dashed rgba(255, 255, 255, 0.1); margin-top: 0; background-color: rgba(0,0,0,0.1); }
        .formatted-analysis-context details[open] > summary { border-radius: 4px 4px 0 0; }
        .formatted-analysis-context details > pre { border-radius: 0 0 4px 4px; }
        .formatted-analysis-context .rendered-markdown-block { margin-top: 5px; padding: 10px; background-color: rgba(0,0,0,0.15); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; }
        .formatted-analysis-context .rendered-markdown-block pre { background-color: rgba(0,0,0,0.25); border: 1px solid rgba(255,255,255,0.15); }
        .formatted-analysis-context strong { color: var(--primary-text-color); }

        body::-webkit-scrollbar,
        textarea::-webkit-scrollbar,
        .modal-content::-webkit-scrollbar,
        #messages::-webkit-scrollbar,
        #analysis-progress-area::-webkit-scrollbar,
        .file-progress-item .details::-webkit-scrollbar,
        pre::-webkit-scrollbar,
        .table-wrapper::-webkit-scrollbar,
        #stagedFilesContainer::-webkit-scrollbar,
        #sidebar::-webkit-scrollbar,
        #chatList::-webkit-scrollbar,
        #profileModal::-webkit-scrollbar,
        #forge-status-log::-webkit-scrollbar,
        .CodeMirror-scroll::-webkit-scrollbar/* <-- ADD THIS LINE */
        {
            width: 8px;
            height: 8px;
        }
       

        body::-webkit-scrollbar-track,
        textarea::-webkit-scrollbar-track,
        .modal-content::-webkit-scrollbar-track,
        #messages::-webkit-scrollbar-track,
        #analysis-progress-area::-webkit-scrollbar-track,
        .file-progress-item .details::-webkit-scrollbar-track,
        pre::-webkit-scrollbar-track,
        .table-wrapper::-webkit-scrollbar-track,
        #stagedFilesContainer::-webkit-scrollbar-track,
        #sidebar::-webkit-scrollbar-track,
        #chatList::-webkit-scrollbar-track,
        #profileModal::-webkit-scrollbar-track,
        #forge-status-log::-webkit-scrollbar-track,
        .CodeMirror-scroll::-webkit-scrollbar-track/* <-- ADD THIS LINE */
        {
            background: var(--scrollbar-track-bg);
            border-radius: 0px;
        }
                body::-webkit-scrollbar-thumb,
        textarea::-webkit-scrollbar-thumb,
        .modal-content::-webkit-scrollbar-thumb,
        #messages::-webkit-scrollbar-thumb,
        #analysis-progress-area::-webkit-scrollbar-thumb,
        .file-progress-item .details::-webkit-scrollbar-thumb,
        pre::-webkit-scrollbar-thumb,
        .table-wrapper::-webkit-scrollbar-thumb,
        #stagedFilesContainer::-webkit-scrollbar-thumb,
        #sidebar::-webkit-scrollbar-thumb,
        #chatList::-webkit-scrollbar-thumb,
        #profileModal::-webkit-scrollbar-thumb,
        #forge-status-log::-webkit-scrollbar-thumb,
        .CodeMirror-scroll::-webkit-scrollbar-thumb/* <-- ADD THIS LINE */
        {
            background: linear-gradient(var(--scrollbar-thumb-start), var(--scrollbar-thumb-end));
            border-radius: 10px;
            border: 1px solid var(--scrollbar-thumb-border);
        }
               body::-webkit-scrollbar-thumb:hover,
        textarea::-webkit-scrollbar-thumb:hover,
        .modal-content::-webkit-scrollbar-thumb:hover,
        #messages::-webkit-scrollbar-thumb:hover,
        #analysis-progress-area::-webkit-scrollbar-thumb:hover,
        .file-progress-item .details::-webkit-scrollbar-thumb:hover,
        pre::-webkit-scrollbar-thumb:hover,
        .table-wrapper::-webkit-scrollbar-thumb:hover,
        #stagedFilesContainer::-webkit-scrollbar-thumb:hover,
        #sidebar::-webkit-scrollbar-thumb:hover,
        #chatList::-webkit-scrollbar-thumb:hover,
        #profileModal::-webkit-scrollbar-thumb:hover,
        #forge-status-log::-webkit-scrollbar-thumb:hover,
        .CodeMirror-scroll::-webkit-scrollbar-thumb:hover/* <-- ADD THIS LINE */
        {
            background: linear-gradient(var(--scrollbar-thumb-hover-start), var(--scrollbar-thumb-hover-end));
            border: 1px solid var(--scrollbar-thumb-hover-border);
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, var(--body-bg-color1), var(--body-bg-color2), var(--body-bg-color3), var(--body-bg-color4));
            background-size: 400% 400%;
            color: var(--primary-text-color);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden;
            transition: color var(--transition-duration-slow) var(--transition-timing-function);
            animation: animatedGradient 20s ease infinite;
        }
        @keyframes animatedGradient { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }

        @keyframes float { 0% { transform: translate(0, 0) scale(1); } 50% { transform: translate(50px, -30px) scale(1.1); } 100% { transform: translate(-30px, 30px) scale(0.9); } }

        header { background: var(--header-bg); backdrop-filter: blur(12px); padding: 15px 24px; display: flex; align-items: center; justify-content: space-between; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2); position: sticky; top: 0; z-index: 100; border-bottom: 1px solid var(--header-border); transition: background var(--transition-duration-medium) var(--transition-timing-function), border-color var(--transition-duration-medium) var(--transition-timing-function); }
        .header-left { display: flex; align-items: center; gap: 15px; }
        .header-right { display: flex; align-items: center; gap: 15px; }
        .title-gradient { font-size: 1.8rem; font-weight: 600; background: linear-gradient(45deg, var(--model-color-start), var(--model-color-end)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 0 15px var(--title-shadow-color); letter-spacing: 1px; transition: text-shadow var(--transition-duration-medium) var(--transition-timing-function), transform var(--transition-duration-fast) var(--transition-timing-function), background var(--transition-duration-medium) var(--transition-timing-function); }
        .title-gradient:hover { text-shadow: 0 0 20px var(--model-hover-color-shadow); transform: translateY(-1px); }
        body.theme-emerald .title-gradient { background: linear-gradient(45deg, #00c292, #00a77d 50%, #36d1dc); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 0 10px var(--title-shadow-color); }
        body.theme-crimson .title-gradient { background: linear-gradient(45deg, #D31027, #9A0007 50%, #ff512f); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 0 10px var(--title-shadow-color); }
        body.theme-obsidian .title-gradient { background: linear-gradient(45deg, #6e7a85, #485563 50%, #8a9aa3); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 0 12px var(--title-shadow-color), 0 0 1px rgba(200, 210, 220, 0.3); filter: brightness(1.1); }
        .clear-icon { font-size: 1.2rem; background: none; border: none; color: #ff6b6b; cursor: pointer; padding: 4px; transition: color var(--transition-duration-fast) var(--transition-timing-function), transform var(--transition-duration-fast) var(--transition-timing-function), box-shadow var(--transition-duration-fast) var(--transition-timing-function); }
        .clear-icon:hover { color: #ff8e8e; transform: translateY(-2px) scale(1.1); box-shadow: 0 4px 10px rgba(255, 107, 107, 0.3); filter: brightness(1.2); }
        .header-auth-buttons { display: flex; gap: 10px; align-items: center; }
        .logout-btn { background: linear-gradient(45deg, #ff8e8e, #ff6b6b); color: #fff; padding: 8px 16px; border-radius: 6px; border: none; cursor: pointer; transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; }
        .logout-btn:hover { background: linear-gradient(45deg, #ff6b6b, #ff8e8e); transform: translateY(-2px); box-shadow: 0 4px 10px rgba(255, 107, 107, 0.4); }

        #sidebarToggleBtn {
            background: none; border: none; color: var(--secondary-text-color); font-size: 1.5rem; cursor: pointer;
            padding: 5px; transition: color 0.2s ease, transform 0.2s ease;
        }
        #sidebarToggleBtn:hover { color: var(--primary-text-color); transform: translateX(2px); }
        #sidebarToggleBtn svg { width: 20px; height: 20px; }

        #chatTitle {
            font-size: 1.8rem; font-weight: 600; background: linear-gradient(45deg, var(--model-color-start), var(--model-color-end)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 0 15px var(--title-shadow-color); letter-spacing: 1px;
            transition: text-shadow var(--transition-duration-medium), transform var(--transition-duration-fast), background var(--transition-duration-medium);
            margin-left: 20px;
        }

        #profileIcon {
            width: 40px; height: 40px; border-radius: 50%; background: linear-gradient(45deg, var(--model-color-start), var(--model-color-end));
            display: flex; align-items: center; justify-content: center; font-size: 1.2rem; font-weight: 600; color: #fff;
            cursor: pointer; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3); transition: all 0.3s ease;
            position: relative; overflow: hidden;
        }
        #profileIcon img { width: 100%; height: 100%; object-fit: cover; border-radius: 50%; }
        #profileIcon:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4); }

        #sidebar {
            position: fixed; top: 0; left: 0; bottom: 0; width: 280px;
            background: var(--sidebar-bg); backdrop-filter: blur(15px);
            border-right: 1px solid var(--sidebar-border); box-shadow: 4px 0 20px rgba(0, 0, 0, 0.3);
            transform: translateX(-100%); transition: transform 0.3s ease-in-out;
            z-index: 105; display: flex; flex-direction: column; padding: 20px;
        }
        #sidebar.open { transform: translateX(0); }

        .sidebar-header {
            display: flex; align-items: center; justify-content: space-between;
            padding-bottom: 15px; margin-bottom: 15px; border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .sidebar-header h3 { font-size: 1.3rem; color: var(--primary-text-color); }
        .sidebar-close-btn {
            background: none; border: none; color: var(--secondary-text-color); font-size: 1.5rem; cursor: pointer;
            padding: 5px; transition: color 0.2s ease, transform 0.2s ease;
        }
        .sidebar-close-btn:hover { color: var(--primary-text-color); transform: translateX(-2px); }
        .sidebar-close-btn svg { width: 20px; height: 20px; }

        .user-info { font-size: 0.9rem; color: var(--secondary-text-color); margin-bottom: 20px; }
        .user-info strong { color: var(--primary-text-color); }

        #newChatBtn {
            width: 100%; padding: 12px; background: linear-gradient(45deg, var(--model-color-start), var(--model-color-end));
            color: #fff; border: none; border-radius: 8px; font-size: 1rem; font-weight: 600; cursor: pointer;
            box-shadow: 0 4px 10px var(--model-color-shadow); transition: all 0.3s ease; margin-bottom: 20px;
        }
        #newChatBtn:hover { transform: translateY(-2px); box-shadow: 0 6px 15px var(--model-hover-color-shadow); filter: brightness(1.1); }

        #chatList {
            list-style: none; padding: 0; margin: 0; flex-grow: 1; overflow-y: auto;
            scrollbar-width: thin; scrollbar-color: var(--scrollbar-thumb-start) var(--scrollbar-track-bg);
        }
        /* ADD THIS CSS */
.chat-search-container {
    position: relative;
    margin-bottom: 15px;
}
.chat-search-container .search-icon {
    position: absolute;
    left: 12px;
    top: 50%;
    transform: translateY(-50%);
    width: 18px;
    height: 18px;
    fill: var(--secondary-text-color);
    pointer-events: none;
    opacity: 0.6;
}
#chatSearchInput {
    width: 100%;
    padding: 10px 12px 10px 40px; 
    background: rgba(0, 0, 0, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.1);
    color: var(--primary-text-color);
    border-radius: 6px;
    font-size: 0.9rem;
    outline: none;
    transition: background 0.2s ease, border-color 0.2s ease;
}
#chatSearchInput:focus {
    background: rgba(0, 0, 0, 0.3);
    border-color: var(--model-color-border);
}
#chatSearchInput::placeholder {
    color: var(--secondary-text-color);
    opacity: 0.7;
}
        .chat-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 12px; margin-bottom: 8px; border-radius: 6px;
            background: rgba(0, 0, 0, 0.1); border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer; transition: background 0.2s ease, border-color 0.2s ease;
        }
        .chat-item:hover { background: var(--chat-item-hover); }
        .chat-item.active {
            background: var(--chat-item-active); border-color: var(--chat-item-active-border);
            box-shadow: 0 2px 8px rgba(123, 97, 255, 0.2);
        }
        .chat-item span { flex-grow: 1; color: var(--primary-text-color); font-size: 0.95rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .chat-item .delete-chat-btn {
            background: none; border: none; color: var(--secondary-text-color); font-size: 1.1rem;
            margin-left: 10px; cursor: pointer; opacity: 0.7; transition: color 0.2s ease, opacity 0.2s ease;
        }
        .chat-item .delete-chat-btn:hover { color: #ff6b6b; opacity: 1; }

        #profileModal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 12, 41, 0.8); backdrop-filter: blur(8px);
            display: none; align-items: center; justify-content: center; z-index: 1000;
            animation: fadeIn 0.3s ease;
        }
        .chat-item-main-content {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    min-width: 0;
}

.chat-item .chat-name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.chat-item .snippet-preview {
    font-size: 0.75rem;
    color: var(--secondary-text-color);
    margin-top: 5px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
    font-style: italic;
    opacity: 0.8;
    display: none; 
}

        .profile-modal-content {
            background: linear-gradient(135deg, rgba(48, 43, 99, 0.8), rgba(36, 36, 62, 0.9));
            border: 1px solid var(--model-color-border); border-radius: 16px; backdrop-filter: blur(20px);
            padding: 30px; width: 90%; max-width: 500px; box-shadow: 0 20px 50px rgba(0, 0, 0, 0.4);
            animation: modalIn 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            overflow-y: auto; max-height: 90vh;
            position: relative;
        }
        .profile-modal-content h2 {
            font-size: 1.8rem; margin-bottom: 25px; text-align: center;
            background: linear-gradient(45deg, var(--model-color-start), var(--model-color-end));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .profile-close-btn {
            position: absolute; top: 15px; right: 15px;
            background: none; border: none; color: var(--secondary-text-color); font-size: 1.5rem;
            cursor: pointer; transition: color 0.2s ease;
        }
        .profile-close-btn:hover { color: var(--primary-text-color); }
        .profile-close-btn svg { width: 20px; height: 20px; }

        .profile-info {
            font-size: 1.1rem; color: var(--primary-text-color); text-align: center; margin-bottom: 25px;
            padding: 10px; background: rgba(0, 0, 0, 0.15); border-radius: 8px;
        }
        .profile-info strong { color: var(--model-color-end); }
        .password-change-section { margin-top: 25px; padding-top: 20px; border-top: 1px solid rgba(255, 255, 255, 0.1); }
        .password-change-section h3 {
            font-size: 1.4rem; margin-bottom: 20px; text-align: center;
            color: var(--link-color);
        }
        .password-change-form { display: flex; flex-direction: column; gap: 15px; }
        .password-change-form input {
            padding: 12px 15px; border: 1px solid var(--auth-input-border); border-radius: 6px;
            background: var(--auth-input-bg); color: var(--primary-text-color); font-size: 1rem;
            outline: none; transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        .password-change-form input:focus {
            border-color: var(--model-color-start); box-shadow: 0 0 8px rgba(123, 97, 255, 0.3);
        }
        .password-change-form button {
            width: 100%; padding: 12px; background: linear-gradient(45deg, var(--nebula-confirm-start), var(--nebula-confirm-end));
            color: #fff; border: none; border-radius: 8px; font-size: 1rem; font-weight: 600; cursor: pointer;
            box-shadow: 0 4px 10px rgba(0, 194, 146, 0.3); transition: all 0.3s ease;
        }
        .password-change-form button:hover { transform: translateY(-2px); box-shadow: 0 6px 15px rgba(0, 194, 146, 0.4); filter: brightness(1.1); }
        #passwordChangeMessage { margin-top: 15px; text-align: center; }

        #logoutButtonProfile {
            width: 100%; padding: 12px; background: linear-gradient(45deg, #ff8e8e, #ff6b6b);
            color: #fff; border: none; border-radius: 8px; font-size: 1rem; font-weight: 600; cursor: pointer;
            box-shadow: 0 4px 10px rgba(255, 107, 107, 0.3); transition: all 0.3s ease; margin-top: 25px;
        }
        #logoutButtonProfile:hover { transform: translateY(-2px); box-shadow: 0 6px 15px rgba(255, 107, 107, 0.4); filter: brightness(1.1); }

        #tokenCountBar {
            position: fixed;
            top: 60px;
            left: 0;
            width: 0%;
            height: 5px;
            background-color: var(--token-bar-fill-low);
            z-index: 95;
            transition: width 0.5s ease-out, background-color 0.5s ease-out;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }


        #chatContainer { flex: 1; display: flex; flex-direction: column; width: 100%; margin: 0 auto; padding: 30px max(20px, calc((100% - 1200px) / 2)); position: relative; padding-bottom: 220px; box-sizing: border-box; }

        #messages {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 15px;
            width: 100%;
            box-sizing: border-box;
            scrollbar-width: thin;
            scrollbar-color: var(--scrollbar-thumb-start) var(--scrollbar-track-bg);
        }

        .message { margin-bottom: 20px; line-height: 1.6; word-wrap: break-word; padding: 18px 22px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15); border: 1px solid transparent; animation: messageIn 0.4s ease forwards; opacity: 0; transform: translateY(20px); transition: background var(--transition-duration-medium) var(--transition-timing-function), border-color var(--transition-duration-medium) var(--transition-timing-function), transform var(--transition-duration-fast) ease-out; max-width: 90%; box-sizing: border-box; position: relative; }
        .message:hover { transform: translateY(-2px); }
        @keyframes messageIn { to { opacity: 1; transform: translateY(0); } }

        .user-msg { background: var(--user-msg-bg); align-self: flex-end; margin-left: auto; border-top-right-radius: 4px; border-left: 1px solid var(--user-msg-border); color: var(--primary-text-color); }
        .user-msg:hover { background: var(--user-msg-hover-bg); }
        .user-msg .message-content { white-space: pre-wrap; }
       .file-feedback-active {
    animation: pulse-upload 0.5s ease;
}

@keyframes pulse-upload {
    0% { 
        box-shadow: 0 0 0 rgba(0, 255, 136, 0); 
        outline: 2px dashed transparent;
        transform: scale(1);
    }
    50% { 
        box-shadow: 0 0 15px rgba(0, 255, 136, 0.4); 
        outline: 2px dashed #00ff88;
        transform: scale(1.1);
    }
    100% { 
        box-shadow: 0 0 0 rgba(0, 255, 136, 0); 
        outline: 2px dashed transparent;
        transform: scale(1);
    }
}

.stellar-msg { background: var(--stellar-msg-bg); align-self: flex-start; color: var(--primary-text-color); border-top-left-radius: 4px; border-right: 1px solid var(--stellar-msg-border); padding-left: 40px; }
        .stellar-msg:hover { background: var(--stellar-msg-hover-bg); }

.research-output { background: rgba(0, 0, 0, 0.4); border: 1px solid var(--stellar-msg-border); box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25); align-self: stretch; margin-left: 0; max-width: none; width: auto; resize: none; overflow-x: hidden; overflow-y: hidden; min-width: 0; } .research-output:hover { background: rgba(0, 0, 0, 0.5); border-color: var(--model-color-border); }
        body.theme-emerald .research-output { border-color: rgba(0, 194, 146, 0.4); } body.theme-emerald .research-output:hover { border-color: rgba(0, 194, 146, 0.6); }
        body.theme-crimson .research-output { border-color: rgba(211, 16, 39, 0.4); } body.theme-crimson .research-output:hover { border-color: rgba(211, 16, 39, 0.6); }
        body.theme-obsidian .research-output { border-color: rgba(72, 85, 99, 0.4); } body.theme-obsidian .research-output:hover { border-color: rgba(72, 85, 99, 0.6); }
       .research-output .message-content a, 
.nebula-output .message-content a,  
.stellar-msg .message-content a {
    color: var(--link-color);
    text-decoration: none;
    border-bottom: 1px dotted var(--link-color);
    transition: color var(--transition-duration-fast), border-color var(--transition-duration-fast);
}.research-output a:hover, .nebula-output a:hover, .stellar-msg a:hover { color: var(--link-hover-color); border-bottom: 1px solid var(--link-hover-color); }
        .research-output .message-content pre, .nebula-output .message-content pre { background-color: var(--code-bg); border: 1.5px solid var(--code-border); color: var(--code-text-color); overflow-x: hidden; }
        .research-output .message-content code:not(pre>code), .nebula-output .message-content code:not(pre>code), .stellar-msg .message-content code:not(pre>code) { background-color: var(--inline-code-bg); color: var(--inline-code-text-color); }
        .research-output .message-content .table-wrapper, .nebula-output .message-content .table-wrapper, .stellar-msg .message-content .table-wrapper { border: 1px solid var(--table-border-color); overflow-x: auto; max-width: 100%; }
        .research-output .message-content table, .nebula-output .message-content table, .stellar-msg .message-content table { border: none; border-color: var(--table-border-color); }
        .research-output .message-content td, .research-output .message-content th, .nebula-output .message-content td, .nebula-output .message-content th, .stellar-msg .message-content td, .stellar-msg .message-content th { border-color: var(--table-border-color); }
        .research-output .message-content th, .nebula-output .message-content th, .stellar-msg .message-content th { background-color: rgba(0, 0, 0, 0.1); }
        .research-output .message-buttons, .nebula-output .message-buttons { margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(255, 255, 255, 0.1); display: flex; gap: 10px; justify-content: flex-start; flex-wrap: wrap; }
        .research-output::-webkit-resizer { border-width: 0 0 8px 8px; border-style: solid; border-color: transparent transparent var(--model-color-border) var(--model-color-border); background: transparent; display: block; width: 12px; height: 12px; position: absolute; bottom: 0; right: 0; cursor: nwse-resize; }

.nebula-output { background: var(--nebula-msg-bg); align-self: stretch; color: var(--primary-text-color); border: 1px solid var(--nebula-msg-border); max-width: none; margin-left: 0; box-shadow: 0 6px 20px rgba(0, 30, 50, 0.3); resize: none; overflow-x: hidden; overflow-y: hidden; min-width: 0; }.nebula-output:hover { background: var(--nebula-msg-hover-bg); border-color: var(--model-color-start); }
        .nebula-output .message-content h2 { margin-bottom: 1em; border-bottom: 1px solid var(--nebula-msg-border); padding-bottom: 0.3em; color: var(--link-color); font-size: 1.3em; }
        .nebula-output .message-content h3 { margin-top: 1.5em; margin-bottom: 0.5em; color: var(--primary-text-color); font-weight: 600; font-size: 1.1em; border-bottom: 1px dashed rgba(255, 255, 255, 0.15); padding-bottom: 0.2em; }
        .nebula-output .nebula-status { font-size: 0.8em; font-style: italic; color: var(--secondary-text-color); margin-left: 5px; }
        .nebula-output .nebula-steps-container { margin-top: 1em; }
        .nebula-output .nebula-step-content { margin-bottom: 1.5em; }
        .nebula-output .nebula-final-summary { margin-top: 1.5em; padding-top: 1em; border-top: 1px solid var(--nebula-msg-border); font-size: 0.95em; }
        .nebula-output::-webkit-resizer { border-width: 0 0 8px 8px; border-style: solid; border-color: transparent transparent var(--model-color-border) var(--model-color-border); background: transparent; display: block; width: 12px; height: 12px; position: absolute; bottom: 0; right: 0; cursor: nwse-resize; }

        .nebula-stop-auto-btn {
            padding: 6px 10px; font-size: 0.85rem; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; color: var(--secondary-text-color); background: rgba(255, 255, 255, 0.05); cursor: pointer;
            transition: background var(--transition-duration-fast) var(--transition-timing-function), border-color var(--transition-duration-fast) var(--transition-timing-function), color var(--transition-duration-fast) var(--transition-timing-function), opacity var(--transition-duration-medium);
            margin-left: 10px; vertical-align: middle; opacity: 0.7; display: none;
        }
        .nebula-stop-auto-btn:hover { background: rgba(255, 255, 255, 0.1); border-color: rgba(255, 255, 255, 0.3); color: var(--primary-text-color); opacity: 1; }
        .nebula-stop-auto-btn:disabled { cursor: not-allowed; opacity: 0.4; filter: grayscale(80%); }

        .edit-paper-btn, .download-btn, #spectrumSearchBtn, #sendBtn, .modal-buttons button, .code-block-btn, .nebula-download-btn, .nebula-confirm-btn, .nebula-regenerate-btn, #modeSelector {
            padding: 8px 16px; font-size: 0.9rem; border: none; border-radius: 6px; color: #fff; cursor: pointer;
            transition: background var(--transition-duration-medium) var(--transition-cubic-bezier), border-color var(--transition-duration-medium) var(--transition-cubic-bezier), box-shadow var(--transition-duration-medium) var(--transition-cubic-bezier), transform var(--transition-duration-fast) var(--transition-cubic-bezier), filter var(--transition-duration-fast) var(--transition-cubic-bezier), color var(--transition-duration-medium) var(--transition-cubic-bezier), opacity var(--transition-duration-fast);
            line-height: 1.4; text-align: center; height: 36px; display: inline-flex; align-items: center; justify-content: center;
        }
        .nebula-confirm-btn:disabled, .nebula-regenerate-btn:disabled, #modeSelector:disabled, #spectrumSearchBtn:disabled { cursor: not-allowed; opacity: 0.6; filter: grayscale(50%); }
        .edit-paper-btn { background: linear-gradient(45deg, #ff8e8e, #ff6b6b); box-shadow: 0 4px 10px rgba(255, 107, 107, 0.3); }
        .download-btn { background: linear-gradient(45deg, #00c292, #00d8b6); box-shadow: 0 4px 10px rgba(0, 216, 182, 0.3); }
        .nebula-download-btn { background: linear-gradient(45deg, #4facfe, #00f2fe); box-shadow: 0 4px 10px rgba(79, 172, 254, 0.3); text-decoration: none; }

        #spectrumSearchBtn, #modeSelector {
            background: rgba(255, 255, 255, 0.07); color: var(--secondary-text-color); box-shadow: none; border: 1px solid transparent;
            appearance: none; -webkit-appearance: none; -moz-appearance: none;
            background-image: none;
            padding-right: 16px;
            text-align: center; text-align-last: center;
        }
        #modeSelector option { background: var(--input-bg, #24243e); color: var(--primary-text-color, #D3D3D3); }

        #sendBtn { background: linear-gradient(45deg, var(--model-color-start), var(--model-color-end)); box-shadow: 0 4px 10px var(--model-color-shadow); border-radius: 8px; }
        .modal-buttons button { padding: 12px 20px; font-weight: 500; border-radius: 8px; }
        #cancelEditBtn { background: rgba(255, 255, 255, 0.1); color: #fff; border: 1px solid rgba(255, 255, 255, 0.2); }
        #saveEditBtn { background: linear-gradient(45deg, var(--model-color-start), var(--model-color-end)); color: #fff; box-shadow: 0 4px 15px var(--model-color-shadow); }
        .nebula-step-actions { margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(255, 255, 255, 0.1); display: flex; gap: 10px; justify-content: flex-start; transition: opacity var(--transition-duration-fast); flex-wrap: wrap; align-items: center; }
        .nebula-confirm-btn { background: linear-gradient(45deg, var(--nebula-confirm-start), var(--nebula-confirm-end)); box-shadow: 0 2px 6px var(--nebula-button-shadow); }
        .nebula-regenerate-btn { background: linear-gradient(45deg, var(--nebula-regenerate-start), var(--nebula-regenerate-end)); box-shadow: 0 2px 6px var(--nebula-button-shadow); }
        .nebula-confirm-btn:hover:not(:disabled), .nebula-regenerate-btn:hover:not(:disabled) { transform: translateY(-1px); filter: brightness(var(--nebula-button-hover-brightness)); box-shadow: 0 4px 8px var(--nebula-button-shadow); }
        .edit-paper-btn:hover, .download-btn:hover, .nebula-download-btn:hover { transform: translateY(-2px) scale(1.03); filter: brightness(1.1); }
        .edit-paper-btn:hover { box-shadow: 0 6px 15px rgba(255, 107, 107, 0.4); }
        .download-btn:hover { box-shadow: 0 6px 15px rgba(0, 216, 182, 0.4); }
        .nebula-download-btn:hover { box-shadow: 0 6px 15px rgba(79, 172, 254, 0.4); background: linear-gradient(45deg, #00f2fe, #4facfe); }

        #spectrumSearchBtn.on, #modeSelector.active-mode {
            background: linear-gradient(45deg, var(--model-color-start), var(--model-color-end)); border: 1px solid var(--model-color-border); box-shadow: 0 4px 10px var(--model-color-shadow); color: #fff;
        }
        #spectrumSearchBtn:disabled, #modeSelector:disabled {
            background: linear-gradient(45deg, #333, #444); border: 1px solid #555; color: #777; transform: none !important; filter: none !important; box-shadow: none !important;
            background-image: none;
        }
        #spectrumSearchBtn.on:hover:not(:disabled), #modeSelector.active-mode:hover:not(:disabled) {
            background: linear-gradient(45deg, var(--model-hover-color-start), var(--model-hover-color-end)); border-color: var(--model-hover-color-border); transform: translateY(-2px) scale(1.05); filter: brightness(1.15); box-shadow: 0 8px 20px var(--model-hover-color-shadow);
        }
        #spectrumSearchBtn:hover:not(:disabled):not(.on), #modeSelector:hover:not(:disabled):not(.active-mode) {
            background: rgba(255, 255, 255, 0.1); color: var(--primary-text-color); transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            background-image: none;
        }
        #spectrumSearchBtn { display: none; }

        #sendBtn:hover { background: linear-gradient(45deg, var(--model-hover-color-start), var(--model-hover-color-end)); transform: translateY(-3px) scale(1.08); filter: brightness(1.2) contrast(1.1); box-shadow: 0 10px 25px var(--model-hover-shadow-strong); }
        #sendBtn:active { transform: translateY(0) scale(1); filter: brightness(0.9); transition-duration: 0.1s; }
        #sendBtn:disabled { background: linear-gradient(45deg, #555, #666); border: 1px solid #777; color: #999; cursor: not-allowed; opacity: 0.7; pointer-events: none; transform: none !important; filter: none !important; box-shadow: none !important; }
        #cancelEditBtn:hover { background: rgba(255, 255, 255, 0.15); transform: translateY(-2px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); }
        #saveEditBtn:hover { background: linear-gradient(45deg, var(--model-hover-color-start), var(--model-hover-color-end)); transform: translateY(-2px); box-shadow: 0 8px 20px var(--model-hover-color-shadow); }
        #saveEditBtn:active, #cancelEditBtn:active { transform: translateY(0); }

        #statusBar { position: fixed; bottom: 0; left: 50%; transform: translateX(-50%); width: calc(100% - 40px); margin: 0 auto; text-align: center; padding: 8px; font-size: 0.95rem; color: var(--status-bar-idle-color); background: var(--status-bar-idle-bg); border-radius: 8px; height: 36px; opacity: 0.7; display: flex; align-items: center; justify-content: center; z-index: 99; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; border: 1px solid transparent; transition: all 0.8s var(--transition-cubic-bezier), background var(--transition-duration-medium) var(--transition-timing-function), color var(--transition-duration-medium) var(--transition-timing-function), box-shadow var(--transition-duration-medium) var(--transition-timing-function), border-color var(--transition-duration-medium) var(--transition-timing-function); max-width: 1200px; }
        #statusBar.active { background: var(--status-bar-bg); color: var(--status-bar-color); box-shadow: 0 0 20px var(--status-bar-shadow); border: 1px solid var(--model-color-border); opacity: 1; transform: translateY(-5px) translateX(-50%); white-space: normal; padding: 12px; animation: statusBarPulse 2.5s infinite alternate ease-in-out; min-height: 36px; }
        @keyframes statusBarPulse { 0% { box-shadow: 0 0 15px var(--status-bar-shadow); opacity: 0.9; } 100% { box-shadow: 0 0 25px var(--status-bar-shadow); opacity: 1; } }
        #statusBar.error { background: rgba(255, 107, 107, 0.3); color: #ff8e8e; box-shadow: 0 0 20px rgba(255, 107, 107, 0.4); border-color: rgba(255, 107, 107, 0.5); animation: none; }

        #inputContainer { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); width: calc(100% - 40px); margin: 0 auto; padding: 8px 16px; background: var(--input-bg); backdrop-filter: blur(12px); border-radius: 12px; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2); border: 1px solid var(--input-border); z-index: 100; display: flex; flex-direction: column; gap: 5px; transition: background var(--transition-duration-medium) var(--transition-timing-function), border-color var(--transition-duration-medium) var(--transition-timing-function), box-shadow var(--transition-duration-medium) var(--transition-timing-function); max-width: 1200px; box-sizing: border-box; }
        #inputContainer:focus-within { background: var(--input-focus-bg); box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3); border: 1px solid var(--input-focus-border); }
        #chatInput { width: 100%; padding: 8px 12px; font-size: 1rem; border: none; background: transparent; color: var(--primary-text-color); outline: none; resize: none; overflow-y: auto; min-height: 24px; max-height: 240px; transition: background var(--transition-duration-medium) var(--transition-timing-function); }
        #chatInput::placeholder { color: rgba(255, 255, 255, 0.5); transition: color var(--transition-duration-medium) var(--transition-timing-function); }
        #chatInput:focus::placeholder { color: rgba(255, 255, 255, 0.3); }
        .input-buttons { display: flex; align-items: center; justify-content: space-between; width: 100%; gap: 8px; }
        .left-buttons, .right-buttons { display: flex; align-items: center; gap: 8px; justify-content: center;}
        #modelSelectWidthHelper { position: absolute; visibility: hidden; white-space: nowrap; font-size: 0.9rem; font-family: 'Poppins', sans-serif; padding: 8px 14px; display: inline-block; }

        #modelSelect {
            background: linear-gradient(45deg, var(--model-color-start), var(--model-color-end)); border: 1px solid var(--model-color-border); box-shadow: 0 0 10px var(--model-color-shadow), inset 0 0 5px var(--model-color-shadow-inset); color: #ffffff; padding: 8px 14px; font-size: 0.9rem; border-radius: 6px; cursor: pointer; appearance: none; -webkit-appearance: none; -moz-appearance: none; position: relative; text-align: center; text-align-last: center; width: auto; min-width: 80px; transition: background var(--transition-duration-medium) var(--transition-cubic-bezier), border-color var(--transition-duration-medium) var(--transition-cubic-bezier), box-shadow var(--transition-duration-medium) var(--transition-cubic-bezier), transform var(--transition-duration-fast) var(--transition-cubic-bezier), filter var(--transition-duration-fast) var(--transition-cubic-bezier); height: 36px;
            background-image: none;
            padding-right: 14px;
        }
        #modelSelect:hover, #modelSelect:focus {
            background: linear-gradient(45deg, var(--model-hover-color-start), var(--model-hover-color-end)); border-color: var(--model-hover-color-border); box-shadow: 0 0 15px var(--model-hover-color-shadow), inset 0 0 8px var(--model-hover-color-shadow-inset); color: #ffffff; transform: translateY(-2px) scale(1.03); filter: brightness(1.1); outline: none;
             background-image: none;
             padding-right: 14px;
        }
        #modelSelect option { background: var(--input-bg, #24243e); color: var(--primary-text-color, #D3D3D3); padding: 10px 14px; text-align: left; transition: background var(--transition-duration-fast) var(--transition-timing-function), color var(--transition-duration-fast) var(--transition-timing-function); }
        #modelSelect option:hover { background: linear-gradient(45deg, var(--model-hover-color-start), var(--model-hover-color-end)); color: #ffffff; }
        #modelSelect option:checked { background: linear-gradient(45deg, var(--model-color-start), var(--model-color-end)); color: #ffffff; font-weight: 600; }
        #modelSelect option:disabled { color: #888 !important; background-color: #555 !important; cursor: not-allowed !important; opacity: 0.7; pointer-events: none; }
        #modelSelect:disabled { background-image: none; }

        #editModalBackdrop, #regenerateModalBackdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(15, 12, 41, 0.8); backdrop-filter: blur(8px); display: none; align-items: center; justify-content: center; z-index: 999; animation: fadeIn var(--transition-duration-medium) var(--transition-timing-function); }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .modal-content { background: linear-gradient(135deg, rgba(48, 43, 99, 0.8), rgba(36, 36, 62, 0.9)); border: 1px solid var(--model-color-border); border-radius: 16px; backdrop-filter: blur(20px); padding: 30px; width: 90%; max-width: 800px; box-shadow: 0 20px 50px rgba(0, 0, 0, 0.4); animation: modalIn 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55); transform: translateY(0) scale(1); overflow-y: auto; max-height: 90vh; transition: border-color var(--transition-duration-medium) var(--transition-timing-function); }
        @keyframes modalIn { from { opacity: 0; transform: translateY(40px) scale(0.9); } to { opacity: 1; transform: translateY(0) scale(1); } }
        .modal-content h2 { font-size: 1.5rem; margin-bottom: 20px; text-align: center; background: linear-gradient(45deg, var(--model-color-start, #7b61ff), var(--model-color-end, #b554ff)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; letter-spacing: 1px; transition: background var(--transition-duration-medium) var(--transition-timing-function); }
        #editMarkdownInput { width: 100%; padding: 15px; font-size: 1rem; border: 1px solid var(--model-color-border); border-radius: 8px; background: rgba(0, 0, 0, 0.4); color: var(--primary-text-color); margin-bottom: 25px; outline: none; box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.2); min-height: 250px; resize: vertical; overflow-y: auto; transition: all var(--transition-duration-medium) var(--transition-timing-function); font-family: monospace; }
        #editMarkdownInput:focus { border: 1px solid var(--model-hover-color-border); background: rgba(0, 0, 0, 0.5); box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.2), 0 0 15px var(--model-hover-color-shadow); }
        .modal-buttons { display: flex; justify-content: flex-end; gap: 15px; margin-top: 10px; flex-wrap: wrap; }
        #regenerateFeedbackInput { width: 100%; padding: 12px; font-size: 0.95rem; border: 1px solid var(--model-color-border); border-radius: 6px; background: rgba(0, 0, 0, 0.4); color: var(--primary-text-color); margin-bottom: 20px; outline: none; box-shadow: inset 0 1px 5px rgba(0, 0, 0, 0.2); min-height: 100px; resize: vertical; transition: all var(--transition-duration-medium) var(--transition-timing-function); font-family: 'Poppins', sans-serif; }
        #regenerateFeedbackInput:focus { border-color: var(--model-hover-color-border); background: rgba(0, 0, 0, 0.5); box-shadow: inset 0 1px 5px rgba(0, 0, 0, 0.2), 0 0 10px var(--model-hover-color-shadow); }
        #regenerateWithoutFeedbackBtn { background: var(--stellar-msg-bg) !important; color: var(--secondary-text-color) !important; border: 1px solid var(--stellar-msg-border) !important; padding: 12px 20px; font-weight: 500; border-radius: 8px; margin-left: 10px; }
        #regenerateWithoutFeedbackBtn:hover { background: var(--stellar-msg-hover-bg) !important; color: var(--primary-text-color) !important; transform: translateY(-2px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); }
        .modal-buttons #cancelRegenerateBtn { background: rgba(255, 255, 255, 0.2); color: var(--primary-text-color); border: 1px solid rgba(255, 255, 255, 0.3); padding: 12px 20px; font-weight: 500; border-radius: 8px; cursor: pointer; transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; }
        .modal-buttons #cancelRegenerateBtn:hover { background: rgba(255, 255, 255, 0.3); transform: translateY(-2px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); }
        .modal-buttons #saveRegenerateBtn { background: linear-gradient(45deg, var(--model-color-start, #7b61ff), var(--model-color-end, #b554ff)); color: #fff; box-shadow: 0 4px 15px var(--model-color-shadow, rgba(123, 97, 255, 0.3)); padding: 12px 20px; font-weight: 500; border-radius: 8px; border: none; cursor: pointer; transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; }
        .modal-buttons #saveRegenerateBtn:hover { background: linear-gradient(45deg, var(--model-hover-color-start, #b554ff), var(--model-hover-color-end, #7b61ff)); transform: translateY(-2px); box-shadow: 0 8px 20px var(--model-hover-color-shadow, rgba(123, 97, 255, 0.5)); }
        .modal-buttons #regenerateWithoutFeedbackBtn { background: var(--stellar-msg-bg) !important; color: var(--secondary-text-color) !important; border: 1px solid var(--stellar-msg-border) !important; padding: 12px 20px; font-weight: 500; border-radius: 8px; margin-left: 10px; cursor: pointer; transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; }
        #regenerateWithoutFeedbackBtn:hover { background: var(--stellar-msg-hover-bg) !important; color: var(--primary-text-color) !important; transform: translateY(-2px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); }
        #saveRegenerateBtn { background: linear-gradient(45deg, var(--model-color-start), var(--model-color-end)); color: #fff; box-shadow: 0 440px 15px var(--model-color-shadow); padding: 12px 20px; font-weight: 500; border-radius: 8px; border: none; cursor: pointer; transition: background var(--transition-duration-medium) var(--transition-cubic-bezier), border-color var(--transition-duration-medium) var(--transition-cubic-bezier), box-shadow var(--transition-duration-medium) var(--transition-cubic-bezier), transform var(--transition-duration-fast) var(--transition-cubic-bezier), filter var(--transition-duration-fast) var(--transition-cubic-bezier), color var(--transition-duration-medium) var(--transition-cubic-bezier), opacity var(--transition-duration-fast); line-height: 1.4; }
        #saveRegenerateBtn:hover { background: linear-gradient(45deg, var(--model-hover-color-start), var(--model-hover-color-end)); transform: translateY(-2px); box-shadow: 0 8px 20px var(--model-hover-color-shadow); }
        #cancelRegenerateBtn { background: rgba(255, 255, 255, 0.1); color: var(--primary-text-color); border: 1px solid rgba(255, 255, 255, 0.2); padding: 12px 20px; font-weight: 500; border-radius: 8px; cursor: pointer; transition: background var(--transition-duration-medium) var(--transition-cubic-bezier), border-color var(--transition-duration-medium) var(--transition-cubic-bezier), box-shadow var(--transition-duration-medium) var(--transition-cubic-bezier), transform var(--transition-duration-fast) var(--transition-cubic-bezier), filter var(--transition-duration-fast) var(--transition-cubic-bezier), color var(--transition-duration-medium) var(--transition-cubic-bezier), opacity var(--transition-duration-fast); line-height: 1.4; }
        #cancelRegenerateBtn:hover { background: rgba(255, 255, 255, 0.15); transform: translateY(-2px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); }
        #regenerateWithoutFeedbackBtn { background: var(--stellar-msg-bg) !important; color: var(--secondary-text-color) !important; border: 1px solid var(--stellar-msg-border) !important; padding: 12px 20px; font-weight: 500; border-radius: 8px; margin-left: 10px; cursor: pointer; transition: background var(--transition-duration-medium) var(--transition-cubic-bezier), border-color var(--transition-duration-medium) var(--transition-cubic-bezier), box-shadow var(--transition-duration-medium) var(--transition-cubic-bezier), transform var(--transition-duration-fast) var(--transition-cubic-bezier), filter var(--transition-duration-fast) var(--transition-cubic-bezier), color var(--transition-duration-medium) var(--transition-cubic-bezier), opacity var(--transition-duration-fast); line-height: 1.4; }
        #regenerateWithoutFeedbackBtn:hover { background: var(--stellar-msg-hover-bg) !important; color: var(--primary-text-color) !important; transform: translateY(-2px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); }

        @media (max-width: 1300px) { #chatContainer { padding-left: 30px; padding-right: 30px; } #inputContainer, #statusBar { max-width: calc(100% - 60px); } }
        @media (max-width: 768px) {
            header { padding: 15px; }
            .clear-icon { font-size: 1rem; }
            #chatContainer { padding: 20px 15px; padding-bottom: 200px; }
            .message:not(.research-output):not(.nebula-output) { max-width: 95%; }
            .research-output, .nebula-output { min-width: calc(100% - 30px); }
            #statusBar { margin: 0 15px; width: calc(100% - 30px); max-width: calc(100% - 30px); transform: translateY(15px) translateX(-50%); left: 50%; }
            #statusBar.active { transform: translateY(5px) translateX(-50%); }
            .modal-content { padding: 20px; max-width: calc(100% - 30px); }
            #inputContainer { padding: 8px; width: calc(100% - 30px); max-width: calc(100% - 30px); left: 50%; transform: translateX(-50%); }
            #sidebar { width: 250px; }
            .profile-modal-content { max-width: calc(100% - 30px); }
        }
        @media (max-width: 480px) {
            .input-buttons { flex-direction: column; align-items: stretch; gap: 8px; }
            .left-buttons, .right-buttons { justify-content: space-between; width: 100%; }
            .right-buttons { margin-top: 5px; }
            #modelSelect { flex-grow: 1; }
            #modeSelector { flex-grow: 1; }
            #sendBtn { padding: 10px; }
            .research-output, .nebula-output { min-width: calc(100% - 30px); }
            .modal-buttons { flex-wrap: wrap; justify-content: center; }
            .modal-buttons button { margin-bottom: 5px; }
            .header-left, .header-right { gap: 8px; }
            #chatTitle { font-size: 1.4rem; margin-left: 10px; }
            #profileIcon { width: 35px; height: 35px; font-size: 1rem; }
        }

        
.message-content { word-wrap: break-word; overflow-wrap: break-word; white-space: normal; position: relative; }
.code-content-original { position: relative; margin: 1.2em 0; }
.message-content pre { white-space: pre-wrap; overflow-x: auto; background-color: var(--code-bg); padding: 18px; padding-top: 45px; border-radius: 8px; border: 1.5px solid var(--code-border); color: var(--code-text-color); transition: background-color var(--transition-duration-medium), border-color var(--transition-duration-medium), color var(--transition-duration-medium), box-shadow var(--transition-duration-medium); box-shadow: 0 3px 8px rgba(0, 0, 0, 0.25); font-family: 'Fira Code', Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; font-size: 0.95rem; line-height: 1.6; tab-size: 4; -moz-tab-size: 4; display: block; position: relative; }

.code-controls {
    position: absolute;
    top: 8px;
    right: 8px;
    z-index: 2;
    display: flex;
    gap: 8px;
    opacity: 1;
    visibility: hidden;
    transition: opacity var(--transition-duration-fast) ease, visibility var(--transition-duration-fast) ease;
}
.code-content-original:hover .code-controls {
    opacity: 0.8;
    visibility: visible;
}
.code-controls:hover {
    opacity: 1;
}
.code-controls button {
    background-color: var(--code-btn-bg);
    color: var(--code-btn-color);
    border: 1px solid transparent; 
    border-radius: 2px;
    padding: 6px 12px;
    font-size: 0.8rem;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 5px;
    transition: background-color var(--transition-duration-fast) ease, color var(--transition-duration-fast) ease, transform 0.2s ease;
    text-shadow: 0.5px 0.5px 0 black, -0.5px -0.5px 0 black, 0.5px -0.5px 0 black, -0.5px 0.5px 0 black;
}
.code-controls button:hover {
    background-color: var(--code-btn-hover-bg);
     border: var(--code-btn-hover-border);
    color: var(--code-btn-hover-color);
    transform: scale(1.05);
}
.code-controls .copy-code-btn.copied {
    background-color: var(--copy-btn-copied-bg);
    color: var(--copy-btn-copied-color);
}
.code-controls svg {
    width: 14px;
    height: 14px;
    fill: currentColor;
}

.code-preview-container { position: relative; margin: 1.2em 0; }
.code-preview-iframe { width: 100%; height: 400px; border: 1px solid var(--code-border); border-radius: 8px; background-color: #ffffff; display: block; margin: 0; }
.message-content code:not(pre>code) { background-color: var(--inline-code-bg); padding: 0.2em 0.4em; margin: 0; font-size: 85%; border-radius: 3px; color: var(--inline-code-text-color); transition: background-color var(--transition-duration-medium), color var(--transition-duration-medium); }
.message-content .table-wrapper { overflow-x: auto; max-width: 100%; margin: 1em 0; border: 1px solid var(--table-border-color); border-radius: 4px; transition: border-color var(--transition-duration-medium); }
.message-content table { width: 100%; border-collapse: collapse; margin: 0; border: none; }
.message-content td, .message-content th { padding: 10px; border: 1px solid var(--table-border-color); text-align: left; word-break: break-word; border-width: 0 0 1px 0; transition: border-color var(--transition-duration-medium); }
.message-content tr td:first-child, .message-content tr th:first-child { border-left: none; }
.message-content tr td:last-child, .message-content tr th:last-child { border-right: none; }
.message-content tr:last-child td { border-bottom: none; }
.message-content th { background-color: rgba(0, 0, 0, 0.1); font-weight: 600; transition: background-color var(--transition-duration-medium); }
.hljs { background: transparent !important; color: inherit !important; border-radius: inherit; }
.hljs-comment, .hljs-quote { color: #8a93a0; font-style: italic; }
.hljs-keyword, .hljs-selector-tag, .hljs-built_in, .hljs-name, .hljs-tag { color: var(--link-color); font-weight: 600; }
.hljs-string, .hljs-regexp, .hljs-symbol, .hljs-variable, .hljs-template-variable, .hljs-link, .hljs-selector-attr, .hljs-selector-pseudo { color: #9ece6a; }
.hljs-number, .hljs-literal { color: #fabd2f; }
.katex-display { text-align: center; margin: 1em 0; }
.katex-display > .katex { display: inline-block; text-align: initial; }


        .output-copy-btn-container {
            position: absolute;
            bottom: 10px;
            right: 10px;
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--tooltip-transition-duration) ease, visibility var(--tooltip-transition-duration) ease;
            z-index: 2;
        }
        .message:hover .output-copy-btn-container {
            opacity: 1;
            visibility: visible;
        }
        .output-copy-btn {
            background: var(--output-copy-btn-bg);
            color: var(--output-copy-btn-color);
            border: none;
            border-radius: 6px;
            padding: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            position: relative;
            transition: background var(--tooltip-transition-duration) ease, color var(--tooltip-transition-duration) ease;
        }
        .output-copy-btn:hover {
            background: var(--output-copy-btn-hover-bg);
            color: var(--output-copy-btn-hover-color);
        }
        .output-copy-btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }
        .output-copy-btn.copied {
            background: var(--output-copy-btn-copied-bg);
            color: var(--output-copy-btn-copied-color);
        }
        .copy-tooltip {
            position: absolute;
            bottom: calc(100% + 5px);
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--tooltip-bg);
            color: var(--tooltip-color);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--tooltip-transition-duration) ease, visibility var(--tooltip-transition-duration) ease, transform var(--tooltip-transition-duration) ease;
            pointer-events: none;
            z-index: 10;
        }
        .output-copy-btn-container:hover .copy-tooltip:not(.visible) {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(-2px);
        }
        .copy-tooltip.visible {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(-2px);
        }
                :root {
            --color-1: #a972ff; --color-2: #82aaff; --color-3: #f77fbe;
            --theme-color-gradient-start: #be93fd; --theme-color-gradient-end: #9164ff;
            --card-bg: rgba(25, 20, 40, 0.45); --card-border: rgba(170, 114, 255, 0.25);
            --base-bg: #100E19; --primary-text-color: #f0f0f0; --secondary-text-color: #c0b8d8;
        }
        #metaball-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
        
        #authContainer { 
            display: none; 
            align-items: center; 
            justify-content: center; 
            min-height: 100vh; 
            width: 100%;
            height: 100%;
            position: fixed;
            top: 0;
            left: 0;
            padding: 20px; 
            z-index: 101; 
            perspective: 2000px; 
            transition: opacity 0.5s ease-in-out;
            opacity: 0;
        }
        #authContainer.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        #authContainer.fade-in {
            opacity: 1;
            pointer-events: all;
        }

        .auth-card { 
            width: 100%; max-width: 380px; 
            background: var(--card-bg); 
            backdrop-filter: blur(25px) saturate(120%); 
            border: 1px solid var(--card-border); 
            border-radius: 16px; 
            padding: 40px 35px; 
            box-shadow: 0 15px 60px rgba(0, 0, 0, 0.6); 
            animation: fadeIn 0.8s 0.2s ease-out forwards; 
            opacity: 0; 
            position: relative; 
            overflow: hidden; 
            transform-style: preserve-3d; 
            transition: transform 0.1s linear; 
        }
        .auth-card::before { content: ''; position: absolute; top: var(--y, 0); left: var(--x, 0); width: 200px; height: 200px; background: radial-gradient(circle closest-side, var(--color-1), transparent); transform: translate(-50%, -50%); opacity: 0.15; transition: top 0.2s linear, left 0.2s linear; pointer-events: none; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px) scale(0.95); } to { opacity: 1; transform: translateY(0) scale(1); } }
        .auth-card-header { text-align: center; margin-bottom: 35px; transform: translateZ(20px); }
        .welcome-text { font-size: 1rem; font-weight: 300; color: var(--secondary-text-color); margin-bottom: 5px; }
        .animated-title { font-size: 1.8rem; font-weight: 500; min-height: 2.2rem; display: flex; justify-content: center; align-items: center; background: linear-gradient(45deg, var(--theme-color-gradient-start), var(--theme-color-gradient-end)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .text-cursor { display: inline-block; margin-left: 3px; background: var(--color-1); width: 3px; animation: blink 1s step-end infinite; }
        @keyframes blink { 50% { opacity: 0; } }
        
        .auth-card-body { position: relative; min-height: 220px; transform: translateZ(10px); }
        .form-fields-container { display: flex; flex-direction: column; gap: 25px; position: absolute; width: 100%; top: 0; left: 0; }
        .is-exiting { animation: slideFadeOut 0.3s forwards ease-in-out; pointer-events: none; }
        .is-entering { animation: slideFadeIn 0.4s 0.2s forwards ease-out; }
        @keyframes slideFadeOut { from { opacity: 1; transform: translateY(0); } to { opacity: 0; transform: translateY(-10px); } }
        @keyframes slideFadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        .form-group label { font-size: 0.9rem; color: var(--secondary-text-color); margin-bottom: 8px; display: block; text-align: left; }
        .form-group input { width: 100%; padding: 8px 0; font-size: 1rem; color: var(--primary-text-color); background: transparent; border: none; border-bottom: 1px solid rgba(255, 255, 255, 0.2); outline: none; transition: border-color 0.3s ease; }
        .form-group input:-webkit-autofill,
        .form-group input:-webkit-autofill:hover,
        .form-group input:-webkit-autofill:focus,
        .form-group input:-webkit-autofill:active {
            -webkit-background-clip: text;
            -webkit-text-fill-color: var(--primary-text-color);
            transition: background-color 5000s ease-in-out 0s;
            box-shadow: inset 0 0 20px 20px var(--card-bg);
        }
        .form-group input:focus { border-bottom-color: var(--color-1); }
        
        .auth-button { width: 100%; padding: 14px; margin-top: 15px; font-size: 1rem; font-weight: 500; color: #fff; background: linear-gradient(45deg, var(--theme-color-gradient-start), var(--theme-color-gradient-end)); border: none; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; }
        .auth-button:hover { transform: translateY(-3px) scale(1.02); box-shadow: 0 8px 25px rgba(145, 100, 255, 0.3); }
        .auth-button:active { transform: translateY(0) scale(0.98); box-shadow: 0 2px 10px rgba(145, 100, 255, 0.2); transition-duration: 0.1s; }
        
        .auth-card-footer { margin-top: 25px; text-align: center; font-size: 0.9rem; color: var(--secondary-text-color); transform: translateZ(20px); }
        .auth-card-footer a { color: var(--color-1); font-weight: 500; text-decoration: none; cursor: pointer; }
        .auth-subtitle { color: var(--secondary-text-color); margin-top: 8px; font-weight: 300; min-height: 1.2rem; text-align: center; }

        .auth-message {
            margin-top: 15px; padding: 10px; border-radius: 6px; font-size: 0.9rem;
            font-weight: 500; display: block; animation: messageFadeIn 0.4s ease forwards;
        }
        @keyframes messageFadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); }}
        .auth-message.success { background-color: rgba(0, 194, 146, 0.2); color: var(--auth-message-success); border: 1px solid var(--auth-message-success); }
        .auth-message.error { background-color: rgba(255, 107, 107, 0.2); color: var(--auth-message-error); border: 1px solid var(--auth-message-error); }
                

        :root { 
            --cyber-green: #00ff88;
            --feedback-color: var(--cyber-green);
            --feedback-shadow: rgba(0, 255, 136, 0.4);
        }

      
        .file-feedback-active {
            animation: pulse-upload 0.3s ease; 
            
        }
        @keyframes pulse-upload {
            0% { box-shadow: 0 0 0 rgba(0,0,0,0); outline: 2px dashed transparent; outline-offset: 0px; }
            50% { box-shadow: 0 0 15px var(--feedback-shadow); outline: 2px dashed var(--feedback-color); outline-offset: 3px; }
            100% { box-shadow: 0 0 0 rgba(0,0,0,0); outline: 2px dashed transparent; outline-offset: 0px; }
        }

        
        #inputContainer.active-drop {
            border: 2px dashed var(--cyber-green) !important; 
            background: rgba(0, 255, 136, 0.05) !important; 
        }
        .drop-overlay {
            position: absolute;
            inset: 0; 
            background: rgba(26, 26, 42, 0.7); 
            color: var(--primary-text-color);
            font-size: 1rem;
            font-weight: 600;
            display: grid; 
            place-items: center;
            border-radius: inherit; 
            z-index: 101; 
            pointer-events: none; 
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }
        #inputContainer.active-drop .drop-overlay {
            opacity: 1;
            visibility: visible;
        }

       
.code-preview-container:-webkit-full-screen {
    width: 100%;
    height: 100%;
    background: #fff;
    padding: 0;
    margin: 0;
}
.code-preview-container:fullscreen {
    width: 100%;
    height: 100%;
    background: #fff;
    padding: 0;
    margin: 0;
}
.code-preview-container:fullscreen .code-preview-iframe {
    height: 100%;
}

#live-preview-container {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 450px;
    height: 350px;
    background: var(--stellar-msg-bg);
    border: 1px solid var(--model-color-border);
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
    z-index: 1000;
    display: none; 
    flex-direction: column;
    animation: preview-in 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
    backdrop-filter: blur(8px);
}
@keyframes preview-in {
    from { opacity: 0; transform: translateY(20px) scale(0.95); }
    to { opacity: 1; transform: translateY(0) scale(1); }
}
#live-preview-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    background: rgba(0, 0, 0, 0.2);
    border-bottom: 1px solid var(--stellar-msg-border);
    flex-shrink: 0;
    cursor: move;
}
.message.highlight {
    animation: highlight-fade 2s forwards;
    box-shadow: 0 0 20px 5px var(--model-color-shadow);
    border-color: var(--model-color-end);
}

@keyframes highlight-fade {
    0% {
        box-shadow: 0 0 20px 5px var(--model-color-shadow);
        border-color: var(--model-color-end);
        transform: scale(1.02);
    }
    100% {
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        border-color: transparent;
        transform: scale(1);
    }
}

.highlighted-text {
    background-color: yellow; 
    color: black;
    padding: 0.1em 0;
    border-radius: 2px;
}

#live-preview-title {
    font-size: 0.8rem;
    color: var(--secondary-text-color);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
#live-preview-close-btn {
    background: none;
    border: none;
    color: var(--secondary-text-color);
    font-size: 1.5rem;
    cursor: pointer;
    padding: 0 5px;
    line-height: 1;
}
#live-preview-close-btn:hover {
    color: var(--primary-text-color);
}
#live-preview-content {
    flex-grow: 1;
    position: relative;
    padding: 5px;
    border-radius: 0 0 12px 12px;
}
#live-preview-iframe {
    width: 100%;
    height: 100%;
    border: none;
    background: #fff;
    border-radius: 0 0 8px 8px;
}
#live-preview-fallback {
    position: absolute;
    top: 5px;
    left: 5px;
    right: 5px;
    bottom: 5px;
    background: #f0f0f0;
    color: #333;
    display: none; 
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    padding: 20px;
    border-radius: 0 0 8px 8px;
}
#live-preview-fallback a {
    color: #555;
    background: #ddd;
    padding: 8px 12px;
    border-radius: 4px;
    text-decoration: none;
    margin-top: 15px;
}
#live-preview-fallback a:hover {
    background: #ccc;
}
#chatScrollToBottomBtn {
    position: fixed; 
    bottom: 125px; 
    right: 40px;
    width: 44px;
    height: 44px;
    background: var(--input-bg);
    backdrop-filter: blur(8px);
    color: var(--secondary-text-color);
    border: 1px solid var(--input-border);
    border-radius: 50%;
    cursor: pointer;
    display: none; /* <-- HIDE BY DEFAULT */
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    z-index: 99;
    transition: background 0.2s ease, transform 0.2s ease, display 0s;
}

#chatScrollToBottomBtn:hover {
    background: var(--input-focus-bg);
    color: var(--primary-text-color);
    border-color: var(--input-focus-border);
    transform: scale(1.05);
}

.chat-item-token-counter {
    display: none; 
    margin-top: 8px;
}
.chat-item.active .chat-item-token-counter {
    display: block; 
}
.chat-item-token-counter .token-text {
    font-size: 0.7rem;
    color: var(--secondary-text-color);
    opacity: 0.8;
    margin-bottom: 3px;
    display: block;
    line-height: 1;
}
.chat-item-token-counter .token-bar-track {
    width: 100%;
    height: 4px;
    background-color: rgba(0, 0, 0, 0.2);
    border-radius: 4px;
    overflow: hidden;
}
.chat-item-token-counter .token-bar-fill {
    width: 0%;
    height: 100%;
    background-color: var(--token-bar-fill-low);
    border-radius: 4px;
    transition: width 0.5s ease-out, background-color 0.5s ease-out;
}
#voiceInputBtn.listening {
    background-color: rgba(211, 16, 39, 0.2);
    color: #ff8e8e;
    border: 1px solid rgba(255, 107, 107, 0.5);
    animation: pulse-mic 1.2s infinite;
}
@keyframes pulse-mic {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}
#stopBtn {
    background: linear-gradient(45deg, #ff8e8e, #ff6b6b);
    box-shadow: 0 4px 10px rgba(255, 107, 107, 0.3);
    border-radius: 8px;
    padding: 8px; 
}
#stopBtn:hover {
    background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
    transform: translateY(-2px);
    box-shadow: 0 6px 15px rgba(255, 107, 107, 0.4);
}

.user-msg {
    position: relative;
}

.edit-prompt-wrapper {
    position: absolute;
    left: -35px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
}

.user-msg:hover .edit-prompt-wrapper {
    opacity: 1;
}

.edit-prompt-icon {
    cursor: pointer;
    padding: 5px;
    border-radius: 50%;
    background-color: rgba(0,0,0,0.1);
    display: flex;
    align-items: center;
    justify-content: center;
}

.edit-prompt-icon svg {
    width: 18px;
    height: 18px;
    color: var(--secondary-text-color);
    transition: color 0.2s ease;
}

.edit-prompt-icon:hover svg {
    color: var(--model-color-start);
}

.edit-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 100%;
}

.edit-textarea {
    width: 100%;
    min-height: 60px;
    background-color: transparent;
    border: 1px solid var(--model-color-border);
    border-radius: 8px;
    color: var(--primary-text-color);
    font-family: 'Poppins', sans-serif;
    font-size: 1rem;
    padding: 10px;
    resize: vertical;
    outline: none;
}

.edit-buttons {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}

.edit-cancel-btn, .edit-save-btn {
    padding: 6px 12px;
    border-radius: 6px;
    border: 1px solid transparent;
    font-size: 0.9rem;
    cursor: pointer;
    transition: background-color 0.2s, border-color 0.2s;
}

.edit-cancel-btn {
    background-color: rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.2);
    color: var(--primary-text-color);
}
.edit-cancel-btn:hover {
    background-color: rgba(255, 255, 255, 0.2);
}

.edit-save-btn {
    background: var(--model-color-start);
    color: #fff;
}
.edit-save-btn:hover {
    background: var(--model-hover-color-start);
}

#voiceWaveCanvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 101; 
    opacity: 0;
    transition: opacity 0.5s ease-in-out;
    pointer-events: none;
}
#voiceWaveCanvas.visible {
    opacity: 1;
}

.voice-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
   
    background-color: var(--voice-overlay-bg, rgba(58, 56, 85, 0.5)); 
    backdrop-filter: blur(1px); 
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-end;
    padding-bottom: 5vh;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
    z-index: 102;
}
.voice-overlay.visible {
    opacity: 1;
    pointer-events: all;
}

.voice-prompt {
    color: rgba(255, 255, 255, 0.85);
    font-size: 1.5rem;
    font-weight: 500;
    margin-bottom: 2rem;
    text-shadow: 0 2px 10px rgba(0,0,0,0.5);
}

.visualizer-container {
    width: 90%;
    max-width: 720px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.voice-controls {
    display: flex;
    gap: 20px;
    background: var(--input-bg);
    border: 1px solid var(--input-border);
    padding: 12px;
    border-radius: 28px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
}

.voice-controls button {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 50%;
    width: 50px;
    height: 50px;
    display: grid;
    place-items: center;
    cursor: pointer;
    transition: background-color 0.2s ease, transform 0.2s ease;
}
.voice-controls svg {
    width: 26px;
    height: 26px;
    color: #d0d0d0;
}
.voice-controls button:hover {
    background: rgba(255, 255, 255, 0.1);
    transform: translateY(-2px);
}

#confirmVoiceBtn {
    background-color: var(--model-color-start);
}
#confirmVoiceBtn:hover {
    background-color: var(--model-hover-color-start);
}
#confirmVoiceBtn svg {
    color: #fff;
}
      
        #codeLabContainer {
            position: fixed;
            top: 61px;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            gap: 1px;
            background-color: var(--input-border);
        }
        #ai-mentor-panel, #workspace-panel {
            padding: 20px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--stellar-msg-bg);
            border: none !important;
        }
        #ai-mentor-panel { width: 40%; }
        #workspace-panel { width: 60%; }
#ai-mentor-panel {
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* This is the key */
        }
        #newProblemBtn {
            background: none;
            border: 1px solid var(--input-border);
            margin-bottom: 20px;
            display: none;
            flex-shrink: 0;
        }
        #mentor-content-scroller {
            flex-grow: 1;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--scrollbar-thumb-start) var(--scrollbar-track-bg);
            padding-right: 10px;
            min-height: 0;
        }
        #problem-generation-container {
            margin-top: auto;
            flex-shrink: 0;
            padding-top: 15px;
            max-height: 250px;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
        }
        #problem-generation-container > h3 {
            text-align: center;
            color: var(--secondary-text-color);
            margin-bottom: 20px;
            cursor: pointer;
        }
        #problemRequestInput {
            width: 100%; height: 80px; background: var(--input-bg); border: 1px solid var(--input-border);
            color: var(--primary-text-color); border-radius: 6px; padding: 10px; font-family: 'Poppins', sans-serif; resize: vertical;
        }
        .problem-gen-buttons {
            display: flex; justify-content: space-between; align-items: center; margin-top: 10px;
        }
        #loadRandomProblemBtn { background: none; border: 1px solid var(--input-border); }
        #ai-mentor-panel.html-view-active #problem-generation-container {
            border-top: 1px solid var(--input-border);
            max-height: 50px; /* Collapsed height */
        }
        #ai-mentor-panel.html-view-active #problem-generation-container.expanded {
            max-height: 250px; /* Expanded height */
        }
        #ai-mentor-panel.html-view-active #problem-generation-container > form {
            display: none;
        }
        #ai-mentor-panel.html-view-active #problem-generation-container.expanded > form {
            display: block;
        }
        #ai-assist-responses-container { margin-top: 20px; }
        .codelab-problem-title { font-size: 1.6rem; font-weight: 600; margin-bottom: 5px; color: var(--primary-text-color); border-bottom: 1px solid var(--stellar-msg-border); padding-bottom: 10px; flex-shrink: 0; }
        .codelab-problem-meta { display: flex; gap: 10px; align-items: center; margin-bottom: 20px; flex-shrink: 0; }
        .codelab-difficulty-tag { padding: 4px 10px; border-radius: 15px; font-size: 0.8rem; font-weight: 500; color: #fff; }
        .codelab-difficulty-tag.Easy { background-color: rgba(0, 194, 146, 0.7); }
        .codelab-difficulty-tag.Medium { background-color: rgba(250, 189, 47, 0.7); }
        .codelab-difficulty-tag.Hard { background-color: rgba(211, 16, 39, 0.7); }
        .codelab-topic-tags { font-size: 0.85rem; color: var(--secondary-text-color); }
        .codelab-problem-description h3 { margin-top: 20px; margin-bottom: 10px; font-size: 1.1rem; color: var(--link-color); border-bottom: 1px solid var(--stellar-msg-border); padding-bottom: 5px; }
        .codelab-test-case { background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 3px solid var(--model-color-border); }
        .codelab-test-case pre { white-space: pre-wrap; word-wrap: break-word; background-color: rgba(0,0,0,0.3) !important; padding: 10px !important; }
        .workspace-header { display: flex; justify-content: space-between; align-items: center; padding-bottom: 15px; flex-shrink: 0; gap: 10px; }
        .workspace-header-left { display: flex; gap: 10px; }
        #codelabLanguageSelector { background: var(--input-bg); border: 1px solid var(--input-border); color: var(--primary-text-color); border-radius: 6px; padding: 5px 10px; font-size: 0.9rem; }
        .CodeMirror { height: 100%; font-size: 1rem; }
        .CodeMirror-lines {
    padding-left: 4px !important;
}
        .workspace-footer { display: flex; justify-content: flex-end; padding-top: 15px; gap: 10px; flex-shrink: 0; }
        .codelab-action-btn { padding: 10px 20px; font-size: 0.95rem; font-weight: 500; border: none; border-radius: 6px; cursor: pointer; transition: all 0.2s ease; }
        .codelab-ai-btn { background-color: rgba(123, 97, 255, 0.15); color: var(--secondary-text-color); border: 1px solid var(--user-msg-border); }
        .codelab-ai-btn:hover { background-color: var(--user-msg-hover-bg); color: var(--primary-text-color); }
        .codelab-ai-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        #codelabRunBtn { background-color: rgba(255, 255, 255, 0.1); color: var(--secondary-text-color); }
        #codelabRunBtn:hover { background-color: rgba(255, 255, 255, 0.2); color: var(--primary-text-color); }
        #codelabSubmitBtn { background-color: var(--nebula-confirm-start); color: #fff; }
        #codelabSubmitBtn:hover { background-color: var(--nebula-confirm-end); filter: brightness(1.1); }
        #codelab-output-panel { margin-top: 15px; height: 200px; background: var(--code-bg); border-radius: 8px; border: 1px solid var(--input-border); padding: 15px; font-family: 'Fira Code', monospace; font-size: 0.9rem; overflow-y: auto; resize: vertical; min-height: 100px; flex-shrink: 0; }
        .ai-mentor-response { margin-top: 20px; padding-top: 15px; border-top: 1px dashed var(--input-border); }
        #live-html-preview { width: 100%; height: 100%; border: none; background-color: #ffffff; }
        .workspace-main-content { flex-grow: 1; display: flex; gap: 15px; margin-top: 15px; min-height: 0; }
        #code-editor-container { border: 1px solid var(--input-border); border-radius: 8px; overflow: hidden; width: 100%; transition: width 0.3s ease-in-out; }
        #html-preview-container { display: none; width: 0%; border: 1px solid var(--input-border); border-radius: 8px; overflow: hidden; transition: width 0.3s ease-in-out; }
        #workspace-panel.html-mode-active #code-editor-container { width: 50%; }
        #workspace-panel.html-mode-active #html-preview-container { display: block; width: 50%; }
        #workspace-panel.html-mode-active #codelab-output-panel,
        #workspace-panel.html-mode-active .workspace-footer { display: none; }
        
        /* --- Stellar Forge CSS --- */
        #codelab-mode-switcher button {
            flex-grow: 1;
            background: rgba(0,0,0,0.2);
            border: 1px solid var(--input-border);
            color: var(--secondary-text-color);
        }
        #codelab-mode-switcher button.active {
            background: var(--model-color-start);
            border-color: var(--model-color-border);
            color: #fff;
            box-shadow: 0 4px 10px var(--model-color-shadow);
        }
        #forge-status-log .log-line {
            display: block;
            margin-bottom: 5px;
            white-space: pre-wrap;
            word-break: break-all;
        }
        #forge-status-log .log-line.error {
            color: var(--nebula-regenerate-start);
        }
        #forge-status-log .log-line.success {
            color: var(--nebula-confirm-start);
            font-weight: bold;
        }
         #forge-left-panel {
            /* This is the most critical fix. It allows this flex column to be constrained and not grow infinitely. */
            min-height: 0;
        }
        #forge-status-log {
            /* This ensures the log itself doesn't force its parent to grow. It will now respect the available space and scroll. */
            min-height: 0;
        }
                /* --- START: Definitive Stellar Forge Layout Fix --- */
        /* --- START: Definitive Stellar Forge Layout Fix v2 --- */
        #codelab-content-area {
            height: 100%;
            overflow: hidden; /* Prevent the container itself from growing */
        }
        #forge-left-panel {
            height: 100%;
            display: flex;
            flex-direction: column;
            max-height: 100%; /* Ensure panel doesn't overflow its container */
        }
        #forge-status-log {
            flex-grow: 1; /* Allow it to take up the available space */
            min-height: 0; /* CRUCIAL: Allows the element to shrink and enables scrolling */
            overflow-y: auto; /* Adds scrollbar when content overflows */
            
            /* --- THIS IS THE KEY CHANGE --- */
            /* It gives the log a default size before it starts growing,
               ensuring the controls below are always visible. */
            flex-basis: 150px; 
        }
        #forge-controls {
            flex-shrink: 0; /* Prevents the controls area from being shrunk */
            padding-top: 15px;
        }
        #forgePromptInput {
            overflow-y: auto; /* Ensures the textarea itself scrolls */
            max-height: 25vh; /* Limits height to 25% of the viewport height */
        }
        /* --- END: Definitive Stellar Forge Layout Fix v2 --- */
        /* --- ADD THESE TWO NEW RULES --- */
        #problem-solving-content {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        #mentor-content-scroller {
            flex-grow: 1; /* Make this the element that expands */
            min-height: 0; /* CRUCIAL: Allow this to shrink and enable scrolling */
            overflow-y: auto; /* Add scrollbar when content is too long */
        }
        /* --- END NEW RULES --- */

    </style>
</head>

<body>
       <svg width="0" height="0" style="position:absolute">
        <symbol id="icon-mic" viewBox="0 0 24 24" fill="currentColor">
    <path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.49 6-3.31 6-6.72h-1.7z"></path>
</symbol>
<symbol id="icon-stop" viewBox="0 0 24 24" fill="currentColor">
    <path d="M6 6h12v12H6z"></path>
</symbol>
        
<symbol id="icon-play" viewBox="0 0 24 24" fill="currentColor">
    <path d="M8 5v14l11-7z"></path>
</symbol>
        <symbol id="icon-download" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
    <polyline points="7 10 12 15 17 10"></polyline>
    <line x1="12" y1="15" x2="12" y2="3"></line>
</symbol>
      <symbol id="icon-copy" viewBox="0 0 16 16">
        <path fill-rule="evenodd" d="M10 1.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v8a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5V2h7.5a.5.5 0 0 0 .5-.5zM5.5 4A1.5 1.5 0 0 0 4 5.5v8A1.5 1.5 0 0 0 5.5 15h8A1.5 1.5 0 0 0 15 13.5v-8A1.5 1.5 0 0 0 13.5 4h-8zm0 1h8a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5h-8a.5.5 0 0 1-.5-.5v-8a.5.5 0 0 1 .5-.5z"/>
      </symbol>
       <symbol id="icon-check" viewBox="0 0 16 16">
        <path fill-rule="evenodd" d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"/>
      </symbol>
      <symbol id="icon-attach" viewBox="0 0 24 24">
        <path d="M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5c0-1.38 1.12-2.5 2.5-2.5s2.5 1.12 2.5 2.5v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5V6c0-2.21-1.79-4-4-4S7 3.79 7 6v11.5c0 3.04 2.46 5.5 5.5 5.5s5.5-2.46 5.5-5.5V6h-1.5z"/>
      </symbol>
      <symbol id="icon-chevron-right" viewBox="0 0 24 24">
        <path fill="currentColor" d="M8.59 16.59L13.17 12L8.59 7.41L10 6L16 12L10 18L8.59 16.59Z"/>
      </symbol>
      <symbol id="icon-close" viewBox="0 0 24 24">
        <path fill="currentColor" d="M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12L19 6.41Z"/>
      </symbol>
      <symbol id="icon-arrow-down" viewBox="0 0 24 24">
        <path fill="currentColor" d="M11 4h2v12l5.5-5.5l1.42 1.42L12 19.84l-7.92-7.92L5.5 10.5L11 16V4Z"/>
      </symbol>
     
<symbol id="icon-play" viewBox="0 0 24 24" fill="currentColor">
    <path d="M8 5v14l11-7z"></path>
</symbol>

    </svg>
 

        <canvas id="metaball-canvas" style="display: none;"></canvas>
       
<canvas id="voiceWaveCanvas"></canvas>


<div id="voiceOverlay" class="voice-overlay">
    <h2 class="voice-prompt">Listening...</h2>
    <div class="visualizer-container">
       
        <div class="voice-controls">
            <button id="cancelVoiceBtn" title="Cancel">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12L19 6.41z"></path></svg>
            </button>
            <button id="confirmVoiceBtn" title="Confirm & Send">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19L21 7l-1.41-1.41L9 16.17z"></path></svg>
            </button>
        </div>
    </div>
</div>

<div id="authContainer" style="display: none;">
    <div class="auth-card">
           <div class="auth-card-header">
    <h2 id="authTitle" class="animated-title">Stellar</h2>
    <p id="authSubtitle" class="auth-subtitle">Sign in to your account</p>
    <div class="auth-message-container"></div>
</div>
<div class="auth-card-body">
<form id="loginForm">
    <div class="form-group">
        <label for="loginUsername">Username</label>
        <input type="text" id="loginUsername" required autocomplete="username">
    </div>
    <div class="form-group">
        <label for="loginPassword">Password</label>
        <input type="password" id="loginPassword" required autocomplete="current-password">
    </div>
    <button type="submit" class="auth-button">Sign in</button>
</form>

<form id="registerForm" style="display: none;">
    <div class="form-group">
        <label for="registerUsername">Choose Username</label>
        <input type="text" id="registerUsername" required autocomplete="username">
    </div>
    <div class="form-group">
        <label for="registerPassword">Password</label>
        <input type="password" id="registerPassword" required autocomplete="new-password">
    </div>
    <div class="form-group">
        <label for="registerConfirmPassword">Confirm Password</label>
        <input type="password" id="registerConfirmPassword" required autocomplete="new-password">
    </div>
    <button type="submit" class="auth-button">Create Account</button>
</form>
</div>
<div class="auth-card-footer">
    <p id="authFooterText">
        <!-- The id="authLink" has been removed to disable the JavaScript trigger -->
        Don't have an account? <del>Sign up</del><br>
        <span style="color: red; font-size: 0.85em; display: block; margin-top: 8px;">
            Currently in closed testing. Please contact <a href="mailto:nikhil080905@gmail.com" style="color: #ff8e8e;">Admin</a> for special access.
        </span>
    </p>
</div>
    </div>
</div>

    <header style="display:none;">
        <div class="header-left">
            <button id="sidebarToggleBtn" title="Toggle Sidebar">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M4 18H20C20.55 18 21 17.55 21 17C21 16.45 20.55 16 20 16H4C3.45 16 3 16.45 3 17C3 17.55 3.45 18 4 18ZM4 11H20C20.55 11 21 10.55 21 10C21 9.45 20.55 9 20 9H4C3.45 9 3 9.45 3 10C3 10.55 3.45 11 4 11ZM3 4C3 4.55 3.45 5 4 5H20C20.55 5 21 4.55 21 4C21 3.45 20.55 3 20 3H4C3.45 3 3 3.45 3 4Z" fill="currentColor"/>
                </svg>
            </button>
            
            <span id="chatTitle" class="title-gradient">Stellar</span>
        </div>
        <div class="header-right">
            <div id="modeSelectorHeaderContainer" style="margin-right: 10px;"></div>
           
            <button class="clear-icon" id="clearHistoryBtn" title="Clear current chat history">🗑️</button>
            <div id="profileIcon" title="View Profile"></div>
        </div>
    </header>

    <div id="sidebar" style="display:none;">
        <div class="sidebar-header">
            <h3>Chats</h3>
            <button class="sidebar-close-btn" id="sidebarCloseBtn">
                <svg width="20" height="20"><use xlink:href="#icon-close"></use></svg>
            </button>
        </div>
        <div class="user-info">Welcome, <strong id="sidebarUsername"></strong>!</div>
        <button id="newChatBtn">New Chat</button>
        
<div class="chat-search-container">
    <svg class="search-icon" viewBox="0 0 24 24"><path d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path></svg>
    <input type="text" id="chatSearchInput" placeholder="Search chats...">
</div>
        <ul id="chatList"></ul>
        <button id="logoutButton" class="logout-btn" style="margin-top: auto;">Logout</button>
    </div>

    <div id="profileModal" style="display:none;">
        <div class="profile-modal-content">
            <h2>Your Profile</h2>
            <button class="profile-close-btn" id="profileCloseBtn">
                <svg width="20" height="20"><use xlink:href="#icon-close"></use></svg>
            </button>
            <div class="profile-info">
                Logged in as: <strong id="profileUsernameDisplay"></strong>
            </div>

            <div class="password-change-section">
                <h3>Change Password</h3>
                <form id="changePasswordForm" class="password-change-form">
                    <input type="password" id="currentPassword" placeholder="Current Password" required>
                    <input type="password" id="newPassword" placeholder="New Password" required>
                    <input type="password" id="confirmNewPassword" placeholder="Confirm New Password" required>
                    <button type="submit" id="changePasswordBtn">Change Password</button>
                    <div id="passwordChangeMessage" class="auth-message"></div>
                </form>
            </div>
            <button id="logoutButtonProfile">Logout</button>
        </div>
    </div>

    <div id="tokenCountBar"></div>

    <div id="chatContainer" style="display:none;">
        <div id="messages"></div>
        <div id="analysis-progress-area"></div>

    </div>

<!-- REPLACE the entire codeLabContainer div with this new structure -->
<div id="codeLabContainer" style="display: none; flex-direction: column;">
    <!-- New CodeLab Mode Switcher -->
    <div id="codelab-mode-switcher" style="display: flex; gap: 10px; border-bottom: 1px solid var(--input-border); padding: 15px 20px; flex-shrink: 0; background: var(--stellar-msg-bg);">
        <button id="switchToProblemModeBtn" class="codelab-action-btn active">Problem Solving</button>
        <button id="switchToForgeModeBtn" class="codelab-action-btn">Stellar Forge</button>
    </div>
    <div id="codelab-content-area" style="display: flex; flex-grow: 1; gap: 1px; background-color: var(--input-border);">
        <!-- Left Panel (AI Mentor) -->
         <div id="ai-mentor-panel">
            <!-- New CodeLab Mode Switcher -->
            <div id="codelab-mode-switcher" style="display: flex; gap: 10px; border-bottom: 1px solid var(--input-border); padding-bottom: 15px; margin-bottom: 15px; flex-shrink: 0;">
                <button id="switchToProblemModeBtn" class="codelab-action-btn active">Problem Solving</button>
               
            </div>

            <!-- Container for Problem Solving UI -->
            <div id="problem-solving-content">
                <button type="button" id="newProblemBtn" class="codelab-action-btn">+ New Problem</button>
                <div id="mentor-content-scroller">
                    <div id="problem-display-container">
                        <!-- Problem will be loaded here -->
                    </div>
                    <div id="ai-assist-responses-container">
                        <!-- AI assistance responses will appear here -->
                    </div>
                </div>
                <div id="problem-generation-container">
                    <h3>Generate a New Problem</h3>
                    <form id="generateProblemForm">
                        <textarea id="problemRequestInput" placeholder="e.g., 'a medium difficulty problem about sorting arrays'"></textarea>
                        <div class="problem-gen-buttons">
                            <button type="submit" id="generateProblemBtn" class="codelab-action-btn codelab-ai-btn">Generate Problem</button>
                            <button type="button" id="loadRandomProblemBtn" class="codelab-action-btn">Load Random</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>

        <!-- Right Panel (Workspace) -->
        <div id="workspace-panel" style="display: flex;">
            <div class="workspace-header">
                <div class="workspace-header-left">
                    <button id="codelabExplainBtn" class="codelab-action-btn codelab-ai-btn" title="Explain the current code in the editor">Explain</button>
                    <button id="codelabDebugBtn" class="codelab-action-btn codelab-ai-btn" title="Get help debugging the code based on the output">Debug with AI</button>
                    <button id="codelabOptimizeBtn" class="codelab-action-btn codelab-ai-btn" title="Get suggestions to improve the current code">Optimize</button>
                </div>
                <div class="workspace-header-right">
                    <select id="codelabLanguageSelector">
                        <option value="python" selected>Python</option>
                        <option value="javascript">JavaScript</option>
                        <option value="html">HTML</option>
                        <option value="java" disabled>Java (soon)</option>
                    </select>
                </div>
            </div>
            <div class="workspace-main-content">
                <div id="code-editor-container"></div>
                <div id="html-preview-container">
                    <iframe id="live-html-preview" sandbox="allow-scripts allow-same-origin allow-forms"></iframe>
                </div>
            </div>
            <div id="codelab-output-panel"></div>
            <div class="workspace-footer">
                <button id="codelabRunBtn" class="codelab-action-btn">Run</button>
                <button id="codelabSubmitBtn" class="codelab-action-btn">Submit</button>
            </div>
        </div>

                <!-- Stellar Forge UI -->
        <div id="forge-container" style="display: none; width: 100%; height: 100%; flex-direction: row; gap: 1px;">
          <div id="forge-left-panel" style="width: 40%; background: var(--stellar-msg-bg); padding: 20px;">
                <h3 style="flex-shrink: 0;">Stellar Forge</h3>
                <p style="font-size: 0.9em; color: var(--secondary-text-color); margin-bottom: 20px; flex-shrink: 0;">Describe the app you want to build or modify.</p>
                <div id="forge-status-log" style="background: rgba(0,0,0,0.2); border-radius: 8px; padding: 15px; font-family: 'Fira Code', monospace; font-size: 0.9em; display: none;"></div>
               <div id="forge-controls" style="display: flex; flex-direction: column; gap: 10px;">
                 <textarea id="forgePromptInput" placeholder="e.g., build a to-do list app" style="width: 100%; height: 100px; background: var(--input-bg); border: 1px solid var(--input-border); color: var(--primary-text-color); border-radius: 6px; padding: 10px; font-family: 'Poppins', sans-serif; resize: vertical;"></textarea>
                    <div style="display: flex; justify-content: space-between; gap: 10px;">
                        <button id="forgeEndSessionBtn" class="codelab-action-btn" style="background-color: var(--nebula-regenerate-end); display: none;">End Session</button>
                        <button id="forgeViewCodeBtn" class="codelab-action-btn codelab-ai-btn" style="display: none;">View Code</button>
                        <button id="forgeStartBtn" class="codelab-action-btn" style="background-color: var(--nebula-confirm-start); flex-grow: 1;">Start Building</button>
                    </div>
                </div>
            </div>
            <div id="forge-right-panel" style="width: 60%; background: #fff; position: relative;">
                <div id="forge-loading-overlay" style="position: absolute; inset: 0; background: #fff; display: grid; place-items: center; color: #333; font-size: 1.2rem; z-index: 2;">
                    Your live application will appear here...
                </div>
                <iframe id="forgePreviewFrame" style="width: 100%; height: 100%; border: none; position: relative; z-index: 1;"></iframe>
            </div>
        </div>
    </div>
</div>
       <button id="chatScrollToBottomBtn" title="Scroll to bottom">
        <svg width="24" height="24"><use xlink:href="#icon-arrow-down"></use></svg>
    </button>
   <div id="inputContainer" style="display:none;">
     <div class="drop-overlay">Drop files to upload</div> 
     <div id="stagedFilesContainer" style="font-size: 0.85em; color: var(--secondary-text-color); margin-bottom: 5px; max-height: 80px; overflow-y: auto; display: none; padding: 5px; border: 1px dashed rgba(255, 255, 255, 0.1); border-radius: 4px;">
     </div>
    <textarea id="chatInput" placeholder="Send a message or drop/paste files..." rows="1"></textarea> 
    <div class="input-buttons">
            <div class="left-buttons">
    <button id="voiceInputBtn" class="file-upload-label-button" title="Use voice input">
        <svg width="18" height="18"><use xlink:href="#icon-mic"></use></svg>
    </button>
    <label for="fileUpload" class="file-upload-label-button" title="Attach files">
        <svg><use xlink:href="#icon-attach"></use></svg>
    </label>
    <input type="file" id="fileUpload" multiple style="display: none;">
             <div id="modeSelectorInputContainer">
            <select id="modeSelector">
                <option value="stellar" selected>Stellar</option>
                <option value="spectrum">Spectrum</option>
                <option value="nebula">Nebula</option>
                <option value="cosmos">Cosmos</option>
                <option value="codelab">CodeLab</option>
            </select>
        </div>
     <button id="spectrumSearchBtn" title="Toggle Spectral Search (uses Tavily API)">Spectral Search</button>
</div>
            <div class="right-buttons">
    <select id="modelSelect">
        <option value="emerald" title="Fastest model, good for quick answers.">Emerald</option>
        <option value="lunarity" selected title="Balanced speed and capability. Default.">Lunarity</option>
        <option value="crimson" title="Smarter, better for complex tasks. Nebula/Cosmos compatible.">Crimson</option>
        <option value="obsidian" title="Most powerful model for in-depth analysis. Nebula/Cosmos compatible.">Obsidian</option>
    </select>
    <button id="sendBtn" title="Send message (Enter)">➤</button>
   
    <button id="stopBtn" title="Stop generation" style="display: none;">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><use xlink:href="#icon-stop"></use></svg>
    </button>
</div>
        </div>
    </div>

    <div id="editModalBackdrop" style="display:none;">
        <div class="modal-content">
            <h2>Edit Research Paper</h2>
            <textarea id="editMarkdownInput" rows="10"></textarea>
            <div class="modal-buttons">
                <button id="cancelEditBtn">Cancel</button>
                <button id="saveEditBtn">Save Changes</button>
            </div>
        </div>
    </div>

    <div id="regenerateModalBackdrop" style="display:none;">
        <div class="modal-content">
            <h2 id="regenerateModalTitle">Regenerate Step Feedback</h2>
            <p style="margin-bottom: 15px; color: var(--secondary-text-color);">Optionally, provide specific instructions for regenerating this step:</p>
            <textarea id="regenerateFeedbackInput" rows="6" placeholder="e.g., Make the explanation simpler, use Python instead of Javascript, add more error handling..."></textarea>
            <div class="modal-buttons">
                <button id="cancelRegenerateBtn">Cancel</button>
                <button id="saveRegenerateBtn">Regenerate with Feedback</button>
                <button id="regenerateWithoutFeedbackBtn">Regenerate Without Feedback</button>
            </div>
        </div>
    </div>

    <span id="modelSelectWidthHelper"></span>
   
<div id="live-preview-container" style="display: none;">
    <div id="live-preview-header">
        <span id="live-preview-title"></span>
        <button id="live-preview-close-btn" title="Close Preview">×</button>
    </div>
    <div id="live-preview-content">
        <iframe id="live-preview-iframe" sandbox="allow-scripts allow-same-origin allow-forms"></iframe>
        <div id="live-preview-fallback" style="display: none;">
            <p>This site does not allow being displayed here due to its security policy.</p>
            <a href="#" target="_blank" rel="noopener noreferrer">Open in New Tab</a>
        </div>
    </div>
</div>


    <script>
        const stopBtn = document.getElementById("stopBtn");
        const chatSearchInput = document.getElementById("chatSearchInput");
        const messagesDiv = document.getElementById("messages");
        const chatInput = document.getElementById("chatInput");
        const sendBtn = document.getElementById("sendBtn");
        const modeSelector = document.getElementById("modeSelector");
        const spectrumSearchBtn = document.getElementById("spectrumSearchBtn");
        const clearHistoryBtn = document.getElementById("clearHistoryBtn");
        const modelSelect = document.getElementById("modelSelect");
        const statusBar = document.getElementById("statusBar");
        const inputContainer = document.getElementById("inputContainer");
        const chatContainer = document.getElementById("chatContainer");
        const editModalBackdrop = document.getElementById("editModalBackdrop");
        const editMarkdownInput = document.getElementById("editMarkdownInput");
        const cancelEditBtn = document.getElementById("cancelEditBtn");
        const saveEditBtn = document.getElementById("saveEditBtn");
        const modelSelectWidthHelper = document.getElementById("modelSelectWidthHelper");
        const bodyElement = document.body;
        const regenerateModalBackdrop = document.getElementById("regenerateModalBackdrop");
        const regenerateModalTitle = document.getElementById("regenerateModalTitle");
        const regenerateFeedbackInput = document.getElementById("regenerateFeedbackInput");
        const cancelRegenerateBtn = document.getElementById("cancelRegenerateBtn");
        const saveRegenerateBtn = document.getElementById("saveRegenerateBtn");
        const regenerateWithoutFeedbackBtn = document.getElementById("regenerateWithoutFeedbackBtn");
        const fileUploadInput = document.getElementById("fileUpload");
        const analysisProgressArea = document.getElementById("analysis-progress-area");

        const authContainer = document.getElementById("authContainer");
        const sidebarToggleBtn = document.getElementById("sidebarToggleBtn");
        const sidebar = document.getElementById("sidebar");
        const sidebarCloseBtn = document.getElementById("sidebarCloseBtn");
        const newChatBtn = document.getElementById("newChatBtn");
        const chatList = document.getElementById("chatList");
        const chatTitle = document.getElementById("chatTitle");
        const profileIcon = document.getElementById("profileIcon");
        const profileModal = document.getElementById("profileModal");
        const profileCloseBtn = document.getElementById("profileCloseBtn");
        const profileUsernameDisplay = document.getElementById("profileUsernameDisplay");
        const changePasswordForm = document.getElementById("changePasswordForm");
        const currentPasswordInput = document.getElementById("currentPassword");
        const newPasswordInput = document.getElementById("newPassword");
        const confirmNewPasswordInput = document.getElementById("confirmNewPassword");
        const passwordChangeMessage = document.getElementById("passwordChangeMessage");
        const logoutButtonProfile = document.getElementById("logoutButtonProfile");
        const sidebarUsername = document.getElementById("sidebarUsername");
        const tokenCountBar = document.getElementById("tokenCountBar");
        const stagedFilesContainer = document.getElementById("stagedFilesContainer");
        const chatScrollToBottomBtn = document.getElementById("chatScrollToBottomBtn");
function copyCode(buttonElement, codeEl) {
    const codeToCopy = codeEl.textContent;
    navigator.clipboard.writeText(codeToCopy).then(() => {
        buttonElement.innerHTML = '<svg><use xlink:href="#icon-check"></use></svg> Copied!';
        buttonElement.classList.add('copied');
        buttonElement.disabled = true;

        setTimeout(() => {
            buttonElement.innerHTML = '<svg><use xlink:href="#icon-copy"></use></svg> Copy';
            buttonElement.classList.remove('copied');
            buttonElement.disabled = false;
        }, 1500);
    }).catch(err => {
        console.error('Failed to copy code: ', err);
        buttonElement.textContent = 'Error';
        setTimeout(() => {
            buttonElement.innerHTML = '<svg><use xlink:href="#icon-copy"></use></svg> Copy';
            buttonElement.disabled = false;
        }, 2000);
    });
}
        let renderHtmlDebounceTimer = null;
         let livePreviewTimer = null;
        let scrapingQueue = [];
        let scrapingTimerId = null;
        const SCRAPING_DISPLAY_DELAY = 15000; 
        let currentMode = 'stellar';
        let useSpectrumSearch = true;
        let currentStreamQueryId = null;
        let currentEditingMsg = null, currentEditingMsgId = null;
        let lastRefinedQuery = "";
        let isProcessing = false;
        let currentStatusText = "Idle";
        let historyLoaded = false;
        let currentRegeneratingStep = null;
        let sseEventSource = null;
        let stagedFiles = [];
        let authImageUrls = [];
        let currentAuthImageIndex = 0;
        let currentChatId = null;
        let currentUsername = null;
        let tokenCounterInterval = null;
        let currentSearchTerm = ''; 

        let forgeHtmlEditor = null;
        let forgePyEditor = null;
        const NEBULA_AUTO_CONTINUE_TIMEOUT = 20000;
        let nebulaAutoContinueTimerId = null;

        let nebulaProcess = {
            isActive: false,
            processId: null,
            currentStep: 0,
            userQuery: null,
            planOutput: null,
            frontendOutput: null,
            backendOutput: null,
            verificationOutput: null,
            reportUrl: null,
            messageElement: null
        };
        let nebulaProcessState = {
    plan: null,
    frontendCode: null,
    backendCode: null,
    verificationResult: null,
    requiredKeys: [],
    apiKeys: {}
};

        // --- START: New Stellar Forge Globals and Functions ---
        let forgeSseSource = null;
        let isForgeSessionActive = false;

        function setupForgeUI() {
    const switchToProblemModeBtn = document.getElementById('switchToProblemModeBtn');
    const switchToForgeModeBtn = document.getElementById('switchToForgeModeBtn');
    const problemSolvingUI = [document.getElementById('ai-mentor-panel'), document.getElementById('workspace-panel')];
    const forgeUI = document.getElementById('forge-container');
    
    const forgeStartBtn = document.getElementById('forgeStartBtn');
    const forgeEndSessionBtn = document.getElementById('forgeEndSessionBtn');
    const forgePromptInput = document.getElementById('forgePromptInput');
    const forgeViewCodeBtn = document.getElementById('forgeViewCodeBtn');

    switchToProblemModeBtn.addEventListener('click', () => {
        if (isForgeSessionActive) {
            if (!confirm("This will end your current Forge session. Are you sure?")) return;
            handleForgeStop();
        }
        switchToProblemModeBtn.classList.add('active');
        switchToForgeModeBtn.classList.remove('active');
        forgeUI.style.display = 'none';
        problemSolvingUI.forEach(el => { if(el) el.style.display = 'flex'; });
        if(codeLabEditor) setTimeout(() => codeLabEditor.refresh(), 1);
    });

    switchToForgeModeBtn.addEventListener('click', () => {
        switchToForgeModeBtn.classList.add('active');
        switchToProblemModeBtn.classList.remove('active');
        forgeUI.style.display = 'flex';
        problemSolvingUI.forEach(el => { if(el) el.style.display = 'none'; });
    });
    
    forgeStartBtn.addEventListener('click', () => {
        if (isForgeSessionActive) {
            handleForgeIterate();
        } else {
            handleForgeStart();
        }
    });

    forgePromptInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            forgeStartBtn.click();
        }
    });

    forgeEndSessionBtn.addEventListener('click', handleForgeStop);
    forgeViewCodeBtn.addEventListener('click', handleForgeViewCode);
}

async function handleForgeViewCode() {
    const forgeRightPanel = document.getElementById('forge-right-panel');
    const forgePreviewFrame = document.getElementById('forgePreviewFrame');
    const forgeLoadingOverlay = document.getElementById('forge-loading-overlay');

    if (document.getElementById('forge-editor-wrapper')) {
        return; 
    }

    try {
        addLogToForge("Fetching project files for editing...");
        const response = await fetch('/codelab/forge/files');
        if (!response.ok) {
            const errData = await response.json();
            throw new Error(errData.error || 'Could not fetch project files.');
        }
        const files = await response.json();

        forgePreviewFrame.style.display = 'none';
        forgeLoadingOverlay.style.display = 'none';

        const editorWrapper = document.createElement('div');
        editorWrapper.id = 'forge-editor-wrapper';
        editorWrapper.style.cssText = `
            width: 100%; height: 100%; display: flex; flex-direction: column;
            background: var(--stellar-msg-bg);
        `;

        // The inline style for the header is now themed with var(--header-bg)
        editorWrapper.innerHTML = `
            <div id="forge-editor-header" style="display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; background: var(--header-bg); border-bottom: 1px solid var(--input-border); flex-shrink: 0;">
                <div id="forge-editor-tabs" style="display: flex; gap: 5px;">
                    <button class="forge-tab-btn active" data-editor="html">index.html</button>
                    <button class="forge-tab-btn" data-editor="py">app.py</button>
                </div>
                <div id="forge-editor-controls" style="display: flex; gap: 10px;">
                    <button id="forge-editor-close-btn" class="codelab-action-btn codelab-ai-btn">Close Editor</button>
                    <button id="forge-editor-redeploy-btn" class="codelab-action-btn" style="background-color: var(--nebula-confirm-start);">Save & Redeploy</button>
                </div>
            </div>
            <div id="forge-editor-body" style="flex-grow: 1; position: relative; overflow: hidden;">
                <div id="forge-html-editor-container" style="position: absolute; width: 100%; height: 100%;"></div>
                <div id="forge-py-editor-container" style="position: absolute; width: 100%; height: 100%; display: none;"></div>
            </div>
        `;

        forgeRightPanel.appendChild(editorWrapper);

        const htmlContainer = editorWrapper.querySelector('#forge-html-editor-container');
        const pyContainer = editorWrapper.querySelector('#forge-py-editor-container');
        
        forgeHtmlEditor = CodeMirror(htmlContainer, { value: files['index.html'] || '', mode: 'htmlmixed', theme: 'dracula', lineNumbers: true });
        forgePyEditor = CodeMirror(pyContainer, { value: files['app.py'] || '', mode: 'python', theme: 'dracula', lineNumbers: true });
        
        // This timeout ensures the editors render correctly after being added to the DOM
        setTimeout(() => { 
            forgeHtmlEditor.refresh(); 
            forgePyEditor.refresh(); 
        }, 1);

        const tabs = editorWrapper.querySelectorAll('.forge-tab-btn');
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                if (tab.dataset.editor === 'html') {
                    htmlContainer.style.display = 'block';
                    pyContainer.style.display = 'none';
                    forgeHtmlEditor.refresh();
                } else {
                    htmlContainer.style.display = 'none';
                    pyContainer.style.display = 'block';
                    forgePyEditor.refresh();
                }
            });
        });

        editorWrapper.querySelector('#forge-editor-close-btn').addEventListener('click', () => {
            editorWrapper.remove();
            forgePreviewFrame.style.display = 'block';
            if (!forgePreviewFrame.src || forgePreviewFrame.src === 'about:blank') {
                forgeLoadingOverlay.style.display = 'grid';
            }
        });

        editorWrapper.querySelector('#forge-editor-redeploy-btn').addEventListener('click', () => {
            handleForgeRedeploy({
                'index.html': forgeHtmlEditor.getValue(),
                'app.py': forgePyEditor.getValue()
            });
            editorWrapper.remove();
            forgePreviewFrame.style.display = 'block';
            forgeLoadingOverlay.style.display = 'grid';
            forgeLoadingOverlay.textContent = 'Redeploying with your changes...';
        });

    } catch (error) {
        addLogToForge(`Error opening editor: ${error.message}`, 'error');
        forgePreviewFrame.style.display = 'block';
        if (!forgePreviewFrame.src || forgePreviewFrame.src === 'about:blank') {
            forgeLoadingOverlay.style.display = 'grid';
        }
    }
}

async function handleForgeRedeploy(files) {
    if (forgeSseSource) forgeSseSource.close();
    addLogToForge("Redeploying application with new code...");
    document.getElementById('forgeStartBtn').disabled = true;

    try {
        const response = await fetch('/codelab/forge/redeploy', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ files: files })
        });
        const data = await response.json();
        if (!response.ok || !data.success) {
            throw new Error(data.error || 'Failed to start redeployment.');
        }

        const processId = data.process_id;
        forgeSseSource = new EventSource(`/codelab/forge/stream?process_id=${processId}`);
        handleForgeStream(forgeSseSource, document.getElementById('forgePromptInput'));

    } catch (error) {
        addLogToForge(`Error: ${error.message}`, 'error');
        document.getElementById('forgeStartBtn').disabled = false;
    }
}
        function updateForgeUIForSessionState(isActive) {
            const forgeStatusLog = document.getElementById('forge-status-log');
            const forgeControls = document.getElementById('forge-controls');
            const forgeStartBtn = document.getElementById('forgeStartBtn');
            const forgeEndSessionBtn = document.getElementById('forgeEndSessionBtn');
            const forgeViewCodeBtn = document.getElementById('forgeViewCodeBtn');

            isForgeSessionActive = isActive;
            forgeStatusLog.style.display = isActive ? 'block' : 'none';
            forgeStartBtn.textContent = isActive ? 'Submit Change' : 'Start Building';
            forgeEndSessionBtn.style.display = isActive ? 'block' : 'none';
            forgeViewCodeBtn.style.display = isActive ? 'block' : 'none';

            if (isActive) {
                forgeControls.style.marginTop = '10px';
            } else {
                forgeStatusLog.innerHTML = '';
                document.getElementById('forge-loading-overlay').style.display = 'grid';
                document.getElementById('forgePreviewFrame').src = 'about:blank';
                forgeControls.style.marginTop = 'auto';
            }
        }

        function addLogToForge(message, type = 'info') {
            const logContainer = document.getElementById('forge-status-log');
            const line = document.createElement('span');
            line.className = `log-line ${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(line);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

              // REPLACE the existing handleForgeStart function
        async function handleForgeStart() {
            const promptInput = document.getElementById('forgePromptInput');
            const prompt = promptInput.value.trim();
            if (!prompt) {
                alert("Please describe the application you want to build.");
                return;
            }

            updateForgeUIForSessionState(true);
            addLogToForge("Sending request to Stellar...");
            document.getElementById('forgeStartBtn').disabled = true;
            promptInput.disabled = true;
            
            try {
                const response = await fetch('/codelab/forge/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: prompt })
                });

                const data = await response.json();
                if (!response.ok || !data.success) {
                    throw new Error(data.error || 'Failed to start Forge session.');
                }
                
                // Now connect to the streaming endpoint
                const processId = data.process_id;
                forgeSseSource = new EventSource(`/codelab/forge/stream?process_id=${processId}`);
                handleForgeStream(forgeSseSource, promptInput);

            } catch (error) {
                addLogToForge(`Error: ${error.message}`, 'error');
                updateForgeUIForSessionState(false); // Reset UI on failure
                document.getElementById('forgeStartBtn').disabled = false;
                promptInput.disabled = false;
            }
        }
        
        async function handleForgeIterate() {
    if (forgeSseSource) forgeSseSource.close(); // <-- ADD THIS LINE
    const promptInput = document.getElementById('forgePromptInput');
    const prompt = promptInput.value.trim();
    if (!prompt) {
        alert("Please describe the change you want to make.");
        return;
    }

    addLogToForge(`Sending modification request: "${prompt}"`);
    document.getElementById('forgeStartBtn').disabled = true;
    promptInput.disabled = true;

    try {
        const response = await fetch('/codelab/forge/iterate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ prompt: prompt })
        });

        const data = await response.json();
        if (!response.ok || !data.success) {
            throw new Error(data.error || 'Failed to iterate on Forge project.');
        }

        const processId = data.process_id;
        forgeSseSource = new EventSource(`/codelab/forge/stream?process_id=${processId}`);
        handleForgeStream(forgeSseSource, promptInput);

    } catch (error) {
        addLogToForge(`Error: ${error.message}`, 'error');
        document.getElementById('forgeStartBtn').disabled = false;
        promptInput.disabled = false;
    }
}

function handleForgeStream(sse, promptInput) {
    const loadingOverlay = document.getElementById('forge-loading-overlay');
    const previewFrame = document.getElementById('forgePreviewFrame');
    const startBtn = document.getElementById('forgeStartBtn');
    
    loadingOverlay.style.display = 'grid';
    loadingOverlay.textContent = 'Connecting to build stream...';

    sse.onmessage = (event) => {
        try {
            if (event.data.startsWith(':')) {
                return;
            }
            
            const data = JSON.parse(event.data);
            
            if (data.type === 'log') {
                addLogToForge(data.content);
                loadingOverlay.textContent = data.content;
            } else if (data.status) {
                addLogToForge(data.status);
                loadingOverlay.textContent = data.status;
            }
            
            if (data.error || (data.type === 'error' && data.content)) {
                const errorMessage = data.error || data.content;
                addLogToForge(`ERROR: ${errorMessage}`, 'error');
                sse.close();
                alert(`An error occurred: ${errorMessage}`);
                startBtn.disabled = false;
                promptInput.disabled = false;
                promptInput.value = '';
            }

            if (data.type === 'port_info' && data.url) {
                addLogToForge(`Deployment successful! URL: ${data.url}`, 'success');
                
                setTimeout(() => {
                    previewFrame.src = data.url;
                    loadingOverlay.style.display = 'none';
                }, 1500);
                
                sse.close();
                startBtn.disabled = false;
                promptInput.disabled = false;
                promptInput.value = '';
            }
        } catch (e) {
            console.error("Error parsing SSE message data:", event.data, e);
            addLogToForge('Received an invalid message from the build stream.', 'error');
        }
    };
    
    sse.onerror = (err) => {
        addLogToForge('Stream connection error. The build may have failed or the session ended.', 'error');
        sse.close();
        startBtn.disabled = false;
        promptInput.disabled = false;
    };
}

        async function handleForgeStop() {
            addLogToForge("Stopping session...");
            if (forgeSseSource) forgeSseSource.close();

            try {
                await fetch('/codelab/forge/stop', { method: 'POST' });
                addLogToForge("Session ended.", 'success');
            } catch (e) {
                addLogToForge(`Error stopping session: ${e.message}`, 'error');
            } finally {
                updateForgeUIForSessionState(false);
                const promptInput = document.getElementById('forgePromptInput');
                promptInput.value = '';
                promptInput.disabled = false;
                 document.getElementById('forgeStartBtn').disabled = false;
            }
        }
        // --- END: New Stellar Forge Globals and Functions ---




        const MAX_TOKEN_LIMIT = 1048576;
        const TOKEN_COUNT_INTERVAL_MS = 600000;


function toggleSendStopButtons(showStop) {
    if (showStop) {
        sendBtn.style.display = 'none';
        stopBtn.style.display = 'inline-flex';
    } else {
        sendBtn.style.display = 'inline-flex';
        stopBtn.style.display = 'none';
    }
}
        function resetNebulaProcessState() {
            clearTimeout(nebulaAutoContinueTimerId);
            nebulaAutoContinueTimerId = null;
            nebulaProcess = {
                isActive: false, processId: null, currentStep: 0, userQuery: null, planOutput: null,
                frontendOutput: null, backendOutput: null, verificationOutput: null, reportUrl: null, messageElement: null
            };
        }

const NEBULA_COMPATIBLE_MODELS = ["crimson", "obsidian"];
        const COSMOS_COMPATIBLE_MODELS = ["crimson", "obsidian"];
        const DEFAULT_NEBULA_MODEL = "crimson";
        const katexDelimiters = [
            { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false },
            { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true }
        ];

        const modelThemes = {
                sapphire: { start: '#4facfe', end: '#00f2fe', border: 'rgba(79, 172, 254, 0.5)', shadow: 'rgba(79, 172, 254, 0.3)', inset: 'rgba(79, 172, 254, 0.2)', h_start: '#00f2fe', h_end: '#4facfe', h_border: 'rgba(79, 172, 254, 0.7)', h_shadow: 'rgba(79, 172, 254, 0.5)', h_inset: 'rgba(79, 172, 254, 0.3)', h_strong: 'rgba(79, 172, 254, 0.4)', statusBarBg: 'rgba(79, 172, 254, 0.2)', statusBarColor: '#e0f8ff', statusBarShadow: 'rgba(79, 172, 254, 0.4)', titleShadow: 'rgba(0, 100, 150, 0.4)', bodyBg1: '#0a192f', bodyBg2: '#112240', bodyBg3: '#1a3b5f', bodyBg4: '#112240', primaryText: '#e0f8ff', secondaryText: '#b3e5fc', headerBg: 'rgba(10, 25, 47, 0.4)', headerBorder: 'rgba(79, 172, 254, 0.2)', inputBg: 'rgba(10, 25, 47, 0.5)', inputBorder: 'rgba(79, 172, 254, 0.15)', inputFocusBg: 'rgba(17, 34, 64, 0.6)', userMsgBg: 'rgba(79, 172, 254, 0.1)', userMsgBorder: 'rgba(79, 172, 254, 0.3)', userMsgHoverBg: 'rgba(79, 172, 254, 0.15)', stellarMsgBg: 'rgba(5, 20, 35, 0.3)', stellarMsgBorder: 'rgba(79, 172, 254, 0.2)', stellarMsgHoverBg: 'rgba(10, 30, 45, 0.4)', nebulaMsgBg: 'rgba(10, 30, 45, 0.35)', nebulaMsgBorder: 'rgba(79, 172, 254, 0.3)', nebulaMsgHoverBg: 'rgba(15, 40, 55, 0.45)', tableBorder: 'rgba(79, 172, 254, 0.4)', codeBg: 'rgba(5, 20, 35, 0.9)', codeBorder: 'rgba(79, 172, 254, 0.5)', codeText: '#e0f8ff', inlineCodeText: '#80d8ff', copyBtnBg: 'rgba(79, 172, 254, 0.15)', copyBtnHoverBg: 'rgba(79, 172, 254, 0.25)', copyBtnColor: '#b3e5fc', copyBtnHoverColor: '#e0f8ff', copyBtnCopiedBg: '#4facfe', copyBtnCopiedColor: '#ffffff', scrollbarTrack: 'rgba(17, 34, 64, 0.7)', previewBtnBg: 'rgba(79, 172, 254, 0.15)', previewBtnHoverBg: 'rgba(79, 172, 254, 0.25)', previewBtnColor: '#b3e5fc', previewBtnHoverColor: '#e0f8ff', tokenLow: '#4facfe', tokenMedium: '#00f2fe', tokenHigh: '#ff8e8e' },
             emerald: { start: '#00c292', end: '#00a77d', border: 'rgba(0, 194, 146, 0.6)', shadow: 'rgba(0, 194, 146, 0.3)', inset: 'rgba(0, 194, 146, 0.2)', h_start: '#00a77d', h_end: '#00c292', h_border: 'rgba(0, 194, 146, 0.8)', h_shadow: 'rgba(0, 194, 146, 0.5)', h_inset: 'rgba(0, 194, 146, 0.3)', h_strong: 'rgba(0, 194, 146, 0.4)', statusBarBg: 'rgba(0, 194, 146, 0.25)', statusBarColor: '#a7f5e3', statusBarShadow: 'rgba(0, 194, 146, 0.4)', titleShadow: 'rgba(0, 100, 80, 0.4)', bodyBg1: '#0a2e26', bodyBg2: '#0f4d3f', bodyBg3: '#146d59', bodyBg4: '#0f4d3f', primaryText: '#e0fdf6', secondaryText: '#94d9c9', headerBg: 'rgba(10, 46, 38, 0.4)', headerBorder: 'rgba(0, 194, 146, 0.2)', inputBg: 'rgba(10, 46, 38, 0.5)', inputBorder: 'rgba(0, 194, 146, 0.15)', inputFocusBg: 'rgba(15, 77, 63, 0.6)', userMsgBg: 'rgba(0, 194, 146, 0.1)', userMsgBorder: 'rgba(0, 194, 146, 0.3)', userMsgHoverBg: 'rgba(0, 194, 146, 0.15)', stellarMsgBg: 'rgba(0, 50, 40, 0.3)', stellarMsgBorder: 'rgba(0, 194, 146, 0.2)', stellarMsgHoverBg: 'rgba(0, 60, 50, 0.4)', nebulaMsgBg: 'rgba(0, 60, 50, 0.35)', nebulaMsgBorder: 'rgba(0, 194, 146, 0.3)', nebulaMsgHoverBg: 'rgba(0, 70, 60, 0.45)', tableBorder: 'rgba(0, 194, 146, 0.4)', codeBg: 'rgba(5, 30, 25, 0.9)', codeBorder: 'rgba(0, 194, 146, 0.5)', codeText: '#e8fff8', inlineCodeText: '#50e3c2', copyBtnBg: 'rgba(0, 194, 146, 0.15)', copyBtnHoverBg: 'rgba(0, 194, 146, 0.25)', copyBtnColor: '#a7f5e3', copyBtnHoverColor: '#e8fff8', copyBtnCopiedBg: '#00a77d', copyBtnCopiedColor: '#ffffff', scrollbarTrack: 'rgba(15, 77, 63, 0.7)', previewBtnBg: 'rgba(0, 194, 146, 0.15)', previewBtnHoverBg: 'rgba(0, 194, 146, 0.25)', previewBtnColor: '#a7f5e3', previewBtnHoverColor: '#e8fff8', tokenLow: '#00c292', tokenMedium: '#00a77d', tokenHigh: '#d31027' },
             lunarity: { start: '#7b61ff', end: '#b554ff', border: 'rgba(181, 84, 255, 0.5)', shadow: 'rgba(123, 97, 255, 0.3)', inset: 'rgba(123, 97, 255, 0.2)', h_start: '#b554ff', h_end: '#7b61ff', h_border: 'rgba(123, 97, 255, 0.7)', h_shadow: 'rgba(123, 97, 255, 0.5)', h_inset: 'rgba(123, 97, 255, 0.3)', h_strong: 'rgba(123, 97, 255, 0.4)', statusBarBg: 'rgba(123, 97, 255, 0.2)', statusBarColor: '#e0d9ff', statusBarShadow: 'rgba(123, 97, 255, 0.4)', titleShadow: 'rgba(123, 97, 255, 0.3)', bodyBg1: '#0f0c29', bodyBg2: '#302b63', bodyBg3: '#24243e', bodyBg4: '#302b63', primaryText: '#f0f0f0', secondaryText: '#a9a3c7', headerBg: 'rgba(20, 16, 50, 0.3)', headerBorder: 'rgba(181, 84, 255, 0.15)', inputBg: 'rgba(20, 16, 50, 0.4)', inputBorder: 'rgba(181, 84, 255, 0.1)', inputFocusBg: 'rgba(30, 26, 60, 0.5)', userMsgBg: 'rgba(123, 97, 255, 0.15)', userMsgBorder: 'rgba(123, 97, 255, 0.3)', userMsgHoverBg: 'rgba(123, 97, 255, 0.2)', stellarMsgBg: 'rgba(0, 0, 0, 0.25)', stellarMsgBorder: 'rgba(123, 97, 255, 0.2)', stellarMsgHoverBg: 'rgba(0, 0, 0, 0.35)', nebulaMsgBg: 'rgba(10, 10, 25, 0.3)', nebulaMsgBorder: 'rgba(123, 97, 255, 0.3)', nebulaMsgHoverBg: 'rgba(15, 15, 35, 0.4)', tableBorder: 'rgba(123, 97, 255, 0.3)', codeBg: 'rgba(10, 10, 25, 0.85)', codeBorder: 'rgba(123, 97, 255, 0.4)', codeText: '#f5f5f5', inlineCodeText: '#cea9ff', copyBtnBg: 'rgba(255, 255, 255, 0.1)', copyBtnHoverBg: 'rgba(255, 255, 255, 0.2)', copyBtnColor: '#c5bfff', copyBtnHoverColor: '#f5f5f5', copyBtnCopiedBg: '#7b61ff', copyBtnCopiedColor: '#ffffff', scrollbarTrack: 'rgba(36, 36, 62, 0.8)', previewBtnBg: 'rgba(255, 255, 255, 0.1)', previewBtnHoverBg: 'rgba(255, 255, 255, 0.2)', previewBtnColor: '#c5bfff', previewBtnHoverColor: '#f5f5f5', tokenLow: '#7b61ff', tokenMedium: '#b554ff', tokenHigh: '#ff6b6b' },
             crimson: { start: '#D31027', end: '#9A0007', border: 'rgba(211, 16, 39, 0.6)', shadow: 'rgba(211, 16, 39, 0.3)', inset: 'rgba(211, 16, 39, 0.2)', h_start: '#9A0007', h_end: '#D31027', h_border: 'rgba(211, 16, 39, 0.8)', h_shadow: 'rgba(211, 16, 39, 0.5)', h_inset: 'rgba(211, 16, 39, 0.3)', h_strong: 'rgba(211, 16, 39, 0.4)', statusBarBg: 'rgba(211, 16, 39, 0.2)', statusBarColor: '#ffcdd2', statusBarShadow: 'rgba(211, 16, 39, 0.4)', titleShadow: 'rgba(100, 0, 0, 0.4)', bodyBg1: '#2b0404', bodyBg2: '#4d0a0a', bodyBg3: '#6f1010', bodyBg4: '#4d0a0a', primaryText: '#ffebee', secondaryText: '#f7c4c4', headerBg: 'rgba(43, 4, 4, 0.4)', headerBorder: 'rgba(211, 16, 39, 0.2)', inputBg: 'rgba(43, 4, 4, 0.5)', inputBorder: 'rgba(211, 16, 39, 0.15)', inputFocusBg: 'rgba(77, 10, 10, 0.6)', userMsgBg: 'rgba(211, 16, 39, 0.1)', userMsgBorder: 'rgba(211, 16, 39, 0.3)', userMsgHoverBg: 'rgba(211, 16, 39, 0.15)', stellarMsgBg: 'rgba(50, 0, 0, 0.3)', stellarMsgBorder: 'rgba(211, 16, 39, 0.2)', stellarMsgHoverBg: 'rgba(60, 0, 0, 0.4)', nebulaMsgBg: 'rgba(60, 5, 5, 0.35)', nebulaMsgBorder: 'rgba(211, 16, 39, 0.3)', nebulaMsgHoverBg: 'rgba(70, 10, 10, 0.45)', tableBorder: 'rgba(211, 16, 39, 0.4)', codeBg: 'rgba(40, 5, 5, 0.9)', codeBorder: 'rgba(211, 16, 39, 0.5)', codeText: '#ffebee', inlineCodeText: '#ff8a80', copyBtnBg: 'rgba(211, 16, 39, 0.15)', copyBtnHoverBg: 'rgba(211, 16, 39, 0.25)', copyBtnColor: '#ffcdd2', copyBtnHoverColor: '#ffebee', copyBtnCopiedBg: '#9A0007', copyBtnCopiedColor: '#ffffff', scrollbarTrack: 'rgba(77, 10, 10, 0.7)', previewBtnBg: 'rgba(211, 16, 39, 0.15)', previewBtnHoverBg: 'rgba(211, 16, 39, 0.25)', previewBtnColor: '#ffcdd2', previewBtnHoverColor: '#ffebee', tokenLow: '#D31027', tokenMedium: '#ff512f', tokenHigh: '#fffb00' },
             obsidian: { start: '#485563', end: '#29323c', border: 'rgba(72, 85, 99, 0.6)', shadow: 'rgba(72, 85, 99, 0.4)', inset: 'rgba(72, 85, 99, 0.2)', h_start: '#29323c', h_end: '#485563', h_border: 'rgba(72, 85, 99, 0.8)', h_shadow: 'rgba(72, 85, 99, 0.6)', h_inset: 'rgba(72, 85, 99, 0.3)', h_strong: 'rgba(72, 85, 99, 0.5)', statusBarBg: 'rgba(72, 85, 99, 0.3)', statusBarColor: '#cfd8dc', statusBarShadow: 'rgba(72, 85, 99, 0.4)', titleShadow: 'rgba(0, 0, 0, 0.4)', bodyBg1: '#0a0c0f', bodyBg2: '#11181f', bodyBg3: '#1a242f', bodyBg4: '#11181f', primaryText: '#eceff1', secondaryText: '#b0bec5', headerBg: 'rgba(26, 32, 39, 0.4)', headerBorder: 'rgba(72, 85, 99, 0.2)', inputBg: 'rgba(26, 32, 39, 0.5)', inputBorder: 'rgba(72, 85, 99, 0.15)', inputFocusBg: 'rgba(44, 62, 80, 0.6)', userMsgBg: 'rgba(72, 85, 99, 0.1)', userMsgBorder: 'rgba(72, 85, 99, 0.3)', userMsgHoverBg: 'rgba(72, 85, 99, 0.15)', stellarMsgBg: 'rgba(20, 30, 40, 0.3)', stellarMsgBorder: 'rgba(72, 85, 99, 0.2)', stellarMsgHoverBg: 'rgba(30, 40, 50, 0.4)', nebulaMsgBg: 'rgba(30, 40, 50, 0.35)', nebulaMsgBorder: 'rgba(72, 85, 99, 0.3)', nebulaMsgHoverBg: 'rgba(40, 50, 60, 0.45)', tableBorder: 'rgba(72, 85, 99, 0.4)', codeBg: 'rgba(15, 22, 30, 1)', codeBorder: 'rgba(72, 85, 99, 0.6)', codeText: '#eceff1', inlineCodeText: '#cfd8dc', copyBtnBg: 'rgba(72, 85, 99, 0.2)', copyBtnHoverBg: 'rgba(72, 85, 99, 0.3)', copyBtnColor: '#b0bec5', copyBtnHoverColor: '#eceff1', copyBtnCopiedBg: '#29323c', copyBtnCopiedColor: '#ffffff', scrollbarTrack: 'rgba(44, 62, 80, 0.7)', previewBtnBg: 'rgba(72, 85, 99, 0.2)', previewBtnHoverBg: 'rgba(72, 85, 99, 0.3)', previewBtnColor: '#b0bec5', previewBtnHoverColor: '#eceff1', tokenLow: '#485563', tokenMedium: '#6e7a85', tokenHigh: '#f3c700' },
              };

        if (typeof hljs !== 'undefined') { hljs.configure({ ignoreUnescapedHTML: true }); }
        const turndownService = new TurndownService({
            headingStyle: 'atx', hr: '---', bulletListMarker: '*', codeBlockStyle: 'fenced',
            emDelimiter: '_', strongDelimiter: '**', linkStyle: 'inlined'
        });
        turndownService.keep(['table', 'thead', 'tbody', 'tr', 'th', 'td']);

                function scrollToBottom() {
           
            console.log("--- scrollToBottom function called ---");
            if (!messagesDiv) {
                console.error("Error: The 'messagesDiv' element was not found.");
                return;
            }

            const lastMessage = messagesDiv.lastElementChild;
            console.log("Found messages container. scrollHeight:", messagesDiv.scrollHeight);
            console.log("Last message element found:", lastMessage);
            

            if (lastMessage) {
               
                lastMessage.scrollIntoView({ behavior: "smooth", block: "end" });
            } else {
               
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
        }
        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return '';
            return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }
        function wrapTables(htmlContent) {
            if (typeof htmlContent !== 'string' || !htmlContent.includes("<table")) return htmlContent;
            try {
                const tempDiv = document.createElement("div"); tempDiv.innerHTML = htmlContent;
                tempDiv.querySelectorAll("table").forEach(table => {
                    if (!table.parentElement || !table.parentElement.classList.contains('table-wrapper')) {
                        const wrapper = document.createElement('div'); wrapper.className = 'table-wrapper';
                        table.parentNode.insertBefore(wrapper, table); wrapper.appendChild(table);
                    }
                }); return tempDiv.innerHTML;
            } catch (e) { return htmlContent; }
        }


function processCodeBlocks(containerElement) {
    if (typeof hljs === 'undefined' || !containerElement) return;

    containerElement.querySelectorAll('pre').forEach(pre => {
        if (pre.parentElement.classList.contains('code-content-original')) {
            return;
        }

        const codeEl = pre.querySelector('code');
        if (!codeEl) return;

        const rawCode = codeEl.textContent;
        codeEl.removeAttribute('data-highlighted');
        codeEl.className = codeEl.className.replace(/hljs.*/g, '').trim();
        try {
            hljs.highlightElement(codeEl);
        } catch (err) {
            console.error("Highlighting error:", err);
        }

        const langClass = codeEl.className.match(/language-(\w+)/);
        const lang = langClass ? langClass[1] : null;
        const isPreviewable = lang === 'html';
                const isRunnable = ['python', 'c', 'cpp', 'javascript', 'typescript', 'java', 'go', 'rust', 'php', 'ruby'].includes(lang);


        const wrapper = document.createElement('div');
        wrapper.className = 'code-content-original';
        pre.parentNode.insertBefore(wrapper, pre);
        wrapper.appendChild(pre);

        const controls = document.createElement('div');
        controls.className = 'code-controls';

        
        if (isRunnable && lang !== 'html') {
            const runBtn = document.createElement('button');
            runBtn.className = 'run-code-btn';
            runBtn.innerHTML = '<svg style="width:14px; height:14px;"><use xlink:href="#icon-play"></use></svg> Run';
            runBtn.setAttribute('aria-label', 'Run code');
            controls.appendChild(runBtn);
        }

        const copyBtn = document.createElement('button');
        copyBtn.className = 'copy-code-btn';
        copyBtn.innerHTML = '<svg><use xlink:href="#icon-copy"></use></svg> Copy';
        copyBtn.setAttribute('aria-label', 'Copy code');
        copyBtn.addEventListener('click', (e) => { e.stopPropagation(); copyCode(copyBtn, codeEl); });
        controls.appendChild(copyBtn);

        const downloadBtn = document.createElement('button');
        downloadBtn.className = 'download-code-btn';
        downloadBtn.innerHTML = '<svg style="width:14px; height:14px;"><use xlink:href="#icon-download"></use></svg> Download';
        downloadBtn.setAttribute('aria-label', 'Download code file');
        controls.appendChild(downloadBtn);

        if (isPreviewable) {
            const previewContainer = document.createElement('div');
            previewContainer.className = 'code-preview-container';
            const iframe = document.createElement('iframe');
            iframe.className = 'code-preview-iframe';
            iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin allow-forms');
            try {
                iframe.srcdoc = rawCode;
            } catch (e) {
                iframe.srcdoc = `<html><body><p style='color:red;'>Error: ${escapeHtml(e.message)}</p></body></html>`;
            }
            previewContainer.appendChild(iframe);
            wrapper.appendChild(previewContainer);
            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'toggle-view-btn';
            toggleBtn.textContent = 'View Code';
            toggleBtn.addEventListener('click', (e) => { 
                e.stopPropagation();
                if (pre.style.display === 'none') {
                    pre.style.display = 'block';
                    previewContainer.style.display = 'none';
                    toggleBtn.textContent = 'View Preview';
                } else {
                    pre.style.display = 'none';
                    previewContainer.style.display = 'block';
                    toggleBtn.textContent = 'View Code';
                }
            });
            controls.appendChild(toggleBtn);

            const fullscreenBtn = document.createElement('button');
            fullscreenBtn.className = 'fullscreen-btn';
            fullscreenBtn.innerHTML = `<svg style="width:14px; height:14px;" viewBox="0 0 24 24" fill="currentColor"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>`;
            fullscreenBtn.setAttribute('aria-label', 'Toggle fullscreen preview');
            fullscreenBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (previewContainer.requestFullscreen) {
                    previewContainer.requestFullscreen();
                } else if (previewContainer.webkitRequestFullscreen) { 
                    previewContainer.webkitRequestFullscreen();
                } else if (previewContainer.msRequestFullscreen) { 
                    previewContainer.msRequestFullscreen();
                }
            });
            controls.appendChild(fullscreenBtn);
            wrapper.insertBefore(controls, pre);
            pre.style.display = 'none'; 
            previewContainer.style.display = 'block';
        } else {
            wrapper.insertBefore(controls, pre);
        }
    });
}




function createOutputPanel(wrapper, runButton) {
  
    const existingPanel = wrapper.querySelector('.code-output-container');
    if (existingPanel) {
        existingPanel.remove();
    }

    const outputContainer = document.createElement('div');
    outputContainer.className = 'code-output-container';
 
    outputContainer.dataset.containerId = ''; 

    outputContainer.innerHTML = `
        <div class="code-output-panel">
            <div class="code-output-header">
                <span class="status-text">Output</span>
                <button class="close-output-btn" title="Close Output">×</button>
            </div>
            <div class="code-output-content">
                <span class="output-line"></span>
            </div>
        </div>
    `;

    wrapper.appendChild(outputContainer);

    
    outputContainer.querySelector('.close-output-btn').addEventListener('click', async () => {
        const containerId = outputContainer.dataset.containerId;
        
       
        if (containerId) {
            try {
                await fetch('/api/stop_container', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ container_id: containerId })
                });
                console.log(`Stop request sent for container: ${containerId}`);
            } catch (error) {
                console.error('Failed to send stop request:', error);
            }
        }
        
    
        outputContainer.remove();
        runButton.classList.remove('running');
        runButton.disabled = false;
        runButton.innerHTML = '<svg style="width:14px; height:14px;"><use xlink:href="#icon-play"></use></svg> Run';
    });

    return outputContainer.querySelector('.code-output-content');
}
messagesDiv.addEventListener('click', async function (event) {
    const runButton = event.target.closest('.run-code-btn');
    if (!runButton || runButton.disabled) return;
    event.stopPropagation();

    const wrapper = runButton.closest('.code-content-original');
    const codeEl = wrapper?.querySelector('code');
    if (!wrapper || !codeEl) return;

    const langMatch = codeEl.className.match(/language-(\w+)/);
    const lang = langMatch ? langMatch[1] : 'unknown';
    const code = codeEl.textContent;

  
    const nebulaMessage = runButton.closest('.nebula-output');
    let processId = null;
    if (nebulaMessage && nebulaMessage.dataset.id) {
      
        processId = nebulaMessage.dataset.id.replace('nebula-output-', '');
    }
  

    runButton.classList.add('running');
    runButton.disabled = true;
    runButton.innerHTML = 'Connecting...';

    const outputContentDiv = createOutputPanel(wrapper, runButton);
    outputContentDiv.innerHTML = '<span class="output-line">Connecting...</span>';

    const backendRunnableLanguages = [
        'python', 'javascript', 'php', 'ruby', 'go', 'c', 'cpp', 'java', 'rust', 'typescript'
    ];

    if (backendRunnableLanguages.includes(lang)) {
       
        executeCode(code, lang, outputContentDiv, runButton, processId);
    } else {
        outputContentDiv.innerHTML = `<span class="output-line error">Execution is not supported for '${lang}' language.</span>`;
        runButton.classList.remove('running');
        runButton.disabled = false;
        runButton.innerHTML = '<svg style="width:14px; height:14px;"><use xlink:href="#icon-play"></use></svg> Run';
    }
});



async function executeCode(backendCode, lang, outputContentDiv, runButton, processId = null) {
    runButton.innerHTML = 'Running...';
    runButton.classList.add('running');
    runButton.disabled = true;
    outputContentDiv.innerHTML = '<span class="output-line initial-status" style="color: var(--secondary-text-color);">Preparing sandbox environment...</span>';
    let firstOutputReceived = false;

    try {
        const payload = {
            code: backendCode,
            language: lang,
            processId: processId
        };

        const response = await fetch('/api/run_code', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: `Execution failed with status: ${response.status}` }));
            throw new Error(errorData.error);
        }

        if (!response.body) {
            throw new Error("Streaming response not available.");
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        const outputPanel = outputContentDiv.closest('.code-output-container');

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            const sseLines = chunk.split('\n\n');

            sseLines.forEach(line => {
                if (!line.startsWith('data: ')) return;

                if (!firstOutputReceived) {
                    outputContentDiv.innerHTML = '';
                    firstOutputReceived = true;
                }

                try {
                    const data = JSON.parse(line.substring(6));
                    if (data.type === 'container_id' && data.id && outputPanel) {
                        outputPanel.dataset.containerId = data.id;
                    } else if (data.type === 'port_info') {
                        const linkEl = document.createElement('a');
                        linkEl.href = data.url;
                        linkEl.target = '_blank';
                        linkEl.rel = 'noopener noreferrer';
                        linkEl.textContent = `Server is live: ${data.url}`;
                        linkEl.style.cssText = "color: var(--nebula-confirm-start, #00c292); font-weight: bold; text-decoration: underline;";
                        const p = document.createElement('p');
                        p.style.marginBottom = '10px';
                        p.appendChild(linkEl);
                        outputContentDiv.appendChild(p);
                    } else if (data.type === 'log') {
                        const lineEl = document.createElement('span');
                        lineEl.className = 'output-line';
                        lineEl.textContent = data.content;
                        outputContentDiv.appendChild(lineEl);
                    } else if (data.type === 'error') {
                        const errorLine = document.createElement('span');
                        errorLine.className = 'output-line error';
                        errorLine.textContent = `Error: ${data.content}`;
                        outputContentDiv.appendChild(errorLine);
                    }
                } catch (e) {
                    
                }
            });
            outputContentDiv.scrollTop = outputContentDiv.scrollHeight;
        }

    } catch (error) {
        if (!firstOutputReceived) {
            outputContentDiv.innerHTML = '';
        }
        const errorLine = document.createElement('span');
        errorLine.className = 'output-line error';
        errorLine.textContent = `Error: ${error.message}`;
        outputContentDiv.appendChild(errorLine);
    } finally {
        runButton.classList.remove('running');
        runButton.disabled = false;
        runButton.innerHTML = '<svg style="width:14px; height:14px;"><use xlink:href="#icon-play"></use></svg> Run';
        if (!firstOutputReceived) {
            outputContentDiv.innerHTML = '<span class="output-line" style="color: var(--secondary-text-color);">[Execution finished with no output]</span>';
        }
    }
}

        
        function renderMath(element) {
            if (!element || typeof renderMathInElement !== 'function') { return; }
            try { renderMathInElement(element, { delimiters: katexDelimiters, throwOnError: false }); } catch (katexError) { }
        }

        function addOutputCopyButton(messageElement) {
            if (!messageElement || messageElement.classList.contains('user-msg') || messageElement.classList.contains('placeholder-message')) { return; }
            const existingContainer = messageElement.querySelector('.output-copy-btn-container'); if (existingContainer) { existingContainer.remove(); }

            const contentDiv = messageElement.querySelector('.message-content'); if (!contentDiv) return;

            const container = document.createElement('div'); container.className = 'output-copy-btn-container';
            const button = document.createElement('button'); button.className = 'output-copy-btn'; button.setAttribute('aria-label', 'Copy content'); button.innerHTML = `<svg><use xlink:href="#icon-copy"></use></svg>`;
            const tooltip = document.createElement('span'); tooltip.className = 'copy-tooltip'; tooltip.textContent = 'Copy';

            button.addEventListener('click', (e) => {
                e.stopPropagation();
                const textToCopy = contentDiv.textContent || contentDiv.innerText || '';
                 if (!textToCopy) { return; }

                navigator.clipboard.writeText(textToCopy).then(() => {
                    button.innerHTML = `<svg><use xlink:href="#icon-check"></use></svg>`; tooltip.textContent = 'Copied!';
                    tooltip.classList.add('visible'); button.classList.add('copied'); button.disabled = true;
                    setTimeout(() => {
                        tooltip.classList.remove('visible');
                         setTimeout(() => {
                             tooltip.textContent = 'Copy'; button.innerHTML = `<svg><use xlink:href="#icon-copy"></use></svg>`;
                             button.classList.remove('copied'); button.disabled = false;
                         }, parseFloat(getComputedStyle(tooltip).transitionDuration) * 1000 || 150);
                    }, 1500);
                }).catch(err => {
                    const originalContent = button.innerHTML;
                    button.textContent = 'Error'; setTimeout(() => { button.innerHTML = originalContent; button.disabled = false; }, 1500);
                });
            });

            container.appendChild(button); container.appendChild(tooltip);
            messageElement.appendChild(container);
        }

function appendUserMessage(text, id) {
    const lastEditIcon = document.querySelector('.user-msg:last-of-type .edit-prompt-wrapper');
    if (lastEditIcon) {
        lastEditIcon.remove();
    }

    const msg = document.createElement("div");
    msg.classList.add("message", "user-msg");
    msg.dataset.id = id;

    const contentDiv = document.createElement("div");
    contentDiv.classList.add("message-content");
    contentDiv.textContent = text;
    msg.appendChild(contentDiv);

    const editWrapper = document.createElement('div');
    editWrapper.className = 'edit-prompt-wrapper';
    
    const editIcon = document.createElement('span');
    editIcon.className = 'edit-prompt-icon';
    editIcon.title = 'Edit & Resubmit Prompt';
    editIcon.innerHTML = `<svg viewBox="0 0 24 24"><path fill="currentColor" d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>`;
    
    editWrapper.appendChild(editIcon);
    msg.appendChild(editWrapper);

    editIcon.addEventListener('click', (e) => {
        e.stopPropagation();

        const originalPromptBubble = e.target.closest('.user-msg');

        contentDiv.style.display = 'none';
        editWrapper.style.display = 'none';

        const editContainer = document.createElement('div');
        editContainer.className = 'edit-container';
        
        const editTextarea = document.createElement('textarea');
        editTextarea.className = 'edit-textarea';
        editTextarea.value = text;
        
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'edit-buttons';
        
        const saveButton = document.createElement('button');
        saveButton.className = 'edit-save-btn';
        saveButton.textContent = 'Save & Resubmit';
        
        const cancelButton = document.createElement('button');
        cancelButton.className = 'edit-cancel-btn';
        cancelButton.textContent = 'Cancel';

        buttonContainer.appendChild(cancelButton);
        buttonContainer.appendChild(saveButton);
        editContainer.appendChild(editTextarea);
        editContainer.appendChild(buttonContainer);
        
        originalPromptBubble.appendChild(editContainer);
        editTextarea.focus();

        const cleanupAndExitEditMode = () => {
            editContainer.remove();
            contentDiv.style.display = 'block';
            editWrapper.style.display = 'flex';
        };

        cancelButton.addEventListener('click', cleanupAndExitEditMode);

        saveButton.addEventListener('click', async () => {
            const correctedText = editTextarea.value.trim();
            const messageId = originalPromptBubble.dataset.id;

            if (!correctedText || correctedText === text) {
                cleanupAndExitEditMode();
                return;
            }
            if (isProcessing) {
                setStatus("Cannot edit while a response is being generated.", true);
                setTimeout(() => setStatus(currentStatusText, false), 3000);
                cleanupAndExitEditMode();
                return;
            }

            try {
                const response = await fetch('/api/messages/delete_after', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message_id: messageId,
                        chat_id: currentChatId
                    })
                });

                if (!response.ok) {
                    const errData = await response.json();
                    throw new Error(errData.error || 'Failed to update chat history.');
                }

               
                let currentElem = originalPromptBubble;
                while (currentElem) {
                    let toRemove = currentElem;
                    currentElem = currentElem.nextElementSibling;
                    toRemove.remove();
                }
                
                
                chatInput.value = correctedText;
                handleSend();

            } catch (error) {
                console.error('Error during edit & resubmit:', error);
                setStatus(`Error: ${error.message}`, true);
            } finally {
                cleanupAndExitEditMode();
            }
        });
    });

    if (messagesDiv) {
        messagesDiv.appendChild(msg);
    }
    scrollToBottom();
}function flashVisualFeedback() {
    const fileUploadButton = document.querySelector('.file-upload-label-button');
    if (fileUploadButton) {
        fileUploadButton.classList.add('file-feedback-active');
        setTimeout(() => {
            fileUploadButton.classList.remove('file-feedback-active');
        }, 500); // Duration matches the animation
    }
}
    function appendResearchOutput(markdownText, id) {
            const msg = document.createElement("div"); msg.classList.add("message", "stellar-msg", "research-output"); msg.dataset.id = id;
            const contentDiv = document.createElement("div"); contentDiv.classList.add("message-content");
            try {
                let htmlText = marked.parse(markdownText || ""); htmlText = wrapTables(htmlText); contentDiv.innerHTML = htmlText; msg.appendChild(contentDiv);
                processCodeBlocks(contentDiv); renderMath(contentDiv);
                addOutputCopyButton(msg);
                setTimeout(scrollToBottom, 50);
            } catch (e) { contentDiv.textContent = "Error."; scrollToBottom(); }
            if (messagesDiv) messagesDiv.appendChild(msg);updateTokenCount();
        }

        function createAndAppendResearchButtons(msgContainer, messageId, initialHtmlContent) {
            if (!msgContainer || !msgContainer.classList.contains('research-output')) return;
            const existingButtonsDiv = msgContainer.querySelector('.message-buttons'); if (existingButtonsDiv) existingButtonsDiv.remove();

            const buttonsDiv = document.createElement('div'); buttonsDiv.classList.add('message-buttons');
            const editButton = document.createElement("button"); editButton.textContent = "Edit"; editButton.classList.add("edit-paper-btn");
            editButton.addEventListener("click", function () { const msgDiv = this.closest('.message.research-output'); if (msgDiv) { const currentHTML = msgDiv.querySelector('.message-content').innerHTML; const id = msgDiv.dataset.id; showEditModal(id, currentHTML, msgDiv); } });
            const downloadButton = document.createElement("button"); downloadButton.textContent = "Download"; downloadButton.classList.add("download-btn");
            downloadButton.addEventListener("click", () => { const msgDiv = downloadButton.closest('.message.research-output'); if (msgDiv) { const currentHTML = msgDiv.querySelector('.message-content').innerHTML; const currentWidth = msgDiv.offsetWidth; downloadHtml(currentHTML, currentWidth); } });
            buttonsDiv.appendChild(editButton); buttonsDiv.appendChild(downloadButton);
            msgContainer.appendChild(buttonsDiv);
        }

        function setStatus(text, isError = false) {
            if (!statusBar) return; currentStatusText = text; statusBar.textContent = text;
            const analysisAreaHasContent = document.getElementById('analysis-progress-area')?.childElementCount > 0;
            const stagedFilesExist = stagedFilesContainer?.childElementCount > 0 && stagedFilesContainer?.style.display !== 'none';

            const isActive = text.toLowerCase() !== "idle" || isProcessing || nebulaProcess.isActive || analysisAreaHasContent || stagedFilesExist;
            statusBar.classList.toggle("active", isActive && !isError); statusBar.classList.toggle("error", isError);
            if (isActive && !isError) { statusBar.style.animation = ''; requestAnimationFrame(() => { statusBar.style.animation = 'statusBarPulse 2.5s infinite alternate ease-in-out'; }); } else { statusBar.style.animation = ''; }
            updateStatusBarPosition();
        }
        function updateStatusBarPosition() {
            if (!inputContainer || !statusBar) return;
            try { const inputRect = inputContainer.getBoundingClientRect(); const progressArea = document.getElementById('analysis-progress-area'); const progressAreaHeight = (progressArea && progressArea.offsetHeight > 0 && progressArea.style.display !== 'none') ? progressArea.offsetHeight : 0; const stagedContainer = document.getElementById('stagedFilesContainer'); const stagedHeight = (stagedContainer && stagedContainer.offsetHeight > 0 && stagedContainer.style.display !== 'none') ? stagedContainer.offsetHeight + 5 : 0; const extraGap = (progressAreaHeight > 0 || stagedHeight > 0) ? 10 : 0; statusBar.style.bottom = `${window.innerHeight - inputRect.top + 5 + progressAreaHeight + stagedHeight + extraGap}px`; } catch (e) { const inputRect = inputContainer.getBoundingClientRect(); statusBar.style.bottom = `${window.innerHeight - inputRect.top + 5}px`; }
        }
        function adjustTextareaHeight() {
            if (!chatInput) return; try { chatInput.style.height = "auto"; const newHeight = Math.min(chatInput.scrollHeight, 240); chatInput.style.height = `${newHeight}px`; chatInput.style.overflowY = newHeight >= 240 ? "auto" : "hidden"; updateStatusBarPosition(); } catch (e) { }
        }
        function showEditModal(id, htmlContent, msgDiv) {
            currentEditingMsg = msgDiv; currentEditingMsgId = id; try { editMarkdownInput.value = turndownService.turndown(htmlContent || ""); } catch (e) { editMarkdownInput.value = "Error converting."; } if (editModalBackdrop) editModalBackdrop.style.display = "flex"; if (editMarkdownInput) setTimeout(() => editMarkdownInput.focus(), 100);
        }
        function hideEditModal() {
            if (editModalBackdrop) editModalBackdrop.style.display = "none"; currentEditingMsg = null; currentEditingMsgId = null; if (editMarkdownInput) editMarkdownInput.value = "";
        }
        function showRegenerateModal(stepNumber) {
            if (!nebulaProcess.isActive) return; currentRegeneratingStep = stepNumber; regenerateModalTitle.textContent = `Regenerate Step ${stepNumber}: ${getNebulaStepTitle(stepNumber)}`; regenerateFeedbackInput.value = ""; if (regenerateModalBackdrop) regenerateModalBackdrop.style.display = "flex"; if (regenerateFeedbackInput) setTimeout(() => regenerateFeedbackInput.focus(), 100);
        }
        function hideRegenerateModal() {
            if (regenerateModalBackdrop) regenerateModalBackdrop.style.display = "none"; regenerateFeedbackInput.value = ""; currentRegeneratingStep = null; if (nebulaProcess.isActive && !isProcessing) { updateNebulaButtonStates(); }
        }

        function triggerRegeneration(stepToRegenerate, feedback = null) {
            clearTimeout(nebulaAutoContinueTimerId); nebulaAutoContinueTimerId = null;
            if (stepToRegenerate === null || !nebulaProcess.isActive || isProcessing) { setStatus("Cannot regen now.", true); setTimeout(() => setStatus(currentStatusText, false), 2500); hideRegenerateModal(); return; }
            setStatus(`Nebula: Regenerating ${getNebulaStepTitle(stepToRegenerate)}...`); isProcessing = true; sendBtn.disabled = true; disableAllNebulaStepActions();
            if (stepToRegenerate <= nebulaProcess.currentStep) {
                const stepsContainer = nebulaProcess.messageElement?.querySelector('.nebula-steps-container');
                if (stepsContainer) { for (let i = stepToRegenerate; i <= 4; i++) { const stepDiv = stepsContainer.querySelector(`.nebula-step-content[data-step="${i}"]`); if (stepDiv) stepDiv.remove(); } }
                if (stepToRegenerate <= 1) nebulaProcess.planOutput = null; if (stepToRegenerate <= 2) nebulaProcess.frontendOutput = null; if (stepToRegenerate <= 3) nebulaProcess.backendOutput = null; if (stepToRegenerate <= 4) nebulaProcess.verificationOutput = null; nebulaProcess.reportUrl = null; nebulaProcess.currentStep = stepToRegenerate;
            }
            requestNebulaStep(stepToRegenerate, true, feedback); hideRegenerateModal();
        }
        function handleSaveRegeneration() { const feedback = regenerateFeedbackInput.value.trim(); triggerRegeneration(currentRegeneratingStep, feedback); }


         function handleStopAutoContinue(stepNumber) {
             if (nebulaAutoContinueTimerId && nebulaProcess.currentStep === stepNumber) {
                 clearTimeout(nebulaAutoContinueTimerId);
                 nebulaAutoContinueTimerId = null;
                 setStatus(`Nebula: Auto-continue stopped. Confirm ${getNebulaStepTitle(stepNumber)}...`);
                 const actionsDiv = nebulaProcess.messageElement?.querySelector(`.nebula-step-actions[data-step="${stepNumber}"]`);
                 const stopAutoBtn = actionsDiv?.querySelector('.nebula-stop-auto-btn');
                 if (stopAutoBtn) {
                     stopAutoBtn.style.display = 'none';
                     stopAutoBtn.disabled = true;
                 }
             }
         }

        function disableAllNebulaStepActions() {
            if (!nebulaProcess.messageElement) return;
            const allConfirmBtns = nebulaProcess.messageElement.querySelectorAll('.nebula-confirm-btn');
            const allRegenerateBtns = nebulaProcess.messageElement.querySelectorAll('.nebula-regenerate-btn');
            const allStopAutoBtns = nebulaProcess.messageElement.querySelectorAll('.nebula-stop-auto-btn');
            allConfirmBtns.forEach(btn => btn.disabled = true);
            allRegenerateBtns.forEach(btn => btn.disabled = true);
            allStopAutoBtns.forEach(btn => { btn.disabled = true; btn.style.display = 'none'; });
        }
        function updateSpectrumSearchButtonState(isOn) {
            useSpectrumSearch = isOn;
            if (spectrumSearchBtn) {
                spectrumSearchBtn.classList.toggle("on", isOn);
                spectrumSearchBtn.disabled = currentMode !== 'spectrum';
            }
        }

        // REPLACE the existing handleModeChange function with this new one
        function handleModeChange() {
            const newMode = modeSelector.value;
            const codeLabContainer = document.getElementById('codeLabContainer');
            const chatContainer = document.getElementById('chatContainer');
            const inputContainer = document.getElementById('inputContainer');
            
            const problemSolvingUI = [document.getElementById('ai-mentor-panel'), document.getElementById('workspace-panel')];
            const forgeUI = document.getElementById('forge-container');

            const modeSelectorElem = document.getElementById('modeSelector');
            const headerContainer = document.getElementById('modeSelectorHeaderContainer');
            const inputBarContainer = document.getElementById('modeSelectorInputContainer');

            if (nebulaProcess.isActive && (isProcessing || (nebulaProcess.currentStep >= 1 && nebulaProcess.currentStep <= 3))) {
                 let reason = isProcessing ? `Wait for Nebula Step ${nebulaProcess.currentStep}.` : `Confirm/Regen Nebula Step ${nebulaProcess.currentStep}.`;
                 setStatus(`Cannot switch mode: ${reason}`, true); setTimeout(() => setStatus(currentStatusText, false), 3000); modeSelector.value = currentMode; return;
            }
            if (currentMode === 'nebula' && newMode !== 'nebula' && nebulaProcess.isActive) { cleanupNebulaProcess(true, "Aborted by mode change."); }

            currentMode = newMode;
            modeSelectorElem.classList.toggle("active-mode", newMode !== 'stellar');
             
            if (newMode === 'codelab') {
                chatContainer.style.display = 'none';
                inputContainer.style.display = 'none';
                codeLabContainer.style.display = 'flex';
                headerContainer.appendChild(modeSelectorElem);
                
                // Trigger the click to default to the Problem Solving view
                document.getElementById('switchToProblemModeBtn').click();
                if(codeLabEditor) setTimeout(() => codeLabEditor.refresh(), 1);

            } else {
                if (isForgeSessionActive) {
                    if (confirm("Leaving CodeLab will end your current Stellar Forge session. Are you sure?")) {
                        handleForgeStop();
                    } else {
                        modeSelector.value = 'codelab'; // Revert change if user cancels
                        return;
                    }
                }
                chatContainer.style.display = 'flex';
                inputContainer.style.display = 'flex';
                codeLabContainer.style.display = 'none';
                inputBarContainer.appendChild(modeSelectorElem);
                updateModelSelectTheme();
            }

            spectrumSearchBtn.style.display = (currentMode === 'spectrum') ? "inline-block" : "none";
            updateSpectrumSearchButtonState(useSpectrumSearch);

            switch (currentMode) {
                 case 'spectrum': chatInput.placeholder = "Enter research query for Spectrum..."; break;
                 case 'nebula': chatInput.placeholder = "Describe the app for Nebula..."; break;
                 case 'cosmos': chatInput.placeholder = "Enter your request for Cosmos..."; break;
                 default: chatInput.placeholder = "Send a message to Stellar..."; break;
            }

            enableDisableModelOptions();
            if (newMode !== 'codelab') {
                chatInput.focus();
                adjustTextareaHeight();
            }
        }
        function enableDisableModelOptions() {
            let currentModelSelected = modelSelect.value; let validModelFound = false; let firstValidModel = null;
            const isNebula = currentMode === 'nebula'; const isCosmos = currentMode === 'cosmos';
            for (const option of modelSelect.options) {
                 let isCompatible = true;
                 if (isNebula) { isCompatible = NEBULA_COMPATIBLE_MODELS.includes(option.value); }
                 else if (isCosmos) { isCompatible = COSMOS_COMPATIBLE_MODELS.includes(option.value); }

                option.disabled = !isCompatible;
                if (isCompatible) { if (!firstValidModel) firstValidModel = option.value; if (option.value === currentModelSelected) validModelFound = true; }
                option.style.opacity = isCompatible ? '1' : '0.5'; option.style.cursor = isCompatible ? 'pointer' : 'not-allowed';
            }
            if ((isNebula || isCosmos) && !validModelFound) {
                 const switchTo = firstValidModel || (isNebula ? DEFAULT_NEBULA_MODEL : modelSelect.options[0].value);
                 modelSelect.value = switchTo; updateModelSelectWidth(); updateModelSelectTheme();
            }
        }
        function updateModelSelectWidth() {
            if (!modelSelect || !modelSelectWidthHelper) return; const selectedOption = modelSelect.options[modelSelect.selectedIndex];
            if (selectedOption) { modelSelectWidthHelper.textContent = selectedOption.text; const textWidth = modelSelectWidthHelper.offsetWidth; const padding = 28; const borderWidth = 2; const buffer = 10; const newWidth = textWidth + padding + borderWidth + buffer; modelSelect.style.width = `${Math.max(100, newWidth)}px`; } else { modelSelect.style.width = 'auto'; }
        }
        function updateModelSelectTheme() {
            if (!modelSelect || !bodyElement) return; const selectedOption = modelSelect.options[modelSelect.selectedIndex];
            if (selectedOption) { const modelKey = selectedOption.value; const themeName = selectedOption.text.toLowerCase().replace(/\s+/g, '-'); const theme = modelThemes[modelKey] || modelThemes[themeName] || modelThemes.lunarity; const root = document.documentElement; bodyElement.className = `theme-${themeName}`;
                Object.keys(theme).forEach(key => { let cssVarName;
                    if (key.startsWith('h_')) { if (key === 'h_strong') cssVarName = '--model-hover-shadow-strong'; else if (key === 'h_inset') cssVarName = '--model-hover-color-shadow-inset'; else if (key === 'h_shadow') cssVarName = '--model-hover-color-shadow'; else if (key === 'h_border') cssVarName = '--model-hover-color-border'; else cssVarName = `--model-hover-color-${key.substring(2).replace('_', '-')}`; }
                    else if (['start', 'end', 'border', 'shadow', 'inset'].includes(key)) { cssVarName = `--model-color-${key.replace('_', '-')}`; }
                    else { switch (key) { case 'bodyBg1': cssVarName = '--body-bg-color1'; break; case 'bodyBg2': cssVarName = '--body-bg-color2'; break; case 'bodyBg3': cssVarName = '--body-bg-color3'; break; case 'bodyBg4': cssVarName = '--body-bg-color4'; break; case 'titleShadow': cssVarName = '--title-shadow-color'; break; case 'statusBarBg': cssVarName = '--status-bar-bg'; break; case 'statusBarColor': cssVarName = '--status-bar-color'; break; case 'statusBarShadow': cssVarName = '--status-bar-shadow'; break; case 'primaryText': cssVarName = '--primary-text-color'; break; case 'secondaryText': cssVarName = '--secondary-text-color'; break; case 'headerBg': cssVarName = '--header-bg'; break; case 'headerBorder': cssVarName = '--header-border'; break; case 'inputBg': cssVarName = '--input-bg'; break; case 'inputBorder': cssVarName = '--input-border'; break; case 'inputFocusBg': cssVarName = '--input-focus-bg'; break; case 'userMsgBg': cssVarName = '--user-msg-bg'; break; case 'userMsgBorder': cssVarName = '--user-msg-border'; break; case 'userMsgHoverBg': cssVarName = '--user-msg-hover-bg'; break; case 'stellarMsgBg': cssVarName = '--stellar-msg-bg'; break; case 'stellarMsgBorder': cssVarName = '--stellar-msg-border'; break; case 'stellarMsgHoverBg': cssVarName = '--stellar-msg-hover-bg'; break; case 'nebulaMsgBg': cssVarName = '--nebula-msg-bg'; break; case 'nebulaMsgBorder': cssVarName = '--nebula-msg-border'; break; case 'nebulaMsgHoverBg': cssVarName = '--nebula-msg-hover-bg'; break; case 'tableBorder': cssVarName = '--table-border-color'; break; case 'codeBg': cssVarName = '--code-bg'; break; case 'codeBorder': cssVarName = '--code-border'; break; case 'codeText': cssVarName = '--code-text-color'; break; case 'inlineCodeText': cssVarName = '--inline-code-text-color'; break; case 'copyBtnBg': cssVarName = '--code-btn-bg'; break; case 'copyBtnHoverBg': cssVarName = '--code-btn-hover-bg'; break; case 'copyBtnColor': cssVarName = '--code-btn-color'; break; case 'copyBtnHoverColor': cssVarName = '--code-btn-hover-color'; break; case 'copyBtnCopiedBg': cssVarName = '--copy-btn-copied-bg'; break; case 'copyBtnCopiedColor': cssVarName = '--copy-btn-copied-color'; break; case 'scrollbarTrack': cssVarName = '--scrollbar-track-bg'; break; case 'previewBtnBg': cssVarName = '--preview-btn-bg'; break; case 'previewBtnHoverBg': cssVarName = '--preview-btn-hover-bg'; break; case 'previewBtnColor': cssVarName = '--preview-btn-color'; break; case 'previewBtnHoverColor': cssVarName = '--preview-btn-hover-color'; break; case 'tokenLow': cssVarName = '--token-bar-fill-low'; break; case 'tokenMedium': cssVarName = '--token-bar-fill-medium'; break; case 'tokenHigh': cssVarName = '--token-bar-fill-high'; break; default: cssVarName = null; } }
                    if (cssVarName) { root.style.setProperty(cssVarName, theme[key]); } });
                root.style.setProperty('--link-color', theme.start); root.style.setProperty('--link-hover-color', theme.h_start); root.style.setProperty('--input-focus-border', theme.border); root.style.setProperty('--inline-code-bg', theme.stellarMsgBg || 'rgba(0,0,0, 0.3)'); root.style.setProperty('--status-bar-idle-color', theme.secondaryText); root.style.setProperty('--status-bar-idle-bg', 'rgba(0, 0, 0, 0.2)'); root.style.setProperty('--scrollbar-thumb-start', theme.start); root.style.setProperty('--scrollbar-thumb-end', theme.end); root.style.setProperty('--scrollbar-thumb-border', theme.border); root.style.setProperty('--scrollbar-thumb-hover-start', theme.h_start); root.style.setProperty('--scrollbar-thumb-hover-end', theme.h_end); root.style.setProperty('--scrollbar-thumb-hover-border', theme.h_border);
                 root.style.setProperty('--output-copy-btn-bg', theme.copyBtnBg || 'rgba(50, 50, 50, 0.7)');
                 root.style.setProperty('--output-copy-btn-hover-bg', theme.copyBtnHoverBg || 'rgba(70, 70, 70, 0.8)');
                 root.style.setProperty('--output-copy-btn-color', theme.secondaryText || '#d1d5db');
                 root.style.setProperty('--output-copy-btn-hover-color', theme.primaryText || '#ffffff');
                 root.style.setProperty('--output-copy-btn-copied-bg', theme.start || '#20a375');
                 root.style.setProperty('--output-copy-btn-copied-color', '#ffffff');
                 const glow1 = document.querySelector('.glow-1'); const glow2 = document.querySelector('.glow-2'); if (glow1) glow1.style.background = `radial-gradient(circle, ${theme.start}99 0%, rgba(123, 97, 255, 0) 70%)`; if (glow2) glow2.style.background = `radial-gradient(circle, ${theme.end}99 0%, rgba(181, 84, 255, 0) 70%)`; }
        }

        function getNebulaStepTitle(stepNumber) { switch (stepNumber) { case 1: return "Planning"; case 2: return "Frontend Code"; case 3: return "Backend Code"; case 4: return "Verification"; default: return `Step ${stepNumber}`; } }
        function getNebulaStepActionDescription(stepNumber) { switch (stepNumber) { case 1: return "Planning"; case 2: return "Frontend"; case 3: return "Backend"; case 4: return "Verification"; default: `Step ${stepNumber}`; } }

     

function displayNebulaStepOutput(stepNumber, markdownText) {
    if (!nebulaProcess.messageElement) return;
    const stepsContainer = nebulaProcess.messageElement.querySelector('.nebula-steps-container');
    if (!stepsContainer) return;

    let stepDiv = stepsContainer.querySelector(`.nebula-step-content[data-step="${stepNumber}"]`);
    if (!stepDiv) {
        stepDiv = document.createElement('div');
        stepDiv.classList.add('nebula-step-content');
        stepDiv.dataset.step = stepNumber;
        stepsContainer.appendChild(stepDiv);
    } else {
        stepDiv.innerHTML = '';
    }

    const stepTitle = getNebulaStepTitle(stepNumber);
    let stepHtml = "";
    try {
        stepHtml = marked.parse(String(markdownText || `(Waiting...)`));
        stepHtml = wrapTables(stepHtml);
    } catch (e) {
        stepHtml = `<pre>Error parsing: ${escapeHtml(e.message)}\n\n${escapeHtml(String(markdownText || ''))}</pre>`;
    }

    stepDiv.innerHTML = `<h3>${stepTitle}</h3><div class="step-output">${stepHtml}</div>`;

    if (stepNumber >= 1 && stepNumber <= 3 && !stepDiv.querySelector('.nebula-step-actions')) {
        const actionsDiv = document.createElement('div');
        actionsDiv.classList.add('nebula-step-actions');
        actionsDiv.dataset.step = stepNumber;
        actionsDiv.innerHTML = `
            <button class="nebula-confirm-btn" onclick="handleNebulaConfirm(${stepNumber})" disabled>Confirm 👍</button>
            <button class="nebula-regenerate-btn" onclick="handleNebulaRegenerate(${stepNumber})" disabled>Regen 🔄</button>
            <button class="nebula-stop-auto-btn" onclick="handleStopAutoContinue(${stepNumber})" disabled style="display:none;" title="Cancel automatic continuation">Stop Auto ⏱️</button>
        `;
        stepDiv.appendChild(actionsDiv);
    }

    if (stepNumber === 1) {
        const keysSectionRegex = /1\.\s+Required\s+API\s+Keys[\s\S]*?(?=2\.\s+HTML|## 2\.|Plain-Language Summary)/;
        const keyNameRegex = /`([A-Z_]+)`/g;
        const keysSectionMatch = markdownText.match(keysSectionRegex);
        let requiredKeys = [];

        if (keysSectionMatch && !/None/i.test(keysSectionMatch[0])) {
            let match;
            while ((match = keyNameRegex.exec(keysSectionMatch[0])) !== null) {
                requiredKeys.push(match[1]);
            }
        }
        
        if (requiredKeys.length > 0) {
            const actionsDiv = stepDiv.querySelector('.nebula-step-actions');
            if (actionsDiv) {
                const confirmBtn = actionsDiv.querySelector('.nebula-confirm-btn');
                if (confirmBtn) confirmBtn.disabled = true;

                const keyFormContainer = document.createElement('div');
                keyFormContainer.className = 'nebula-api-keys-form';
                keyFormContainer.style.cssText = 'margin-top: 15px; padding: 15px; border: 1px solid var(--nebula-msg-border); border-radius: 8px; background: rgba(0,0,0,0.1);';
                
                let formHTML = '<h4>API Keys Required</h4><p style="font-size: 0.85em; color: var(--secondary-text-color); margin-bottom: 10px;">Please provide the following keys to continue:</p>';
                requiredKeys.forEach(key => {
                    formHTML += `
                        <div style="margin-bottom: 10px;">
                            <label for="key-input-${key}" style="display: block; margin-bottom: 3px; font-size: 0.9em;">${key}</label>
                            <input type="password" id="key-input-${key}" name="${key}" placeholder="Enter your key here" style="width: 100%; padding: 8px; background: rgba(0,0,0,0.2); border: 1px solid var(--code-border); color: white; border-radius: 4px;">
                        </div>
                    `;
                });
                keyFormContainer.innerHTML = formHTML;
                stepDiv.insertBefore(keyFormContainer, actionsDiv);

                const saveKeysBtn = document.createElement('button');
                saveKeysBtn.textContent = 'Save Keys';
                saveKeysBtn.className = 'nebula-confirm-btn';
                saveKeysBtn.style.marginLeft = '10px';
                saveKeysBtn.onclick = () => saveNebulaKeysAndContinue(true);
                actionsDiv.appendChild(saveKeysBtn);
            }
        }
    }

    const outputDiv = stepDiv.querySelector('.step-output');
    if (outputDiv) {
        processCodeBlocks(outputDiv);
        setTimeout(() => {
            renderMath(outputDiv);
            addOutputCopyButton(nebulaProcess.messageElement);
            scrollToBottom();
        }, 150);
    } else {
        scrollToBottom();
    }
}

async function saveNebulaKeysAndContinue() {
    if (!nebulaProcess.isActive || !nebulaProcess.messageElement) return;

    const formContainer = nebulaProcess.messageElement.querySelector('.nebula-api-keys-form');
    if (!formContainer) {
        handleNebulaConfirm(1);
        return;
    }

    const inputs = formContainer.querySelectorAll('input[type="password"]');
    const apiKeys = {};
    let allKeysProvided = true;

    inputs.forEach(input => {
        const keyName = input.name;
        const keyValue = input.value.trim();
        if (!keyValue) {
            allKeysProvided = false;
            input.style.borderColor = 'var(--nebula-regenerate-start)';
        } else {
            input.style.borderColor = 'var(--code-border)';
        }
        apiKeys[keyName] = keyValue;
    });

    if (!allKeysProvided) {
        setStatus("Please provide all required API keys.", true);
        setTimeout(() => setStatus(currentStatusText, false), 3000);
        return;
    }

    setStatus("Saving API keys...");
    try {
        const response = await fetch('/nebula/save_keys', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                processId: nebulaProcess.processId,
                api_keys: apiKeys
            })
        });

        const data = await response.json();
        if (!response.ok || !data.success) {
            throw new Error(data.error || 'Failed to save keys on the server.');
        }

        formContainer.style.display = 'none';
        handleNebulaConfirm(1);

    } catch (err) {
        setStatus(`Error saving keys: ${err.message}`, true);
        setTimeout(() => setStatus(currentStatusText, false), 4000);
    }
}

function _createAndAppendStepDiv(stepNumber, markdownText, stepsContainer) {
    if (!markdownText) return;

    const stepDiv = document.createElement('div');
    stepDiv.classList.add('nebula-step-content');
    stepDiv.dataset.step = stepNumber;

    const stepTitle = getNebulaStepTitle(stepNumber);
    let stepHtml = "";
    try {
        stepHtml = marked.parse(String(markdownText));
        stepHtml = wrapTables(stepHtml);
    } catch (e) {
        stepHtml = `<p>Error rendering content.</p>`;
    }

    stepDiv.innerHTML = `<h3>${stepTitle}</h3><div class="step-output">${stepHtml}</div>`;

    
    if (stepNumber >= 1 && stepNumber <= 3) {
        const actionsDiv = document.createElement('div');
        actionsDiv.classList.add('nebula-step-actions');
        actionsDiv.dataset.step = stepNumber;
        actionsDiv.innerHTML = `
            <button class="nebula-confirm-btn" id="confirm-btn-step-${stepNumber}" onclick="handleNebulaConfirm(${stepNumber})" disabled>Confirm 👍</button>
            <button class="nebula-regenerate-btn" id="regen-btn-step-${stepNumber}" onclick="handleNebulaRegenerate(${stepNumber})" disabled>Regen 🔄</button>
            <button class="nebula-stop-auto-btn" id="stop-auto-btn-step-${stepNumber}" onclick="handleStopAutoContinue(${stepNumber})" disabled style="display:none;" title="Cancel the automatic continuation timer">Stop Auto ⏱️</button>
        `;
        stepDiv.appendChild(actionsDiv);
    }

    stepsContainer.appendChild(stepDiv);

    
    const outputDiv = stepDiv.querySelector('.step-output');
    if (outputDiv) {
        if (stepNumber === 3) { 
             outputDiv.querySelectorAll('pre > code').forEach(codeEl => {
                if (!/language-/.test(codeEl.className)) codeEl.classList.add('language-python');
            });
        }
        processCodeBlocks(outputDiv);
        setTimeout(() => renderMath(outputDiv), 50);
    }
}


function renderAllNebulaSteps() {
    if (!nebulaProcess.messageElement) return;
    const stepsContainer = nebulaProcess.messageElement.querySelector('.nebula-steps-container');
    if (!stepsContainer) return;

   
    stepsContainer.innerHTML = '';

   
    _createAndAppendStepDiv(1, nebulaProcess.planOutput, stepsContainer);
    _createAndAppendStepDiv(2, nebulaProcess.frontendOutput, stepsContainer);
    _createAndAppendStepDiv(3, nebulaProcess.backendOutput, stepsContainer);
    _createAndAppendStepDiv(4, nebulaProcess.verificationOutput, stepsContainer);

    
    updateNebulaButtonStates();
    addOutputCopyButton(nebulaProcess.messageElement);
    scrollToBottom();
}

        function handleNebulaConfirm(confirmedStepNumber) {
            clearTimeout(nebulaAutoContinueTimerId); nebulaAutoContinueTimerId = null; if (!nebulaProcess.isActive || isProcessing || nebulaProcess.currentStep !== confirmedStepNumber) { setStatus("Cannot proceed.", true); setTimeout(() => setStatus(currentStatusText, false), 2500); return; }
            disableAllNebulaStepActions(); const nextStep = confirmedStepNumber + 1; if (nextStep <= 4) { setStatus(`Nebula: Processing ${getNebulaStepTitle(nextStep)}...`); isProcessing = true; sendBtn.disabled = true; nebulaProcess.currentStep = nextStep; requestNebulaStep(nextStep); } else { cleanupNebulaProcess(true, "Internal error post-confirm."); }
        }
        function handleNebulaRegenerate(stepToRegenerate) {
            clearTimeout(nebulaAutoContinueTimerId); nebulaAutoContinueTimerId = null; if (!nebulaProcess.isActive || isProcessing) { const msg = isProcessing ? "Cannot regen while processing." : "Nebula inactive."; setStatus(msg, true); setTimeout(() => setStatus(currentStatusText, false), 2500); return; }
            disableAllNebulaStepActions(); showRegenerateModal(stepToRegenerate); setStatus(`Nebula: Awaiting regen feedback for ${getNebulaStepTitle(stepToRegenerate)}...`);
        }
        function createNebulaMessageContainer(processId) {
            const msg = document.createElement("div"); msg.classList.add("message", "stellar-msg", "nebula-output"); msg.dataset.id = `nebula-output-${processId}`; const contentDiv = document.createElement("div"); contentDiv.classList.add("message-content"); contentDiv.innerHTML = `<h2>Nebula <span class="nebula-status">(Initializing...)</span></h2><div class="nebula-steps-container"></div><div class="nebula-final-summary"></div>`; msg.appendChild(contentDiv); if (messagesDiv) messagesDiv.appendChild(msg); addOutputCopyButton(msg); scrollToBottom(); return msg;
        }
function cleanupNebulaProcess(showErrorStatus = false, errorMessage = null) {
    toggleSendStopButtons(false); 
    clearTimeout(nebulaAutoContinueTimerId);
    nebulaAutoContinueTimerId = null;
    const wasActive = nebulaProcess.isActive;
    isProcessing = false;
    sendBtn.disabled = false;
    const finalStatus = showErrorStatus ? (errorMessage ? `Nebula Error: ${errorMessage}` : "Nebula Error") : (wasActive ? "Nebula Finished" : "Idle");
    setStatus(finalStatus, showErrorStatus);
    
    if (nebulaProcess.messageElement) {
        const statusSpan = nebulaProcess.messageElement.querySelector('.nebula-status');
        if (statusSpan) {
            statusSpan.textContent = showErrorStatus ? `(Error)` : `(Finished)`;
        }
        if (showErrorStatus) {
            nebulaProcess.messageElement.style.borderColor = 'var(--nebula-regenerate-start)';
        }
        disableAllNebulaStepActions();
        addOutputCopyButton(nebulaProcess.messageElement);
    }
    
    resetNebulaProcessState();
    
    if (showErrorStatus) {
        setTimeout(() => {
            const shouldBeIdle = !isProcessing && !nebulaProcess.isActive && stagedFiles.length === 0 && analysisProgressArea.childElementCount === 0;
            if (shouldBeIdle) setStatus("Idle");
        }, 4000);
    }
    
    // FIX: Only switch mode if the process was actually active and is now finishing.
    if (wasActive && currentMode === 'nebula') {
        modeSelector.value = 'stellar';
        handleModeChange();
    }
}

        async function startNebulaProcess(userQuery) { 
            console.log('startNebulaProcess: Function started. Received pendingFiles:', pendingFiles);
            clearTimeout(nebulaAutoContinueTimerId); nebulaAutoContinueTimerId = null; isProcessing = true; nebulaProcess.isActive = true; sendBtn.disabled = true; nebulaProcess.userQuery = userQuery; nebulaProcess.processId = Date.now(); nebulaProcess.messageElement = createNebulaMessageContainer(nebulaProcess.processId); if (!nebulaProcess.messageElement) { cleanupNebulaProcess(true, "Failed container"); return; } nebulaProcess.currentStep = 1; disableAllNebulaStepActions(); requestNebulaStep(1); }
        function parsePlanAndSetupKeys(planMarkdown) {
    const keysSectionRegex = /\*\*1\.\s+Required\s+API\s+Keys(?:.|\n)*?(\`[A-Z_]+\`|None)/g;
    const keyNameRegex = /`([A-Z_]+)`/g;
    nebulaProcess.pendingFiles = pendingFiles;
    
    const keysMatch = planMarkdown.match(keysSectionRegex);
    nebulaProcessState.requiredKeys = [];
    
    if (keysMatch && !keysMatch.includes('None')) {
        let keyNameMatch;
        while ((keyNameMatch = keyNameRegex.exec(keysMatch)) !== null) {
            nebulaProcessState.requiredKeys.push(keyNameMatch);
        }
    }
    
    const summaryDiv = nebulaProcess.messageElement.querySelector('.nebula-final-summary');
    summaryDiv.innerHTML = ''; 
    
    if (nebulaProcessState.requiredKeys.length > 0) {
        const keyForm = document.createElement('div');
        keyForm.id = 'nebula-keys-form';
        keyForm.style.marginTop = '20px';
        keyForm.innerHTML = '<h4>API Keys Required</h4>';
        
        nebulaProcessState.requiredKeys.forEach(key => {
            keyForm.innerHTML += `
                <div style="margin-top: 10px;">
                    <label for="key-${key}" style="display: block; margin-bottom: 5px;">${key}</label>
                    <input type="password" id="key-${key}" name="${key}" style="width: 100%; padding: 8px; background: rgba(0,0,0,0.2); border: 1px solid var(--code-border); color: white; border-radius: 4px;">
                </div>
            `;
        });
        summaryDiv.appendChild(keyForm);
    }
}
async function requestNebulaStep(stepNumber, isRegeneration = false, regenerationFeedback = null) {
    if (!nebulaProcess.isActive) return;

    const stepTitle = getNebulaStepTitle(stepNumber);
    setStatus(`Nebula: ${isRegeneration ? 'Regenerating' : 'Processing'} ${stepTitle}...`);
    disableAllNebulaStepActions();
    isProcessing = true;
    sendBtn.disabled = true;

    const payload = {
        processId: nebulaProcess.processId,
        step: stepNumber,
        model_id: modelSelect.value,
        regenerate: isRegeneration,
        context: {
            query: nebulaProcess.userQuery,
            chat_id: currentChatId,
            step1: nebulaProcess.planOutput,
            step2: nebulaProcess.frontendOutput,
            step3: nebulaProcess.backendOutput,
            regeneration_feedback: regenerationFeedback,
            // This line correctly sends the file list during step 1
            pending_files: stepNumber === 1 ? nebulaProcess.pendingFiles : []
        }
    };

    try {
        const response = await fetch("/nebula/step", {
            method: "POST",
            headers: { "Content-Type": "application/json", 'Accept': 'application/json' },
            body: JSON.stringify(payload)
        });
        const data = await response.json();
        
        if (!response.ok || data.error) {
            throw new Error(data.error || `HTTP error! status: ${response.status}`);
        }

        const output = data.output || `(No output received for Step ${stepNumber})`;

        switch (stepNumber) {
            case 1: nebulaProcess.planOutput = output; break;
            case 2: nebulaProcess.frontendOutput = output; break;
            case 3: nebulaProcess.backendOutput = output; break;
            case 4: nebulaProcess.verificationOutput = output; break;
        }

        displayNebulaStepOutput(stepNumber, output);
        isProcessing = false;

        if (data.status === 'nebula_complete') {
            handleNebulaCompletion(data);
        } else if (stepNumber < 4) {
            nebulaProcess.currentStep = stepNumber;
            setStatus(`Nebula: Confirm ${getNebulaStepTitle(stepNumber)}...`);
            sendBtn.disabled = true;
            updateNebulaButtonStates();
        }

    } catch (err) {
        cleanupNebulaProcess(true, `Error in ${stepTitle}: ${err.message}`);
    }
}function updateNebulaButtonStates() {
    clearTimeout(nebulaAutoContinueTimerId);
    nebulaAutoContinueTimerId = null;

    if (!nebulaProcess.messageElement || !nebulaProcess.isActive) {
        disableAllNebulaStepActions();
        return;
    }

    const stepsContainer = nebulaProcess.messageElement.querySelector('.nebula-steps-container');
    if (!stepsContainer) return;

    let canAutoContinue = false;

    for (let i = 1; i <= 3; i++) {
        const actionsDiv = stepsContainer.querySelector(`.nebula-step-actions[data-step="${i}"]`);
        const stepOutputDiv = stepsContainer.querySelector(`.nebula-step-content[data-step="${i}"]`);
        if (!actionsDiv || !stepOutputDiv) continue;

        const confirmBtn = actionsDiv.querySelector('.nebula-confirm-btn');
        const regenerateBtn = actionsDiv.querySelector('.nebula-regenerate-btn');
        const stopAutoBtn = actionsDiv.querySelector('.nebula-stop-auto-btn');
        if (!confirmBtn || !regenerateBtn || !stopAutoBtn) continue;

        let stepOutputExists = false;
        switch (i) {
            case 1: stepOutputExists = !!nebulaProcess.planOutput; break;
            case 2: stepOutputExists = !!nebulaProcess.frontendOutput; break;
            case 3: stepOutputExists = !!nebulaProcess.backendOutput; break;
        }

        regenerateBtn.disabled = !(stepOutputExists && nebulaProcess.isActive && !isProcessing);

        const canConfirm = (i === nebulaProcess.currentStep) && stepOutputExists && nebulaProcess.isActive && !isProcessing;
        const apiKeyFormExists = !!stepOutputDiv.querySelector('.nebula-api-keys-form');
        
        confirmBtn.disabled = !canConfirm || apiKeyFormExists;

        if (canConfirm && !apiKeyFormExists) {
            canAutoContinue = true;
        }
        
        stopAutoBtn.style.display = 'none';
        stopAutoBtn.disabled = true;
    }

    const currentStepActionsDiv = stepsContainer.querySelector(`.nebula-step-actions[data-step="${nebulaProcess.currentStep}"]`);

    if (canAutoContinue && currentStepActionsDiv) {
        const stopAutoBtnForCurrentStep = currentStepActionsDiv.querySelector('.nebula-stop-auto-btn');
        nebulaAutoContinueTimerId = setTimeout(() => {
            if (nebulaProcess.isActive && !isProcessing) {
                handleNebulaConfirm(nebulaProcess.currentStep);
            }
        }, NEBULA_AUTO_CONTINUE_TIMEOUT);

        if (stopAutoBtnForCurrentStep) {
            stopAutoBtnForCurrentStep.style.display = 'inline-block';
            stopAutoBtnForCurrentStep.disabled = false;
        }
    }
}



function handleNebulaCompletion(data) {
    if (!nebulaProcess.isActive || !nebulaProcess.messageElement) return;

    const summaryDiv = nebulaProcess.messageElement.querySelector('.nebula-final-summary');
    const statusSpan = nebulaProcess.messageElement.querySelector('.nebula-status');
    if (statusSpan) statusSpan.textContent = `(Completed)`;
    if (summaryDiv) summaryDiv.innerHTML = '';

    const finalVerificationOutput = data.output || nebulaProcess.verificationOutput || "(Verification report not available)";
    displayNebulaStepOutput(4, finalVerificationOutput);

    if (summaryDiv && data.report_url) {
        const reportLink = document.createElement('a');
        reportLink.href = data.report_url;
        reportLink.textContent = "Download Full Report (MD)";
        reportLink.className = "nebula-download-btn";
        reportLink.style.display = "inline-block";
        reportLink.style.marginTop = "15px";
        summaryDiv.appendChild(reportLink);
    }
    
    scrollToBottom();
    
    // FIX: This is the most critical part. Update the message element's ID
    // from the temporary one to the permanent one from the database.
    const finalProcessId = data.message_id;
    if (finalProcessId && nebulaProcess.messageElement) {
        nebulaProcess.messageElement.dataset.id = `nebula-output-${finalProcessId}`;
    }

    // FIX: Call the correct cleanup function without an error flag.
    cleanupStream(false, null, null);
    setStatus("Nebula: Complete.", false);
    
    // FIX: Enable regenerate buttons but keep confirm buttons disabled.
    enableRegenButtonsForCompletedNebula(nebulaProcess.messageElement);

    // FIX: Reset the state *after* all UI updates are complete.
    resetNebulaProcessState();
}

async function saveNebulaKeysAndContinue(continueToNextStep = true, processIdOverride = null) {
    const currentProcessId = processIdOverride || nebulaProcess.processId;
    if (!currentProcessId) return;

    const messageElement = document.querySelector(`.nebula-output[data-id="nebula-output-${currentProcessId}"]`);
    if (!messageElement) return;

    const formContainer = messageElement.querySelector('.nebula-api-keys-form');
    if (!formContainer) {
        if (continueToNextStep) handleNebulaConfirm(1);
        return;
    }

    const inputs = formContainer.querySelectorAll('input[type="password"]');
    const apiKeys = {};
    let allKeysProvided = true;

    inputs.forEach(input => {
        const keyName = input.name;
        const keyValue = input.value.trim();
        if (!keyValue) allKeysProvided = false;
        apiKeys[keyName] = keyValue;
    });

    if (!allKeysProvided) {
        setStatus("Please provide all required API keys.", true);
        inputs.forEach(input => {
            if (!input.value.trim()) input.style.borderColor = 'var(--nebula-regenerate-start)';
        });
        setTimeout(() => setStatus(currentStatusText, false), 3000);
        return;
    }

    setStatus("Saving API keys...");
    try {
        const response = await fetch('/api/user/api_keys', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ api_keys: apiKeys })
        });
        const data = await response.json();
        if (!response.ok || !data.success) throw new Error(data.error || 'Failed to save keys.');

        setStatus("API Keys saved successfully.", false);
        formContainer.style.border = '1px solid var(--nebula-confirm-start)';
        
        if (continueToNextStep) {
            handleNebulaConfirm(1);
        } else {
            const updateBtn = formContainer.querySelector('.update-keys-btn');
            if (updateBtn) updateBtn.style.display = 'none';
        }

    } catch (err) {
        setStatus(`Error saving keys: ${err.message}`, true);
        setTimeout(() => setStatus(currentStatusText, false), 4000);
    }
}

function downloadHtml(contentToDownload, currentWidth = 900) { if (!contentToDownload) { setStatus("No content.", true); setTimeout(() => setStatus(currentStatusText), 2000); return; } setStatus("Preparing download..."); const styles = ` body { font-family: 'Poppins', sans-serif; line-height: 1.7; color: #333; background-color: #f0f2f5; margin: 0; padding: 20px; } .main-content-wrapper { background-color: #fdfdff; border: 1px solid #eee; padding: 30px; margin: 0 auto; max-width: ${currentWidth}px; } h1, h2, h3, h4, h5, h6 { color: #302b63; margin-top: 1.5em; margin-bottom: 0.5em; } h1 { font-size: 2em; border-bottom: 1px solid #ddd; padding-bottom: 0.3em;} h2 { font-size: 1.6em; } h3 { font-size: 1.3em; } p { margin: 1em 0; } a { color: #7b61ff; text-decoration: none; } a:hover { text-decoration: underline; } pre { background-color: #f0f0f0; padding: 15px; border-radius: 4px; overflow-x: auto; border: 1px solid #ddd; color: #333; white-space: pre-wrap; word-wrap: break-word; font-family: monospace; line-height: 1.6; } code { font-family: monospace; background-color: #eee; padding: 0.2em 0.4em; border-radius: 3px; } pre > code { background-color: transparent; padding: 0; border: none; } .table-wrapper { overflow-x: auto; max-width: 100%; margin: 1em 0; border: 1px solid #ccc; border-radius: 4px; } table { border-collapse: collapse; width: 100%; margin: 0; border: none; } th, td { border: 1px solid #ccc; padding: 8px 12px; text-align: left; word-break: break-word; border-width: 0 0 1px 0; } tr td:first-child, tr th:first-child { border-left: none; } tr td:last-child, tr th:last-child { border-right: none; } tr:last-child td { border-bottom: none; } th { background-color: #f2f2f2; font-weight: 600; } ul, ol { margin-left: 2em; margin-bottom: 1em; } blockquote { border-left: 4px solid #ccc; padding-left: 1em; margin-left: 0; color: #666; } .katex { font-size: 1.1em; } .katex-display { display: block; text-align: center; margin: 1em 0; } .katex-display > .katex { display: inline-block; text-align: initial; } .dl-header, .dl-footer { padding: 10px 30px; max-width: ${currentWidth}px; margin: 20px auto; font-size: 0.9em; color: #555; text-align: center; } .dl-header { border-bottom: 1px dashed #ccc; } .dl-footer { border-top: 1px dashed #ccc; margin-top: 30px; } `; const filenameBase = (lastRefinedQuery || "stellar_research").substring(0, 50).replace(/[^a-z0-9_\-\.]/gi, '_').toLowerCase(); const html = `<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <title>Stellar Research: ${filenameBase}</title> <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" crossorigin="anonymous"> <style>${styles}</style> </head> <body> <div class="dl-header"> <h1>Stellar Research Paper</h1> <p>Generated: ${new Date().toLocaleString()}</p> ${lastRefinedQuery ? `<p>Query: "${escapeHtml(lastRefinedQuery)}"</p>` : ''} </div> <div class="main-content-wrapper"> ${contentToDownload} </div> <div class="dl-footer"> <p>Stellar AI.</p> </div> </body> </html>`; try { const blob = new Blob([html], { type: "text/html;charset=utf-8" }); const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = `${filenameBase}.html`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); setStatus(currentStatusText); } catch (e) { setStatus("Download failed.", true); appendStellarMessage("DL err.", Date.now() + '_dl_err'); setTimeout(() => setStatus(currentStatusText), 3000); } }

       
function handleFileUpload(filesOrEvent) {
    
    const files = filesOrEvent.target ? (filesOrEvent.target.files || filesOrEvent.dataTransfer?.files) : filesOrEvent;

    if (!files || !files.length) return;

    const newFilesArray = Array.from(files); 
    let addedCount = 0;
    newFilesArray.forEach(file => {
        if (!stagedFiles.some(sf => sf.name === file.name && sf.size === file.size)) {
            stagedFiles.push(file);
            addedCount++;
        } else {
           
        }
    });

    if (addedCount > 0) {
        updateStagedFilesUI();
        flashVisualFeedback(); 
    }

   
    if (filesOrEvent.target && filesOrEvent.target.type === 'file' && filesOrEvent.target.id === 'fileUpload') {
        filesOrEvent.target.value = null;
    }
    updateStatusBarPosition();
}

        function handlePasteEvent(event) {
            const files = event.clipboardData?.files;
            if (files && files.length > 0) {
                const targetElement = event.target;
                const isModalInput = targetElement.closest('#editModalBackdrop, #regenerateModalBackdrop');
                const isChatInputArea = targetElement === chatInput;
                const isChatContainerArea = targetElement === chatContainer || targetElement === messagesDiv || document.body === targetElement;

                if (!isModalInput && !isChatInputArea && isChatContainerArea) {
                     event.preventDefault();
                     handleFileUpload({ dataTransfer: { files: files } });
                }
            }
         }

        function updateStagedFilesUI() {
            const container = document.getElementById('stagedFilesContainer');
            if (!container) return;

            if (stagedFiles.length === 0) {
                container.innerHTML = '';
                container.style.display = 'none';
                updateStatusBarPosition();
                return;
            }

            container.style.display = 'block';
            container.innerHTML = '<small>Files to send:</small>';
            const list = document.createElement('ul');
            list.style.listStyle = 'none';
            list.style.paddingLeft = '0';
            list.style.marginTop = '3px';

            stagedFiles.forEach((file, index) => {
                const listItem = document.createElement('li');
                listItem.style.display = 'flex';
                listItem.style.justifyContent = 'space-between';
                listItem.style.alignItems = 'center';
                listItem.style.marginBottom = '3px';
                listItem.style.padding = '2px 5px';
                listItem.style.backgroundColor = 'rgba(0,0,0,0.1)';
                listItem.style.borderRadius = '3px';

                const fileName = document.createElement('span');
                fileName.textContent = file.name;
                fileName.style.whiteSpace = 'nowrap';
                fileName.style.overflow = 'hidden';
                fileName.style.textOverflow = 'ellipsis';
                fileName.style.marginRight = '10px';
                fileName.title = `${file.name} (${(file.size / 1024).toFixed(1)} KB)`;

                const removeBtn = document.createElement('button');
                removeBtn.textContent = '✖';
                removeBtn.style.background = 'none';
                removeBtn.style.border = 'none';
                removeBtn.style.color = 'var(--secondary-text-color)';
                removeBtn.style.cursor = 'pointer';
                removeBtn.style.fontSize = '0.9em';
                removeBtn.style.padding = '0 5px';
                removeBtn.title = 'Remove file';
                removeBtn.onclick = (e) => {
                    e.stopPropagation();
                    removeStagedFile(index);
                };
                 removeBtn.onmouseover = () => { removeBtn.style.color = 'var(--nebula-regenerate-start)'; };
                 removeBtn.onmouseout = () => { removeBtn.style.color = 'var(--secondary-text-color)'; };


                listItem.appendChild(fileName);
                listItem.appendChild(removeBtn);
                list.appendChild(listItem);
            });
            container.appendChild(list);
            container.scrollTop = container.scrollHeight;
            updateStatusBarPosition();
        }

        function removeStagedFile(index) {
            if (index >= 0 && index < stagedFiles.length) {
                stagedFiles.splice(index, 1);
                updateStagedFilesUI();
            }
        }

        function displayUploadError(filename, errorMsg) {
            if (!analysisProgressArea) return;
            analysisProgressArea.style.display = 'flex';
            let id = 'progress-' + filename.replace(/[^a-zA-Z0-9-_]/g, '');
            let div = document.getElementById(id);
            if (!div) {
                div = document.createElement('div');
                div.id = id;
                div.className = 'file-progress-item status-error';
                div.innerHTML = `<div class="summary">📄 <strong>${filename}</strong>: <span class="status">Upload Failed</span></div><div class="details" style="display: block; padding-left: 15px;"><strong style="color: var(--nebula-regenerate-start);">${new Date().toLocaleTimeString()}: ${errorMsg}</strong><br></div>`;
                analysisProgressArea.appendChild(div);
            } else {
                const s = div.querySelector('.summary .status');
                const d = div.querySelector('.details');
                if (s) s.textContent = 'Upload Failed';
                if (d) {
                    d.innerHTML += `<strong style="color: var(--nebula-regenerate-start);">${new Date().toLocaleTimeString()}: ${errorMsg}</strong><br>`;
                    d.style.display = 'block';
                }
                div.classList.add('status-error');
            }
            updateStatusBarPosition();
            setTimeout(() => {
                if(div?.parentNode === analysisProgressArea){
                    div.style.transition = 'opacity 0.5s ease';
                    div.style.opacity = '0';
                    setTimeout(() => {
                        if(div.parentNode === analysisProgressArea) {
                            analysisProgressArea.removeChild(div);
                            if (analysisProgressArea.childElementCount === 0) {
                                analysisProgressArea.style.display = 'none';
                            }
                        }
                        updateStatusBarPosition();
                    }, 500);
                }
            }, 7000);
        }
        function initializeSSE() {
            if (sseEventSource && sseEventSource.readyState !== EventSource.CLOSED) {
                return;
            }
            sseEventSource = new EventSource('/analysis_progress');
            sseEventSource.onopen = () => {
                const errorDiv = document.getElementById('sse-conn-error-msg');
                if (errorDiv) errorDiv.remove();
            };
            sseEventSource.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);

                    if (!data.filename && !['sse_connected', 'sse_error'].includes(data.type)) return;

                    let id = data.filename ? 'progress-' + data.filename.replace(/[^a-zA-Z0-9-_]/g, '') : null;
                    let div = id ? document.getElementById(id) : null;

                    if (!div && id && data.type !== 'analysis_thread_end') {
                        div = document.createElement('div');
                        div.id = id;
                        div.className = 'file-progress-item';
                        div.innerHTML = `<div class="summary">📄 <strong>${data.filename}</strong>: <span class="status">...</span></div><div class="details"><small>Details:</small><br></div>`;
                        div.querySelector('.summary').onclick = () => {
                            const detailsDiv = div.querySelector('.details');
                            if(detailsDiv) detailsDiv.style.display = detailsDiv.style.display === 'none' ? 'block' : 'none';
                        };
                        if(analysisProgressArea) {
                            analysisProgressArea.appendChild(div);
                            analysisProgressArea.style.display = 'flex';
                        }
                        updateStatusBarPosition();
                    }

                    if (div) {
                        const statusSpan = div.querySelector('.summary .status');
                        const detailsDiv = div.querySelector('.details');
                        let isDone = false;

                        if (!statusSpan || !detailsDiv) return;

                        switch (data.type) {
                            case 'file_start':
                                statusSpan.textContent = 'Starting analysis...';
                                detailsDiv.innerHTML += `<small>${new Date().toLocaleTimeString()}: Analysis started.</small><br>`;
                                break;
                            case 'progress':
                                const progressMsg = data.message || `Processing chunk ${data.chunk_num}/${data.total_chunks}...`;
                                statusSpan.textContent = progressMsg;
                                detailsDiv.innerHTML += `<small>${new Date().toLocaleTimeString()}: ${progressMsg}</small><br>`;
                                break;
                             case 'file_chunk_info':
                                statusSpan.textContent = `Split into ${data.total_chunks} chunks.`;
                                detailsDiv.innerHTML += `<small>${new Date().toLocaleTimeString()}: Split into ${data.total_chunks} chunks.</small><br>`;
                                break;
                            case 'chunk_result':
                                statusSpan.textContent = `Analyzed chunk ${data.chunk_num}/${data.total_chunks}...`;
                                detailsDiv.innerHTML += `<small>${new Date().toLocaleTimeString()}: Chunk ${data.chunk_num} result received.</small><br>`;
                                break;
                            case 'file_complete':
                                statusSpan.textContent = `Analysis Complete (${data.status})`;
                                detailsDiv.innerHTML += `<strong>${new Date().toLocaleTimeString()}: Analysis finished - ${data.status}</strong><br>`;
                                div.classList.add(data.status.toLowerCase().includes('success') ? 'status-success' : 'status-finished');
                                isDone = true;
                                break;
                            case 'chunk_error':
                            case 'file_error':
                                statusSpan.textContent = `Analysis Error`;
                                detailsDiv.innerHTML += `<strong style="color: var(--nebula-regenerate-start);">${new Date().toLocaleTimeString()}: Error - ${data.error}</strong><br>`;
                                div.classList.add('status-error');
                                isDone = true;
                                break;
                            case 'analysis_thread_end':
                                if (!div.classList.contains('status-success') && !div.classList.contains('status-finished') && !div.classList.contains('status-error')) {
                                    statusSpan.textContent = `Analysis Thread Ended`;
                                    detailsDiv.innerHTML += `<small>Analysis thread ended.</small><br>`;
                                    div.classList.add('status-ended');
                                }
                                isDone = true;
                                break;
                            case 'sse_connected':
                                break;
                            case 'sse_error':
                                break;
                            default:
                                break;
                        }

                        if(detailsDiv.style.display !== 'none') detailsDiv.scrollTop = detailsDiv.scrollHeight;

                        if(isDone && analysisProgressArea){
                            const delay = div.classList.contains('status-error') ? 7000 : 5000;
                            setTimeout(() => {
                                if(div?.parentNode === analysisProgressArea){
                                    div.style.transition = 'opacity 0.5s ease';
                                    div.style.opacity = '0';
                                    setTimeout(() => {
                                        if(div.parentNode === analysisProgressArea) {
                                            analysisProgressArea.removeChild(div);
                                            if (analysisProgressArea.childElementCount === 0) {
                                                analysisProgressArea.style.display = 'none';
                                            }
                                        }
                                        updateStatusBarPosition();
                                    }, 500);
                                }
                            }, delay);
                        }
                    }
                } catch (e) {
                }
                updateStatusBarPosition();
            };
            sseEventSource.onerror = (err) => {
                if (analysisProgressArea && !document.getElementById('sse-conn-error-msg')) {
                    const errorDiv = document.createElement('div');
                    errorDiv.id = 'sse-conn-error-msg';
                    errorDiv.innerHTML = '<p style="color:red; font-size:0.8em; text-align:center;">Analysis progress connection lost. Attempting to reconnect...</p>';
                    analysisProgressArea.appendChild(errorDiv);
                    analysisProgressArea.style.display = 'flex';
                    updateStatusBarPosition();
                }
                setStatus("Analysis progress connection error", true);
                if(sseEventSource) sseEventSource.close();
                sseEventSource = null;
                setTimeout(() => {
                    const errorDiv = document.getElementById('sse-conn-error-msg');
                    if (errorDiv) errorDiv.remove();
                    initializeSSE();
                }, 10000);
            };
        }
async function handleSend() {
    const lastEditIcon = document.querySelector('.user-msg:last-of-type .edit-prompt-wrapper');
    if (lastEditIcon) {
        lastEditIcon.remove();
    }

    if (currentMode !== 'nebula' && isProcessing) { setStatus("Wait...", true); setTimeout(() => setStatus(currentStatusText, false), 2000); return; }
    if (currentMode === 'nebula' && nebulaProcess.isActive) { let reason = isProcessing ? `Wait Step ${nebulaProcess.currentStep}.` : (nebulaProcess.currentStep <= 3 ? `Confirm/Regen Step ${nebulaProcess.currentStep}.` : "Nebula done."); setStatus(`Cannot start: ${reason}`, true); setTimeout(() => setStatus(currentStatusText, false), 3000); return; }
    clearTimeout(nebulaAutoContinueTimerId); nebulaAutoContinueTimerId = null;

    if (chatContainer.style.display === 'none') {
        setStatus("Please log in to send messages.", true);
        setTimeout(() => setStatus(currentStatusText, false), 3000);
        return;
    }

    const query = chatInput.value.trim();
    if (!query && stagedFiles.length === 0) return;

    const selectedModel = modelSelect.value;
    isProcessing = true;
    sendBtn.disabled = true;
    toggleSendStopButtons(true);
    setStatus("Processing...");

    const userMsgId = Date.now() + '_user';
    if (query) {
        appendUserMessage(query, userMsgId);
    }
    updateTokenCount();
    const originalQuery = query;
    chatInput.value = "";
    adjustTextareaHeight();

    let serverFileIds = [];
    let hasFilesToSend = stagedFiles.length > 0;

    if (hasFilesToSend) {
        setStatus("Uploading files...");
        try {
            const formData = new FormData();
            stagedFiles.forEach(file => {
                formData.append('file', file);
            });

            const uploadResponse = await fetch('/upload_files', { method: 'POST', body: formData });
            if (!uploadResponse.ok) {
                const errData = await uploadResponse.json().catch(() => ({ error: `Upload HTTP ${uploadResponse.status}` }));
                throw new Error(errData.error || `Upload HTTP ${uploadResponse.status}`);
            }
            const uploadData = await uploadResponse.json();

            if (uploadData.uploaded_files && uploadData.uploaded_files.length > 0) {
                serverFileIds = uploadData.uploaded_files;
            }
            if (uploadData.files_failed?.length || uploadData.files_disallowed?.length) {
                analysisProgressArea.style.display = 'flex';
                uploadData.files_failed?.forEach(f => displayUploadError(f, "Save failed during send."));
                uploadData.files_disallowed?.forEach(f => displayUploadError(f, "Type not allowed during send."));
                 setStatus("Query sent (some files failed upload).", true);
                 setTimeout(() => setStatus(currentStatusText, false), 3500);
             }

            stagedFiles = [];
            updateStagedFilesUI();

        } catch (uploadError) {
            setStatus(`File Upload Failed: ${uploadError.message}`, true);
            isProcessing = false;
            sendBtn.disabled = false;
            toggleSendStopButtons(false);
            stagedFiles = [];
            updateStagedFilesUI();
            setTimeout(() => setStatus(currentStatusText, false), 4000);
            return;
        }
    }

    if (currentMode === 'nebula') {
        if (!originalQuery) { setStatus("Nebula needs a description.", true); isProcessing = false; sendBtn.disabled = false; toggleSendStopButtons(false); setTimeout(() => setStatus(currentStatusText, false), 3000); return; }
        // --- THIS IS THE FIX ---
        // Pass the serverFileIds array as the second argument.
        startNebulaProcess(originalQuery, serverFileIds);
        return;
    }
    
    // ... rest of the function for other modes ...
    let placeholderId = `placeholder-${Date.now()}`;
    let placeholderText = query ? "Processing query..." : "Processing files...";
    if (serverFileIds.length > 0) {
        placeholderText = query ? `Analyzing ${serverFileIds.length} files + query...` : `Analyzing ${serverFileIds.length} files...`;
        if (!sseEventSource || sseEventSource.readyState === EventSource.CLOSED) {
            initializeSSE();
        }
    }

     let endpoint = '/register_query'; let streamUrl = '/refine_stream'; let modeForBackend = 'refine';
     let isResearchOutputExpected = false;

     switch (currentMode) {
         case 'spectrum':
             modeForBackend = useSpectrumSearch ? 'search_tavily' : 'search_no_tavily';
             streamUrl = '/search_stream';
             isResearchOutputExpected = true;
             break;
         case 'cosmos':
             modeForBackend = 'cosmos'; streamUrl = '/cosmos_stream';
             break;
     }

     try {
         const placeholderMsg = document.createElement("div");
         placeholderMsg.classList.add("message", "stellar-msg", "placeholder-message");
         if (isResearchOutputExpected) {
             placeholderMsg.classList.add("research-output");
         }
         placeholderMsg.dataset.id = placeholderId;
         const contentDiv = document.createElement("div"); contentDiv.classList.add("message-content");
         const statusSpan = document.createElement("span"); statusSpan.className = "placeholder-status"; if (serverFileIds.length > 0) statusSpan.classList.add("clickable", "analysis-placeholder"); statusSpan.textContent = placeholderText; contentDiv.appendChild(statusSpan);
         if (serverFileIds.length > 0) { const detailsDiv = document.createElement("div"); detailsDiv.className = "analysis-content"; detailsDiv.style.display = "none"; detailsDiv.innerHTML = "<small><i>Waiting for analysis details...</i></small>"; contentDiv.appendChild(detailsDiv); }
         placeholderMsg.appendChild(contentDiv);
         if (messagesDiv) messagesDiv.appendChild(placeholderMsg);
         scrollToBottom();

         const registerPayload = { query: originalQuery || " ", model_id: selectedModel, mode: modeForBackend, pending_files: serverFileIds, chat_id: currentChatId };
         const response = await fetch(endpoint, { method: "POST", headers: { "Content-Type": "application/json", "Accept": "application/json" }, body: JSON.stringify(registerPayload) });
         if (!response.ok) { const errData = await response.json().catch(() => ({})); throw new Error(errData.error || `Register fail HTTP ${response.status}`); }
         const data = await response.json(); if (!data.query_id) { throw new Error("No query_id received from registration."); }
         const query_id = data.query_id;
         initAndStartStreaming(
            originalQuery,
            selectedModel,
            modeForBackend,
            serverFileIds,
            currentChatId,
            placeholderId,
            userMsgId,
            isResearchOutputExpected
        );
     } catch (err) {
         const errorMsg = `Error: ${err.message}`;
         updateStellarMessagePlaceholder(placeholderId, errorMsg, true);
         setStatus(`Error: ${err.message}`, true);
         isProcessing = false; sendBtn.disabled = false; toggleSendStopButtons(false); setTimeout(() => setStatus(currentStatusText, false), 4000);
     }
}

 function appendStellarMessage(markdownText, id) {
    const msg = document.createElement("div");
    msg.classList.add("message", "stellar-msg");
    msg.dataset.id = id;
    const contentDiv = document.createElement("div");
    contentDiv.classList.add("message-content");
    try {
        let htmlContent = marked.parse(markdownText || "");
        htmlContent = wrapTables(htmlContent);
        contentDiv.innerHTML = htmlContent;
        msg.appendChild(contentDiv);
        processCodeBlocks(contentDiv);
        renderMath(contentDiv);
        addOutputCopyButton(msg);
        setTimeout(scrollToBottom, 50);
    } catch (e) {
        contentDiv.textContent = "Error rendering message content.";
        scrollToBottom();
    }
    if (messagesDiv) messagesDiv.appendChild(msg);
    updateTokenCount();
}
async function startNebulaProcess(userQuery, pendingFiles = []) {
    // This console log is for debugging; you can remove it after confirming the fix.
    console.log('startNebulaProcess: Function started. Received pendingFiles:', pendingFiles);

    clearTimeout(nebulaAutoContinueTimerId);
    nebulaAutoContinueTimerId = null;
    isProcessing = true;
    nebulaProcess.isActive = true;
    sendBtn.disabled = true;
    nebulaProcess.userQuery = userQuery;
    nebulaProcess.processId = Date.now();
    nebulaProcess.messageElement = createNebulaMessageContainer(nebulaProcess.processId);
    
    // This is where the file list is correctly stored in the process state
    nebulaProcess.pendingFiles = pendingFiles;

    if (!nebulaProcess.messageElement) {
        cleanupNebulaProcess(true, "Failed to create message container.");
        return;
    }
    nebulaProcess.currentStep = 1;
    disableAllNebulaStepActions();
    requestNebulaStep(1);
}
        function appendStellarMessagePlaceholder(id, initialText, hasFiles) { }
        function updateStellarMessagePlaceholder(id, newText, isError = false, analysisDetails = null) {
    const msgDiv = messagesDiv.querySelector(`.message[data-id="${id}"]`);
    if (!msgDiv) {
        if (isError) appendStellarMessage(`Error: ${newText}`, id + "_err");
        return;
    }
    const statusSpan = msgDiv.querySelector('.placeholder-status');
    const detailsDiv = msgDiv.querySelector('.analysis-content');

    if (statusSpan) {
        statusSpan.textContent = newText;
        if (isError) {
            
            msgDiv.classList.remove("placeholder-message");
            
            
            statusSpan.style.color = 'var(--nebula-regenerate-start, #ff6b6b)';
            statusSpan.classList.remove("clickable", "analysis-placeholder");
            statusSpan.onclick = null;
        } else {
            statusSpan.style.color = '';
            if (detailsDiv && !statusSpan.classList.contains("clickable")) {
                statusSpan.classList.add("clickable", "analysis-placeholder");
                if (!statusSpan.onclick) {
                    statusSpan.onclick = () => toggleAnalysisDetails(msgDiv);
                }
            }
        }
    }

    if (detailsDiv && analysisDetails) {
        let html = '';
        if (typeof analysisDetails === 'string') {
            html = `<pre>${escapeHtml(analysisDetails)}</pre>`;
        } else if (typeof analysisDetails === 'object' && analysisDetails !== null) {
            html += '<small>Results:</small><ul>';
            for (const [f, r] of Object.entries(analysisDetails)) {
                const s = r ? r.substring(0, 300) + (r.length > 300 ? '...' : '') : '(None)';
                html += `<li><strong>${escapeHtml(f)}:</strong><pre>${escapeHtml(s)}</pre></li>`;
            }
            html += '</ul>';
        } else {
            html = '<small><i>No details.</i></small>';
        }
        detailsDiv.innerHTML = html;
    }
}
        function finalizeStellarMessage(placeholderId, finalContent, messageDbId, analysisContextUsed = null) {
             const placeholderDiv = messagesDiv.querySelector(`.message[data-id="${placeholderId}"]`);
             if (!placeholderDiv) { if (analysisContextUsed) { appendStellarMessageWithAnalysis(finalContent, messageDbId, analysisContextUsed); } else { appendStellarMessage(finalContent, messageDbId); } return; }

             const isResearch = placeholderDiv.classList.contains('research-output');

             placeholderDiv.dataset.id = messageDbId; placeholderDiv.classList.remove("placeholder-message");
             let contentDiv = placeholderDiv.querySelector('.message-content'); if (!contentDiv) { contentDiv = document.createElement('div'); contentDiv.classList.add('message-content'); placeholderDiv.innerHTML = ''; placeholderDiv.appendChild(contentDiv); } else { contentDiv.innerHTML = ''; }

             try {
                 let htmlContent = marked.parse(finalContent || ""); htmlContent = wrapTables(htmlContent); contentDiv.innerHTML = htmlContent;
                 processCodeBlocks(contentDiv);
                 if (analysisContextUsed) { addAnalysisIndicator(placeholderDiv, analysisContextUsed); }

                  if (isResearch) {
                      createAndAppendResearchButtons(placeholderDiv, messageDbId, contentDiv.innerHTML);
                  }
                 addOutputCopyButton(placeholderDiv);

                 setTimeout(() => { renderMath(contentDiv); scrollToBottom(); }, 150);
             } catch (e) { contentDiv.textContent = "Error."; if (analysisContextUsed) { addAnalysisIndicator(placeholderDiv, analysisContextUsed); } if (isResearch) { createAndAppendResearchButtons(placeholderDiv, messageDbId, "<p>Error</p>"); } addOutputCopyButton(placeholderDiv); scrollToBottom(); }
 updateTokenCount();       }
        function addAnalysisIndicator(messageDiv, analysisContext) { if (!messageDiv || !analysisContext) return; const contentDiv = messageDiv.querySelector('.message-content'); if (!contentDiv) return; contentDiv.querySelectorAll('.analysis-indicator, .analysis-content').forEach(el => el.remove()); const ind = document.createElement("span"); ind.className = "analysis-indicator clickable"; ind.textContent = " Analyzed files"; ind.style.marginLeft = '10px'; const det = document.createElement("div"); det.className = "analysis-content"; det.style.display = "none"; det.style.marginTop = "10px"; det.style.paddingTop = "10px"; det.style.borderTop = "1px dashed var(--stellar-msg-border)"; det.innerHTML = `<small><i>Context:</i></small><div class="formatted-analysis-context">${formatAnalysisContextForDisplay(analysisContext)}</div>`; contentDiv.appendChild(ind); contentDiv.appendChild(det); }
        function formatAnalysisContextForDisplay(rawContext) { if (!rawContext || typeof rawContext !== 'string') return "<p>No context.</p>"; try { let html = ''; try { html = marked.parse(rawContext || ""); } catch (e) { return `<pre>Parse err: ${escapeHtml(e.message)}\n\n${escapeHtml(rawContext)}</pre>`; } const p = new DOMParser(); const d = p.parseFromString(`<div id="ctx-wrap">${html}</div>`, 'text/html'); const w = d.getElementById('ctx-wrap'); if (!w) return `<pre>${escapeHtml(rawContext)}</pre>`; w.querySelectorAll('details').forEach(det => { let s = det.querySelector('summary'); if (!s) { s = d.createElement('summary'); s.textContent = 'Details'; det.insertBefore(s, det.firstChild); } s.style.cursor = 'pointer'; s.style.fontWeight = 'bold'; s.style.color = 'var(--primary-text-color)'; s.style.padding = '8px'; s.style.display = 'block'; s.style.backgroundColor = 'rgba(255, 255, 255, 0.03)'; s.style.borderRadius = '4px 4px 0 0'; let cw = s.nextElementSibling; if (cw && (cw.tagName === 'DIV' || cw.tagName === 'PRE')) { cw.style.padding = '10px'; cw.style.borderTop = '1px dashed rgba(255, 255, 255, 0.1)'; cw.style.marginTop = '0'; cw.style.backgroundColor = 'rgba(0,0,0,0.1)'; } else { const nw = d.createElement('div'); nw.style.padding = '10px'; nw.style.borderTop = '1px dashed rgba(255, 255, 255, 0.1)'; nw.style.marginTop = '0'; nw.style.backgroundColor = 'rgba(0,0,0,0.1)'; while (s.nextSibling) { nw.appendChild(s.nextSibling); } det.appendChild(nw); } det.style.border = '1px solid rgba(255, 255, 255, 0.1)'; det.style.borderRadius = '4px'; det.style.marginBottom = '10px'; det.style.backgroundColor = 'rgba(0, 0, 0, 0.05)'; }); w.querySelectorAll(':scope > pre').forEach(pre => { if (pre.closest('details')) return; pre.style.marginTop = '10px'; pre.style.marginBottom = '10px'; pre.style.padding = '12px'; pre.style.fontSize = '0.9em'; pre.style.backgroundColor = 'rgba(0,0,0,0.25)'; pre.style.border = '1px solid rgba(255,255,255,0.15)'; pre.style.borderRadius = '4px'; pre.style.whiteSpace = 'pre-wrap'; pre.style.wordWrap = 'break-word'; }); let finalHtml = w.innerHTML; finalHtml = finalHtml.replace(/##\s*(.*?)\s*(<br\s*\/?>)?/g, '<h3>$1</h3>'); finalHtml = finalHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); finalHtml = finalHtml.replace(/__(.*?)__/g, '<strong>$1</strong>'); finalHtml = finalHtml.replace(/\*(.*?)\*/g, '<em>$1</em>'); finalHtml = finalHtml.replace(/_(.*?)_/g, '<em>$1</em>'); finalHtml = finalHtml.replace(/`([^`]+)`/g, '<code>$1</code>'); return finalHtml; } catch (e) { return `<pre>${escapeHtml(rawContext)}</pre>`; } }
        function appendStellarMessageWithAnalysis(markdownText, id, analysisContext) { const msg = document.createElement("div"); msg.classList.add("message", "stellar-msg"); msg.dataset.id = id; const contentDiv = document.createElement("div"); contentDiv.classList.add("message-content"); try { let htmlContent = marked.parse(markdownText || ""); htmlContent = wrapTables(htmlContent); contentDiv.innerHTML = htmlContent; processCodeBlocks(contentDiv); addAnalysisIndicator(msg, analysisContext); addOutputCopyButton(msg); setTimeout(() => { renderMath(contentDiv); const analysisEl = msg.querySelector('.analysis-content .formatted-analysis-context'); if(analysisEl) renderMath(analysisEl); scrollToBottom(); }, 150); } catch (e) { contentDiv.textContent = "Error."; addAnalysisIndicator(msg, analysisContext); addOutputCopyButton(msg); scrollToBottom(); } msg.appendChild(contentDiv); if (messagesDiv) messagesDiv.appendChild(msg); }
        
async function initAndStartStreaming(userQuery, modelId, modeForBackend, pendingFiles, chatId, placeholderId, userMessageId, isResearchOutputExpected) {
    if (currentStreamQueryId) {
        currentStreamQueryId = null;
    }

    const maxRetries = 3;
    let retryCount = 0;

    const attemptStreamConnection = async () => {
        try {
            const registerPayload = {
                query: userQuery || " ",
                model_id: modelId,
                mode: modeForBackend,
                pending_files: pendingFiles,
                chat_id: chatId
            };

            const registerResponse = await fetch('/register_query', {
                method: 'POST',
                headers: { "Content-Type": "application/json", "Accept": "application/json" },
                body: JSON.stringify(registerPayload)
            });

            if (!registerResponse.ok) {
                const errData = await registerResponse.json().catch(() => ({}));
                throw new Error(errData.error || `Register fail HTTP ${registerResponse.status}`);
            }
            const registerData = await registerResponse.json();
            if (!registerData.query_id) {
                throw new Error("No query_id received from registration.");
            }
            currentStreamQueryId = registerData.query_id;

            lastRefinedQuery = userQuery;

            let streamUrl = '/refine_stream';
            if (modeForBackend.startsWith('search')) {
                streamUrl = '/search_stream';
            } else if (modeForBackend === 'cosmos') {
                streamUrl = '/cosmos_stream';
            }

            const params = new URLSearchParams({ query_id: currentStreamQueryId, chat_id: chatId });
            if (modeForBackend.startsWith('search')) {
                params.append('useTavily', useSpectrumSearch.toString());
            }

            if (sseEventSource && sseEventSource.readyState !== EventSource.CLOSED) {
                sseEventSource.close();
            }
            sseEventSource = new EventSource(`${streamUrl}?${params.toString()}`);

            let fullResponseContent = "";
            let analysisContextReceived = null;
            let analysisResultsReceived = null;
            let streamEndedCleanly = false;

            sseEventSource.onmessage = async (event) => {
                if (!event.data || event.data.trim() === "") return;
                try {
                    const data = JSON.parse(event.data);

                    if (data.type === 'scraping_url' && data.url) {
                        scrapingQueue.push(data.url);
                        if (scrapingTimerId === null) {
                            processScrapingQueue();
                        }
                    }

                    if(data.status) {
                        currentStatusText = data.status;
                        const simpleStatus = currentStatusText.replace(/\s*\(Attempt \d+\/\d+\)/i, '');
                        setStatus(simpleStatus, !!data.error);
                    }

                    if (data.analysis_results) {
                        analysisResultsReceived = data.analysis_results;
                        updateStellarMessagePlaceholder(placeholderId, data.status || "Processing...", false, analysisResultsReceived);
                    } else if (data.status) {
                        updateStellarMessagePlaceholder(placeholderId, data.status || "Processing...", false);
                    }

                    if (data.error) {
                        const errMsg = data.error || data.status || "Unknown error";
                        cleanupStream(true, errMsg + (data.details ? ` Details: ${data.details}` : ''), placeholderId);
                        streamEndedCleanly = true;
                        return;
                    }

                    if (data.analysis_context_used) {
                        analysisContextReceived = data.analysis_context_used;
                    }

                    const finalContent = data.refined_query || data.result;
                    const isFinalMessage = (data.status === 'refined_ready' || data.status === 'display_result') && finalContent !== undefined;

                    if (isFinalMessage) {
                        streamEndedCleanly = true;
                        fullResponseContent = finalContent;
                        const messageDbId = data.message_id || placeholderId;
                        const userMessageDbId = data.user_message_id;

                        if (userMessageDbId) {
                            const lastUserMsg = document.querySelector(`.message.user-msg[data-id="${userMessageId}"]`);
                            if (lastUserMsg) {
                                console.log(`Updating user message ID from ${lastUserMsg.dataset.id} to ${userMessageDbId}`);
                                lastUserMsg.dataset.id = userMessageDbId;
                            }
                        }
                        
                        const placeholderDiv = messagesDiv.querySelector(`.message[data-id="${placeholderId}"]`);
                        if (placeholderDiv && isResearchOutputExpected && !placeholderDiv.classList.contains('research-output')) {
                            placeholderDiv.classList.add('research-output');
                        }

                        finalizeStellarMessage(placeholderId, fullResponseContent, messageDbId, analysisContextReceived);

                        if (data.status === 'display_result' && data.file_url) {
                            const finalMsgDiv = messagesDiv.querySelector(`.message[data-id="${messageDbId}"]`);
                            if (finalMsgDiv && finalMsgDiv.classList.contains('research-output')) {
                                const buttonsDiv = finalMsgDiv.querySelector('.message-buttons');
                                if (buttonsDiv) {
                                    let viewBtn = buttonsDiv.querySelector('.view-html-btn');
                                    if (!viewBtn) {
                                        viewBtn = document.createElement("a");
                                        viewBtn.classList.add("download-btn", "view-html-btn");
                                        viewBtn.target = "_blank";
                                        buttonsDiv.appendChild(viewBtn);
                                    }
                                    viewBtn.textContent = "View Paper";
                                    viewBtn.href = data.file_url;
                                }
                            }
                        }

                        cleanupStream(false, null, placeholderId);

                        const numMessagesInChat = Array.from(messagesDiv.children).filter(child => child.classList.contains('user-msg') || child.classList.contains('stellar-msg')).length;
                        if (currentChatId && (numMessagesInChat === 2 || (numMessagesInChat > 2 && (numMessagesInChat - 2) % 10 === 1))) {
                            const chatNameResponse = await fetch(`/api/chats/${currentChatId}/name`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ first_message_content: userQuery })
                            });
                            const chatNameData = await chatNameResponse.json();
                            if (chatNameData.success) {
                                updateChatNameInList(currentChatId, chatNameData.name);
                            }
                        }
                    }
                } catch (err) {
                    console.error("Error processing stream update:", err);
                    updateStellarMessagePlaceholder(placeholderId, "Error processing stream update.", true);
                    setStatus("Stream processing error", true);
                }
            };

            sseEventSource.onerror = (err) => {
                console.error("SSE Error:", err);
                if (!streamEndedCleanly && retryCount < maxRetries) {
                    retryCount++;
                    setTimeout(attemptStreamConnection, 2000 * retryCount);
                } else {
                    cleanupStream(true, "Stream connection failed after retries.", placeholderId);
                }
            };

            sseEventSource.onclose = () => {
                if (!streamEndedCleanly && sseEventSource.readyState === EventSource.CLOSED) {
                    cleanupStream(true, "Stream connection unexpectedly closed.", placeholderId);
                }
            };

        } catch (err) {
            console.error(`Error in attemptStreamConnection: ${err.message}`);
            if (retryCount < maxRetries) {
                retryCount++;
                setTimeout(attemptStreamConnection, 2000 * retryCount);
            } else {
                cleanupStream(true, `Failed to establish stream after retries: ${err.message}`, placeholderId);
            }
        }
    };

    attemptStreamConnection();
}
function cleanupStream(showErrorStatus = false, errorMsg = null, placeholderId) {
    toggleSendStopButtons(false);
    if (sseEventSource) {
        sseEventSource.close();
        sseEventSource = null;
    }
    hideLivePreview();
    clearTimeout(scrapingTimerId);
    scrapingTimerId = null;
    scrapingQueue = [];
    isProcessing = false;
    
   
    sendBtn.disabled = false;

    const finalStatus = showErrorStatus ? (errorMsg || "Stream Error") : "Idle";
    const shouldBeIdle = !isProcessing && !nebulaProcess.isActive && stagedFiles.length === 0 && analysisProgressArea?.childElementCount === 0;
    setStatus(showErrorStatus ? finalStatus : (shouldBeIdle ? "Idle" : currentStatusText), showErrorStatus);
    if (showErrorStatus) {
        updateStellarMessagePlaceholder(placeholderId, `Error: ${errorMsg || 'Failed'}`, true);
        setTimeout(() => {
            const shouldBeIdleAfterError = !isProcessing && !nebulaProcess.isActive && stagedFiles.length === 0 && analysisProgressArea?.childElementCount === 0;
            setStatus(shouldBeIdleAfterError ? "Idle" : currentStatusText, false);
        }, 4000);
    }
    
    const latestUserMessage = [...document.querySelectorAll('.user-msg')].pop();
    if (latestUserMessage) {
        const editIconWrapper = latestUserMessage.querySelector('.edit-prompt-wrapper');
        if (editIconWrapper) {
            editIconWrapper.style.display = 'flex';
        }
    }
}


function enableRegenButtonsForCompletedNebula(messageElement) {
    if (!messageElement) return;
    const allConfirmBtns = messageElement.querySelectorAll('.nebula-confirm-btn');
    const allRegenerateBtns = messageElement.querySelectorAll('.nebula-regenerate-btn');
    const allStopAutoBtns = messageElement.querySelectorAll('.nebula-stop-auto-btn');

    allConfirmBtns.forEach(btn => btn.disabled = true);
    allStopAutoBtns.forEach(btn => {
        btn.disabled = true;
        btn.style.display = 'none';
    });
    
    // Enable all regenerate buttons so the user can go back to any step.
    allRegenerateBtns.forEach(btn => {
        btn.disabled = false;
    });
} function toggleAnalysisDetails(messageElement) { if (!messageElement) return; const det = messageElement.querySelector('.analysis-content'); if (det) { const isHidden = det.style.display === 'none'; det.style.display = isHidden ? 'block' : 'none'; if (isHidden) { det.querySelectorAll('.formatted-analysis-context pre code').forEach(c => { if (!c.dataset.highlighted) { try { if (typeof hljs !== 'undefined') { hljs.highlightElement(c); c.dataset.highlighted = 'yes'; } } catch(e) {} } }); setTimeout(() => det.scrollIntoView({ behavior: 'smooth', block: 'nearest' }), 100); } } }

async function loadHistory(chatIdToLoad = null, targetMessageId = null, highlightTerm = null) {
    if (!messagesDiv) return;
    messagesDiv.innerHTML = "";
    historyLoaded = false;
    setStatus("Loading history...");

    try {
        let url = '/get_history';
        if (chatIdToLoad) {
            url += `?chat_id=${chatIdToLoad}`;
        }
        const response = await fetch(url, { credentials: 'include' });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();

        if (data.history && Array.isArray(data.history) && data.history.length > 0) {
            const ids = new Set();
            data.history.forEach(msg => {
                if (!msg?.id || ids.has(msg.id)) { return; }
                ids.add(msg.id);
                const content = msg.message_content || "";
                const msgId = msg.id;
                const messageType = msg.message_type || "stellar";
                const analysisContext = msg.file_analysis_context || null;

                try {
                    if (messageType === "user") {
                        appendUserMessage(content, msgId);
                    } else if (messageType === "nebula_output") {
                        const reportUrl = msg.report_url || null;
                        const processId = msgId.replace('nebula-output-', '') || Date.now();
                        const nebulaMsgElement = createNebulaMessageContainer(processId);
                        
                        let tempNebulaState = { messageElement: nebulaMsgElement, planOutput: null, frontendOutput: null, backendOutput: null, verificationOutput: null };
                        let stepOutputs = msg.nebula_output || {};
                        const sortedSteps = Object.keys(stepOutputs).map(s => parseInt(s.replace('step', ''))).filter(n => !isNaN(n)).sort((a, b) => a - b);
                        
                        sortedSteps.forEach(stepNum => {
                            const stepKey = `step${stepNum}`;
                            if (stepOutputs[stepKey]) {
                                let origProc = nebulaProcess;
                                nebulaProcess = tempNebulaState;
                                displayNebulaStepOutput(stepNum, stepOutputs[stepKey]);
                                nebulaProcess = origProc;
                            }
                        });
                        
                        enableRegenButtonsForCompletedNebula(nebulaMsgElement);

                        const statusSpan = nebulaMsgElement.querySelector('.nebula-status');
                        if (statusSpan) statusSpan.textContent = `(Loaded)`;
                        
                        const summaryDiv = nebulaMsgElement.querySelector('.nebula-final-summary');
                        if (summaryDiv && reportUrl) {
                             summaryDiv.innerHTML = '';
                             const downloadLink = document.createElement("a");
                             downloadLink.textContent = "Download Report (MD)";
                             downloadLink.className = "nebula-download-btn";
                             downloadLink.href = reportUrl;
                             downloadLink.target = "_blank";
                             summaryDiv.appendChild(downloadLink);
                        }

                    } else { 
                        const isResearch = msg.is_research_output;
                        const msgDiv = document.createElement("div");
                        msgDiv.classList.add("message", "stellar-msg");
                        if (isResearch) msgDiv.classList.add("research-output");
                        msgDiv.dataset.id = msgId;
                        
                        const contentDiv = document.createElement("div");
                        contentDiv.classList.add("message-content");
                        let htmlContent = marked.parse(content || "");
                        htmlContent = wrapTables(htmlContent);
                        contentDiv.innerHTML = htmlContent;
                        msgDiv.appendChild(contentDiv);

                        processCodeBlocks(contentDiv);
                        if (analysisContext) { addAnalysisIndicator(msgDiv, analysisContext); }
                        addOutputCopyButton(msgDiv);

                        if (isResearch) {
                            createAndAppendResearchButtons(msgDiv, msgId, contentDiv.innerHTML);
                            if (msg.html_file) {
                                const btnsDiv = msgDiv.querySelector('.message-buttons');
                                if (btnsDiv) {
                                    const viewBtn = document.createElement("a");
                                    viewBtn.classList.add("download-btn", "view-html-btn");
                                    viewBtn.textContent = "View Paper";
                                    viewBtn.href = `/view/${msg.html_file.split('/').pop()}`;
                                    viewBtn.target = "_blank";
                                    btnsDiv.appendChild(viewBtn);
                                }
                            }
                        }
                        if (messagesDiv) messagesDiv.appendChild(msgDiv);
                        setTimeout(() => { renderMath(contentDiv); const analysisEl = msgDiv.querySelector('.analysis-content .formatted-analysis-context'); if(analysisEl) renderMath(analysisEl); }, 150);
                    }
                } catch (error) {
                    appendStellarMessage(`*Error displaying history message ${msgId}*`, msgId + '_err');
                }
            });
             
           
            const lastMessage = data.history[data.history.length - 1];
            const lastUserMessage = data.history.filter(m => m.message_type === 'user').pop();

            if (lastMessage && lastMessage.message_type === "nebula_output") {
                const stepOutputs = lastMessage.nebula_output || {};
                const stepKeys = Object.keys(stepOutputs);
                const maxStep = Math.max(0, ...stepKeys.map(k => parseInt(k.replace('step',''))).filter(n => !isNaN(n)));
                const lastMessageElement = messagesDiv.querySelector(`.message[data-id="${lastMessage.id}"]`);

                if (maxStep > 0 && maxStep < 4) { 
                    console.log("Restoring incomplete Nebula process from history.");
                    modeSelector.value = 'nebula';
                    handleModeChange();

                    nebulaProcess.isActive = true;
                    nebulaProcess.messageElement = lastMessageElement;
                    nebulaProcess.processId = lastMessage.id.replace('nebula-output-', '');
                    nebulaProcess.userQuery = lastUserMessage ? lastUserMessage.message_content : ""; 
                    nebulaProcess.planOutput = stepOutputs.step1 || null;
                    nebulaProcess.frontendOutput = stepOutputs.step2 || null;
                    nebulaProcess.backendOutput = stepOutputs.step3 || null;
                    nebulaProcess.verificationOutput = stepOutputs.step4 || null;
                    nebulaProcess.currentStep = maxStep;

                    setStatus(`Nebula: Restored at Step ${maxStep}. Confirm to continue.`);
                    updateNebulaButtonStates();
                }
            } else if (lastUserMessage && lastUserMessage.message_content) {
                
                 const lastStellarMessage = data.history[data.history.length - 1];
                 if(lastStellarMessage && lastStellarMessage.is_research_output){
                    modeSelector.value = 'spectrum';
                    handleModeChange();
                 }
            }
            // --- FIX END ---

            if (targetMessageId) {
                setTimeout(() => {
                    const targetElement = messagesDiv.querySelector(`.message[data-id="${targetMessageId}"]`);
                    if (targetElement) {
                        targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        targetElement.classList.add('highlight');
                        if (highlightTerm) highlightTextInMessage(targetElement, highlightTerm);
                        setTimeout(() => {
                            targetElement.classList.remove('highlight');
                            removeHighlightFromMessage(targetElement);
                        }, 2500);
                    }
                }, 400);
            } else {
                setTimeout(scrollToBottom, 400);
            }
        } else {
             
             const welcome = "Heyy there! I'm Stellar, and I can help you with research papers using Spectrum Mode, which includes Spectral Search! and building websites/apps with Nebula Mode!  I can also generate data analysis reports with extreme infographics using Cosmos! You can even Preview code blocks to see them live! I've got different models too, like Emerald for quick stuff or Obsidian for super complex things! ✨  ";
             appendStellarMessage(welcome, "welcome-msg");
        }
        historyLoaded = true;
    } catch (error) {
        appendStellarMessage(`Error loading history: ${error.message}.`, Date.now() + '_hist_err');
        setStatus("Error loading history", true);
        historyLoaded = false;
    } finally {
        updateModelSelectTheme();
        updateModelSelectWidth();
        adjustTextareaHeight();
        const idle = !isProcessing && !nebulaProcess.isActive && stagedFiles.length === 0 && analysisProgressArea.childElementCount === 0;
        if (idle) setStatus("Idle");
        else setStatus(currentStatusText);
    }
}


        async function loadChatList() {
            try {
                const response = await fetch('/api/chats');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const chats = await response.json();

                chatList.innerHTML = '';
                if (chats.length > 0) {
                    chats.forEach(chat => {
const li = document.createElement('li');
li.className = 'chat-item';
li.dataset.chatId = chat.id;
li.innerHTML = createChatItemHtml(chat); 
li.addEventListener('click', () => selectChat(chat.id));
li.querySelector('.delete-chat-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    deleteChat(chat.id, chat.name);
});
chatList.appendChild(li);
                    });
                    if (!currentChatId) {
                        selectChat(chats[0].id);
                    } else {
                        const activeChatItem = chatList.querySelector(`.chat-item[data-chat-id="${currentChatId}"]`);
                        if (activeChatItem) {
                            activeChatItem.classList.add('active');
                        } else {
                            selectChat(chats[0].id);
                        }
                    }
                } else {
                    await createNewChat(false); 
                }
            } catch (error) {
                setStatus(`Error loading chats: ${error.message}`, true);
            }
        }

        async function createNewChat(selectNew = true) {
            if (isProcessing || (nebulaProcess.isActive && nebulaProcess.currentStep <= 3)) {
                setStatus("Cannot create new chat while processing.", true);
                setTimeout(() => setStatus(currentStatusText, false), 3000);
                return;
            }
            setStatus("Creating new chat...");
            try {
                const response = await fetch('/api/chats/new', { method: 'POST' });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                const newChat = { id: data.chat_id, name: "New Chat", created_at: new Date().toISOString() };
 const li = document.createElement('li');
li.className = 'chat-item';
li.dataset.chatId = newChat.id;
li.innerHTML = createChatItemHtml(newChat); // UPDATED LINE
li.addEventListener('click', () => selectChat(newChat.id));
li.querySelector('.delete-chat-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    deleteChat(newChat.id, newChat.name);
});
chatList.prepend(li);
                if (selectNew) {
                    await selectChat(newChat.id);
                    setStatus("New chat created.", false);
                }
            } catch (error) {
                setStatus(`Error creating chat: ${error.message}`, true);
            } finally {
                if (!isProcessing) setStatus("Idle");
            }
        }



async function selectChat(chatId) {
    if (isProcessing || (nebulaProcess.isActive && nebulaProcess.currentStep <= 3)) {
        setStatus("Cannot switch chat while processing.", true);
        setTimeout(() => setStatus(currentStatusText, false), 3000);
        return;
    }

    if (currentChatId === chatId) {
        sidebar.classList.remove('open');
        return;
    }

    
    currentChatId = chatId;
    
  
    try {
        const response = await fetch('/api/set_active_chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ chat_id: chatId })
        });
        if (!response.ok) {
            console.error("Failed to set active chat on backend. History clearing might be affected.");
        }
    } catch (error) {
        console.error("Error setting active chat on backend:", error);
    }
  

   
    messagesDiv.innerHTML = '';
    historyLoaded = false;
    setStatus("Switching chat...");

    document.querySelectorAll('.chat-item').forEach(item => item.classList.remove('active'));
    const selectedItem = chatList.querySelector(`.chat-item[data-chat-id="${chatId}"]`);
    if (selectedItem) {
        selectedItem.classList.add('active');
    }
    clearInterval(tokenCounterInterval);
    tokenCounterInterval = null;

    const targetMessageId = selectedItem?.dataset.messageId || null;
    const highlightTerm = selectedItem?.dataset.searchTerm || null;

    await loadHistory(chatId, targetMessageId, highlightTerm);
    await updateTokenCount();
    
    sidebar.classList.remove('open');
    setStatus(`Switched to chat.`, false);
    setTimeout(() => setStatus("Idle"), 2000);

    if (selectedItem) {
        delete selectedItem.dataset.messageId;
        delete selectedItem.dataset.searchTerm;
    }
}

        async function deleteChat(chatId, chatName) {

            if (isProcessing || (nebulaProcess.isActive && nebulaProcess.currentStep <= 3)) {
                setStatus("Cannot delete chat while processing.", true);
                setTimeout(() => setStatus(currentStatusText, false), 3000);
                return;
            }

            setStatus(`Deleting chat "${chatName}"...`);
            try {
                const response = await fetch(`/api/chats/${chatId}/delete`, { method: 'DELETE' });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                if (data.success) {
                    const deletedItem = chatList.querySelector(`.chat-item[data-chat-id="${chatId}"]`);
                    if (deletedItem) {
                        deletedItem.remove();
                    }
                    if (currentChatId === chatId) {
                        currentChatId = null;
                        messagesDiv.innerHTML = '';
                        historyLoaded = false;
                        clearInterval(tokenCounterInterval);
                        tokenCounterInterval = null;
                        await loadChatList(); 
                    }
                    setStatus(`Chat "${chatName}" deleted.`, false);
                } else {
                    throw new Error(data.message || 'Failed to delete chat.');
                }
            } catch (error) {
                setStatus(`Error deleting chat: ${error.message}`, true);
            } finally {
                setTimeout(() => { if (!isProcessing) setStatus("Idle"); }, 2000);
            }
        }

        function updateChatNameInList(chatId, newName) {
            const chatItem = chatList.querySelector(`.chat-item[data-chat-id="${chatId}"] span`);
            if (chatItem) {
                chatItem.textContent = newName;
            }
        }



async function updateTokenCount() {
    
    document.querySelectorAll('.chat-item-token-counter').forEach(el => {
        el.style.display = 'none';
    });

    
    const activeChatItem = document.querySelector('#chatList .chat-item.active');

   
    if (!activeChatItem || !currentChatId) {
        return;
    }

   
    const counterContainer = activeChatItem.querySelector('.chat-item-token-counter');
    const tokenText = activeChatItem.querySelector('.token-text');
    const tokenFill = activeChatItem.querySelector('.token-bar-fill');

    if (!counterContainer || !tokenText || !tokenFill) {
        // 
        return;
    }

    try {
        const response = await fetch(`/api/chats/${currentChatId}/tokens`);
        if (!response.ok) {
            console.error("Failed to fetch token count:", response.status);
            return; 
        }

        const data = await response.json();
        const tokenCount = data.token_count || 0;

       
        let percentage = (tokenCount / MAX_TOKEN_LIMIT) * 100;
        percentage = Math.min(100, Math.max(0, percentage));

       
        tokenText.textContent = `${percentage.toFixed(1)}% Used`;
       

      
        tokenFill.style.width = `${percentage}%`;

        
        if (percentage < 50) {
            tokenFill.style.backgroundColor = 'var(--token-bar-fill-low)';
        } else if (percentage < 80) {
            tokenFill.style.backgroundColor = 'var(--token-bar-fill-medium)';
        } else {
            tokenFill.style.backgroundColor = 'var(--token-bar-fill-high)';
        }

        
        counterContainer.style.display = 'block';

    } catch (error) {
        console.error("Error fetching token count:", error);
    }
}

        async function checkAuthStatus() {
            try {
                const response = await fetch('/check_auth');
                const data = await response.json();
                if (data.logged_in) {
                    currentUsername = data.username;
                    profileIcon.textContent = currentUsername.charAt(0).toUpperCase();
                    sidebarUsername.textContent = currentUsername;
                    profileUsernameDisplay.textContent = currentUsername;

                    document.querySelector('header').style.display = 'flex';
                    document.querySelector('.header-left').style.display = 'flex';
                    document.querySelector('.header-right').style.display = 'flex';
                    chatContainer.style.display = 'flex';
                    inputContainer.style.display = 'flex';
                    sidebar.style.display = 'flex';
                    tokenCountBar.style.display = 'block';
                    chatScrollToBottomBtn.style.display = 'flex';

                    authContainer.classList.remove('fade-in');
                    authContainer.classList.add('fade-out');
                    setTimeout(() => {
                        authContainer.style.display = 'none';
                        if (!historyLoaded) {
                            loadChatList();
                        }
                    }, 500);
                } else {
                    document.querySelector('header').style.display = 'flex';
                    document.querySelector('.header-left').style.display = 'none';
                    document.querySelector('.header-right').style.display = 'none';
                    chatContainer.style.display = 'none';
                    inputContainer.style.display = 'none';
                    sidebar.style.display = 'none';
                    tokenCountBar.style.display = 'none';

                    authContainer.style.display = 'flex';
                    authContainer.classList.remove('fade-out');
                    authContainer.classList.add('fade-in');
                    fetchUnsplashImage();
                }
            } catch (error) {
                document.querySelector('header').style.display = 'flex';
                document.querySelector('.header-left').style.display = 'none';
                document.querySelector('.header-right').style.display = 'none';
                chatContainer.style.display = 'none';
                inputContainer.style.display = 'none';
                sidebar.style.display = 'none';
                tokenCountBar.style.display = 'none';

                authContainer.style.display = 'flex';
                authContainer.classList.remove('fade-out');
                authContainer.classList.add('fade-in');
                fetchUnsplashImage();
                setStatus("Failed to check auth status. Please refresh.", true);
                setTimeout(() => setStatus("Idle", false), 3000);
            }
        }

        

        async function handleLogout() {
    try {
        resetAuthUI(); 
        const response = await fetch('/logout', { method: 'POST' });
        const data = await response.json();
        if (data.success) {
            messagesDiv.innerHTML = '';
            historyLoaded = false;
            stagedFiles = [];
            updateStagedFilesUI();
            analysisProgressArea.innerHTML = '';
            analysisProgressArea.style.display = 'none';
            if (sseEventSource) {
                sseEventSource.close();
                sseEventSource = null;
            }
            resetNebulaProcessState();
            clearInterval(tokenCounterInterval);
            tokenCounterInterval = null;
            currentChatId = null;
            currentUsername = null;
            chatTitle.textContent = "Stellar";
            sidebar.classList.remove('open');
            profileModal.style.display = 'none';
            chatScrollToBottomBtn.style.display = 'none';
            setStatus("Logged out. Goodbye!", false);
            setTimeout(checkAuthStatus, 500);
            setTimeout(() => setStatus("Idle", false), 3000);
        } else {
            setStatus(data.message || 'Logout failed.', true);
            setTimeout(() => setStatus(currentStatusText, false), 3000);
        }
    } catch (error) {
        setStatus('An error occurred during logout.', true);
        setTimeout(() => setStatus(currentStatusText, false), 3000);
    }
}
function resetAuthUI() {
    window.webglInitialized = false;
    window.tiltInitialized = false;
    window.formsInitialized = false;
    window.logoutInProgress = true;
}

        async function handleChangePassword(event) {
    event.preventDefault();
    const currentPassword = currentPasswordInput.value;
    const newPassword = newPasswordInput.value;
    const confirmNewPassword = confirmNewPasswordInput.value;
    displayModalMessage(passwordChangeMessage, '', false);

    if (!currentPassword || !newPassword || !confirmNewPassword) {
        displayModalMessage(passwordChangeMessage, 'All fields are required.', true);
        return;
    }
    if (newPassword !== confirmNewPassword) {
        displayModalMessage(passwordChangeMessage, 'New passwords do not match.', true);
        return;
    }
    if (newPassword.length < 6) {
        displayModalMessage(passwordChangeMessage, 'New password must be at least 6 characters long.', true);
        return;
    }

    try {
        const response = await fetch('/api/user/change_password', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ current_password: currentPassword, new_password: newPassword })
        });
        const data = await response.json();
        if (data.success) {
            displayModalMessage(passwordChangeMessage, 'Password changed successfully!', false);
            currentPasswordInput.value = '';
            newPasswordInput.value = '';
            confirmNewPasswordInput.value = '';
        } else {
            displayModalMessage(passwordChangeMessage, data.message || 'Failed to change password.', true);
        }
    } catch (error) {
        displayModalMessage(passwordChangeMessage, 'An error occurred while changing password.', true);
    }
}

        

function highlightTextInMessage(messageElement, textToHighlight) {
    const contentDiv = messageElement.querySelector('.message-content');
    if (!contentDiv || !textToHighlight) return;

   
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = contentDiv.innerHTML;

  
    const walk = document.createTreeWalker(tempDiv, NodeFilter.SHOW_TEXT, null, false);
    let node;
    const nodesToReplace = [];

    while (node = walk.nextNode()) {
        const parentTag = node.parentNode.tagName.toLowerCase();
       
        if (parentTag === 'code' || parentTag === 'pre' || parentTag === 'script' || node.parentNode.classList.contains('highlighted-text')) {
            continue;
        }

        const regex = new RegExp(textToHighlight, 'gi');
        if (node.nodeValue.match(regex)) {
            nodesToReplace.push(node);
        }
    }

    nodesToReplace.forEach(node => {
        const span = document.createElement('span');
        span.innerHTML = node.nodeValue.replace(
            new RegExp(textToHighlight, 'gi'),
            match => `<span class="">${match}</span>`
        );
        node.parentNode.replaceChild(span, node);
    });

    contentDiv.innerHTML = tempDiv.innerHTML;
}
function removeHighlightFromMessage(messageElement) {
    const contentDiv = messageElement.querySelector('.message-content');
    if (!contentDiv) return;

    const highlightedSpans = contentDiv.querySelectorAll('.highlighted-text');
    highlightedSpans.forEach(span => {
        const parent = span.parentNode;
        while (span.firstChild) {
            parent.insertBefore(span.firstChild, span);
        }
        parent.removeChild(span);
    });
}

       
        const metaballCanvas = document.getElementById("metaball-canvas");
        let threeJsScript = null; 

       
        function loadThreeJs() {
            if (document.getElementById('threejs-lib')) return; 
            threeJsScript = document.createElement('script');
            threeJsScript.id = 'threejs-lib';
            threeJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
            threeJsScript.onload = () => {
                initNewAuthUI();
            };
            document.body.appendChild(threeJsScript);
        }

        
function displayLoginMessage(message, isError) {
    const cardHeader = document.querySelector('.auth-card-header');
    if (!cardHeader) return;

    const existingMsg = cardHeader.querySelector('.auth-message');
    if (existingMsg) existingMsg.remove();

    if (!message) return;

    const messageEl = document.createElement('div');
    messageEl.textContent = message;
    messageEl.className = 'auth-message';
    messageEl.classList.add(isError ? 'error' : 'success');
    
    cardHeader.appendChild(messageEl);
}


function displayModalMessage(element, message, isError) {
    element.textContent = message;
    element.classList.remove('success', 'error');
    if (message) {
        element.style.display = 'block';
        element.classList.add(isError ? 'error' : 'success');
    } else {
        element.style.display = 'none';
    }
}
      
        async function checkAuthStatus() {
            try {
                const response = await fetch('/check_auth');
                const data = await response.json();
                if (data.logged_in) {
                    currentUsername = data.username;
                   
                    profileIcon.textContent = currentUsername.charAt(0).toUpperCase();
                    sidebarUsername.textContent = currentUsername;
                    profileUsernameDisplay.textContent = currentUsername;

                    document.querySelector('header').style.display = 'flex';
                    document.querySelector('.header-left').style.display = 'flex';
                    document.querySelector('.header-right').style.display = 'flex';
                    chatContainer.style.display = 'flex';
                    inputContainer.style.display = 'flex';
                    sidebar.style.display = 'flex';
                    tokenCountBar.style.display = 'block';
                    chatScrollToBottomBtn.style.display = 'flex';
                    
                    
                    authContainer.classList.remove('fade-in');
                    authContainer.classList.add('fade-out');
                    metaballCanvas.style.display = 'none';

                    setTimeout(() => {
                        authContainer.style.display = 'none';
                        if (!historyLoaded) {
                            loadChatList();
                        }
                    }, 500);
                } else {
                   
                    document.querySelector('header').style.display = 'flex';
                    document.querySelector('.header-left').style.display = 'none';
                    document.querySelector('.header-right').style.display = 'none';
                    chatContainer.style.display = 'none';
                    inputContainer.style.display = 'none';
                    sidebar.style.display = 'none';
                    tokenCountBar.style.display = 'none';
                    
                   
                    authContainer.style.display = 'flex';
                    authContainer.classList.remove('fade-out');
                    authContainer.classList.add('fade-in');
                    metaballCanvas.style.display = 'block';

                    loadThreeJs();
                }
            } catch (error) {
                
                document.querySelector('header').style.display = 'flex';
                document.querySelector('.header-left').style.display = 'none';
                document.querySelector('.header-right').style.display = 'none';
                chatContainer.style.display = 'none';
                inputContainer.style.display = 'none';
                sidebar.style.display = 'none';
                tokenCountBar.style.display = 'none';

                authContainer.style.display = 'flex';
                authContainer.classList.remove('fade-out');
                authContainer.classList.add('fade-in');
                metaballCanvas.style.display = 'block';
                loadThreeJs();
                
                setStatus("Failed to check auth status. Please refresh.", true);
                setTimeout(() => setStatus("Idle", false), 3000);
            }
        }
        
        async function handleLogin(event) {
    event.preventDefault();
    const username = document.getElementById('loginUsername').value.trim();
    const password = document.getElementById('loginPassword').value.trim();
    displayLoginMessage('', false); 

    if (!username || !password) {
        displayLoginMessage('Username and password are required.', true);
        return;
    }

    try {
        const response = await fetch('/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username, password })
        });
        const data = await response.json();
        if (data.success) {
            displayLoginMessage('Login successful!', false);
            setTimeout(checkAuthStatus, 500);
        } else {
            displayLoginMessage(data.message || 'Login failed.', true);
        }
    } catch (error) {
        displayLoginMessage('An error occurred during login.', true);
    }
}
        
async function handleRegister(event) {
    event.preventDefault();
    const username = document.getElementById('registerUsername').value.trim();
    const password = document.getElementById('registerPassword').value.trim();
    const confirmPassword = document.getElementById('registerConfirmPassword').value.trim();
    displayLoginMessage('', false);

    if (!username || !password || !confirmPassword) {
        displayLoginMessage('All fields are required.', true);
        return;
    }
    if (password !== confirmPassword) {
        displayLoginMessage('Passwords do not match.', true);
        return;
    }

    try {
        const registerResponse = await fetch('/register', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username, password })
        });
        const registerData = await registerResponse.json();

        if (registerData.success) {
            displayLoginMessage('Account created! Logging you in...', false);
            const loginResponse = await fetch('/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, password })
            });
            const loginData = await loginResponse.json();
            if (loginData.success) {
                setTimeout(checkAuthStatus, 500);
            } else {
                document.getElementById('authLink').click();
                setTimeout(() => {
                    displayLoginMessage('Account created, but auto-login failed. Please sign in.', true);
                }, 500);
            }
        } else {
            displayLoginMessage(registerData.message || 'Registration failed.', true);
        }
    } catch (error) {
        displayLoginMessage('An error occurred during registration.', true);
    }
}

        
function initNewAuthUI() {
    
    (function initWebGL() {
        if (window.webglInitialized) return;
        window.webglInitialized = true;
        let scene, camera, renderer, material, balls = [], NUM_BALLS = 7, BALL_SIZE = 60;
        const vertexShader = `void main() { gl_Position = vec4(position, 1.0); }`;
        const fragmentShader = `uniform vec3[${NUM_BALLS}] u_balls; uniform float u_ball_size; uniform vec3 u_color_1, u_color_2, u_color_3; void main() { vec2 coord = gl_FragCoord.xy; float sum = 0.0; vec3 color_sum = vec3(0.0); for (int i = 0; i < ${NUM_BALLS}; i++) { vec3 ball = u_balls[i]; float influence = (ball.z * u_ball_size) / distance(coord, ball.xy); sum += influence; if (i == 0 || i == 3 || i == 6) color_sum += influence * u_color_1; else if (i == 1 || i == 4) color_sum += influence * u_color_2; else color_sum += influence * u_color_3; } if (sum >= 1.0) { gl_FragColor = vec4(normalize(color_sum), 1.0); } else { discard; } }`;
        try {
            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('metaball-canvas'), alpha: true });
            const geometry = new THREE.PlaneBufferGeometry(2, 2);
            material = new THREE.ShaderMaterial({ vertexShader, fragmentShader, uniforms: { u_balls: { value: [] }, u_ball_size: { value: BALL_SIZE }, u_color_1: { value: new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--color-1')) }, u_color_2: { value: new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--color-2')) }, u_color_3: { value: new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--color-3')) } }, transparent: true });
            scene.add(new THREE.Mesh(geometry, material));
            for (let i = 0; i < NUM_BALLS; i++) { balls.push({ x: Math.random(), y: Math.random(), z: 0.6 + Math.random() * 0.4, vx: (Math.random() - 0.5) * 0.0008, vy: (Math.random() - 0.5) * 0.0008 }); }
            const animate = () => { if (metaballCanvas.style.display === 'none' && !window.logoutInProgress) { requestAnimationFrame(animate); return; } window.logoutInProgress = false; requestAnimationFrame(animate); let ball_data = []; balls.forEach(ball => { ball.x += ball.vx; ball.y += ball.vy; if (ball.x < 0 || ball.x > 1) ball.vx *= -1; if (ball.y < 0 || ball.y > 1) ball.vy *= -1; ball_data.push(new THREE.Vector3(ball.x * window.innerWidth, ball.y * window.innerHeight, ball.z)); }); material.uniforms.u_balls.value = ball_data; renderer.render(scene, camera); };
            const resize = () => renderer.setSize(window.innerWidth, window.innerHeight);
            window.addEventListener('resize', resize); resize(); animate();
        } catch (e) { console.error("Three.js initialization failed:", e); }
    })();

    (function initTilt() {
        if (window.tiltInitialized) return;
        window.tiltInitialized = true;
        const authCard = document.querySelector('.auth-card'), authContainer = document.getElementById('authContainer');
        window.addEventListener('mousemove', (e) => { if (authContainer.style.display === 'none') return; const { clientX, clientY } = e, { offsetWidth, offsetHeight } = authContainer, xRotation = 8 * ((clientY - offsetHeight / 2) / offsetHeight), yRotation = -8 * ((clientX - offsetWidth / 2) / offsetWidth); authCard.style.transform = `rotateX(${xRotation}deg) rotateY(${yRotation}deg)`; const rect = authCard.getBoundingClientRect(); authCard.style.setProperty('--x', `${clientX - rect.left}px`); authCard.style.setProperty('--y', `${clientY - rect.top}px`); });
        authContainer.addEventListener('mouseleave', () => { authCard.style.transform = `rotateX(0deg) rotateY(0deg)`; });
    })();

    
    (function initForms() {
        if (window.formsInitialized) { return; }
        window.formsInitialized = true;
        
        const loginForm = document.getElementById('loginForm');
        const registerForm = document.getElementById('registerForm');
        const authLink = document.getElementById('authLink');
        const footerText = document.getElementById('authFooterText');
        const subtitle = document.getElementById('authSubtitle');
        const authTitle = document.getElementById('authTitle');
        let typingTimeoutId;

        loginForm.addEventListener('submit', handleLogin);
        registerForm.addEventListener('submit', handleRegister);
        
        function typeEffect() {
            const titleTextSpan = document.getElementById('titleText');
            const cursorSpan = document.querySelector('.text-cursor');
            if (!titleTextSpan || !cursorSpan) return;
            
            clearTimeout(typingTimeoutId);
            const words = ["Stellar"]; 
            let charIndex = 0, isDeleting = false;

            function type() {
                const currentWord = words[0]; 
                const typeSpeed = isDeleting ? 75 : 150;

                if (isDeleting) {
                    titleTextSpan.textContent = currentWord.substring(0, charIndex - 1);
                    charIndex--;
                } else {
                    titleTextSpan.textContent = currentWord.substring(0, charIndex + 1);
                    charIndex++;
                }

                if (!isDeleting && charIndex === currentWord.length) {
                    isDeleting = true;
                    typingTimeoutId = setTimeout(type, 2000);
                } else if (isDeleting && charIndex === 0) {
                    isDeleting = false;
                    typingTimeoutId = setTimeout(type, 500);
                } else {
                    typingTimeoutId = setTimeout(type, typeSpeed);
                }
            }
            type();
        }

        function toggleForms(e) {
            e.preventDefault();
            displayLoginMessage('', false);
            clearTimeout(typingTimeoutId);
            const isLoginVisible = loginForm.style.display !== 'none';
            
            if (isLoginVisible) {
                loginForm.style.display = 'none';
                registerForm.style.display = 'block';
                authTitle.innerHTML = '<h2>Stellar</h2>';
                subtitle.textContent = 'Create your account';
                footerText.innerHTML = 'Already have an account? <a id="authLink">Sign in</a>';
            } else {
                loginForm.style.display = 'block';
                registerForm.style.display = 'none';
                authTitle.innerHTML = `<span id="titleText"></span><span class="text-cursor"> </span>`;
                subtitle.textContent = 'Sign in to your account';
                footerText.innerHTML = 'Don\'t have an account? <a id="authLink">Sign up</a>';
                typeEffect();
            }
           
            document.getElementById('authLink').addEventListener('click', toggleForms);
        }
        authLink.addEventListener('click', toggleForms);
        
       
        authTitle.innerHTML = `<span id="titleText"></span><span class="text-cursor"> </span>`;
        typeEffect();
    })();
}
        

        function toggleSidebar() {
            sidebar.classList.toggle('open');
        }

        function showProfileModal() {
            profileModal.style.display = 'flex';
            currentPasswordInput.value = '';
            newPasswordInput.value = '';
            confirmNewPasswordInput.value = '';
            displayAuthMessage(passwordChangeMessage, '', false);
        }

        function hideProfileModal() {
            profileModal.style.display = 'none';
        }


messagesDiv.addEventListener('click', function(event) {
   
    const downloadButton = event.target.closest('.download-code-btn');

    if (downloadButton) {
        event.stopPropagation(); 

        
        const codeContentWrapper = downloadButton.closest('.code-content-original');
        if (!codeContentWrapper) return;

        const codeElement = codeContentWrapper.querySelector('code');
        if (!codeElement) return;

       
        const codeToDownload = codeElement.textContent;

       
const langClass = codeElement.className.match(/language-(\w+)/);
let extension = langClass ? langClass[1] : 'txt';

const extensionMap = {
  'python': 'py',
  'javascript': 'js',
  'java': 'java',
  'c': 'c',
  'cpp': 'cpp',
  'csharp': 'cs',
  'php': 'php',
  'typescript': 'ts',
  'kotlin': 'kt',
  'go': 'go',
  'rust': 'rs',
  'html': 'html',
  'css': 'css',
  'json': 'json',
  'xml': 'xml',
  'yaml': 'yaml',
  'markdown': 'md',
};

extension = extensionMap[extension] || 'txt';

const fileName = `stellar_code.${extension}`;


        
        const blob = new Blob([codeToDownload], { type: 'text/plain;charset=utf-8' });

        
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = fileName;
        
       
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        
        URL.revokeObjectURL(link.href);
    }
});
        if (sendBtn) sendBtn.addEventListener("click", handleSend);
        if (chatInput) { chatInput.addEventListener("keydown", (e) => { if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); handleSend(); } }); chatInput.addEventListener("input", adjustTextareaHeight); }
        if (modeSelector) modeSelector.addEventListener("change", handleModeChange);
        if (spectrumSearchBtn) { spectrumSearchBtn.addEventListener("click", () => { if (currentMode === 'spectrum' && !spectrumSearchBtn.disabled) { updateSpectrumSearchButtonState(!useSpectrumSearch); } }); }
        if (modelSelect) { modelSelect.addEventListener("change", () => { updateModelSelectWidth(); updateModelSelectTheme(); enableDisableModelOptions(); }); }
        if (cancelEditBtn) cancelEditBtn.addEventListener("click", hideEditModal);
        if (saveEditBtn) { saveEditBtn.addEventListener("click", () => { if (currentEditingMsg && currentEditingMsgId) { const md = editMarkdownInput.value; let html = ""; try { html = marked.parse(md || ""); html = wrapTables(html); } catch (e) { html = "<p>Error parsing.</p>"; } const contentDiv = currentEditingMsg.querySelector('.message-content'); if (contentDiv) { contentDiv.innerHTML = html; processCodeBlocks(contentDiv); setTimeout(() => renderMath(contentDiv), 150); createAndAppendResearchButtons(currentEditingMsg, currentEditingMsgId, contentDiv.innerHTML); addOutputCopyButton(currentEditingMsg); } } hideEditModal(); }); }
        if (cancelRegenerateBtn) cancelRegenerateBtn.addEventListener("click", hideRegenerateModal);
        if (saveRegenerateBtn) saveRegenerateBtn.addEventListener("click", handleSaveRegeneration);
        if (regenerateWithoutFeedbackBtn) { regenerateWithoutFeedbackBtn.addEventListener("click", () => { triggerRegeneration(currentRegeneratingStep); }); }
       // REPLACE the old clearHistoryBtn block with this one
                if (clearHistoryBtn) { 
            clearHistoryBtn.addEventListener("click", async () => { 
                if (isProcessing || (nebulaProcess.isActive && nebulaProcess.currentStep <= 3)) { 
                    const msg = isProcessing ? "Wait..." : `Wait Nebula Step ${nebulaProcess.currentStep}.`; 
                    setStatus(msg, true); 
                    setTimeout(() => setStatus(currentStatusText, false), 2000); 
                    return; 
                } 
                if (nebulaProcess.isActive) { 
                    cleanupNebulaProcess(true, "Cleared"); 
                } 
                setStatus("Clearing..."); 
                try { 
                    const r = await fetch("/clear_history", { method: "POST" }); 
                    if (!r.ok) { 
                        let m = `HTTP ${r.status}`; 
                        try { m = (await r.json()).message || m; } catch(e){} 
                        throw new Error(m); 
                    } 
                    const d = await r.json(); 
                    if (d.status !== 'Success') throw new Error(d.message || "Fail"); 
                    
                    lastRefinedQuery = ""; 
                    historyLoaded = false; 
                    stagedFiles = []; 
                    updateStagedFilesUI(); 
                    messagesDiv.innerHTML = ""; 
                    analysisProgressArea.innerHTML = ""; 
                    analysisProgressArea.style.display = 'none'; 
                    
                    // Reset CodeLab UI specifically
                    if (currentMode === 'codelab') {
                        showProblemGenerator();
                        const outputPanel = document.getElementById('codelab-output-panel');
                        if (outputPanel) outputPanel.innerHTML = '';
                        if (codeLabEditor) codeLabEditor.setValue("# Welcome to Stellar CodeLab!\n# Click 'Run' to see this message in the output.\n\nprint('Hello, CodeLab!')");
                    }
                    
                    if (currentMode !== 'codelab') {
                        modeSelector.value = 'stellar';
                        handleModeChange();
                    }

                    await loadHistory();
                    
                    setStatus("History cleared"); 
                    setTimeout(() => { 
                        const shouldBeIdle = !isProcessing && !nebulaProcess.isActive && stagedFiles.length === 0 && analysisProgressArea?.childElementCount === 0; 
                        if (shouldBeIdle) setStatus("Idle"); 
                    }, 1500); 
                } catch (err) { 
                    appendStellarMessage(`Clear err: ${err.message}`, Date.now() + '_clr_err'); 
                    setStatus("Error clear", true); 
                    setTimeout(() => setStatus(currentStatusText, false), 3000); 
                } 
            }); 
        }
        if (fileUploadInput) { fileUploadInput.addEventListener('change', handleFileUpload); }
        if (messagesDiv) { messagesDiv.addEventListener('click', function(event) { const clickable = event.target.closest('.message-content .analysis-placeholder, .message-content .analysis-indicator.clickable'); if (clickable) { const msgEl = clickable.closest('.message'); if (msgEl) { toggleAnalysisDetails(msgEl); } } }); }
        

        
        sidebarToggleBtn.addEventListener('click', toggleSidebar);
        sidebarCloseBtn.addEventListener('click', toggleSidebar);
        newChatBtn.addEventListener('click', createNewChat);
        profileIcon.addEventListener('click', showProfileModal);
        profileCloseBtn.addEventListener('click', hideProfileModal);
        changePasswordForm.addEventListener('submit', handleChangePassword);
        logoutButtonProfile.addEventListener('click', handleLogout);
        document.getElementById('logoutButton').addEventListener('click', handleLogout);
         if (chatScrollToBottomBtn) {
            chatScrollToBottomBtn.addEventListener('click', scrollToBottom);
        }

        window.addEventListener("load", () => {
            resetNebulaProcessState();
            if (modelSelect) { updateModelSelectTheme(); updateModelSelectWidth(); }
            handleModeChange();
            checkAuthStatus();
            initializeCodeEditor();
            
            // Setup for Problem Solving mode
            document.getElementById('codelabRunBtn')?.addEventListener('click', () => handleCodeExecution('run'));
            document.getElementById('codelabSubmitBtn')?.addEventListener('click', () => handleCodeExecution('submit'));
            document.getElementById('codelabExplainBtn')?.addEventListener('click', () => handleAIAssist('explain'));
            document.getElementById('codelabDebugBtn')?.addEventListener('click', () => handleAIAssist('debug'));
            document.getElementById('codelabOptimizeBtn')?.addEventListener('click', () => handleAIAssist('optimize'));
            document.getElementById('generateProblemForm')?.addEventListener('submit', handleGenerateProblem);
            document.getElementById('loadRandomProblemBtn')?.addEventListener('click', () => loadCodeLabProblem());   
            document.getElementById('newProblemBtn')?.addEventListener('click', showProblemGenerator);
            document.getElementById('codelabLanguageSelector')?.addEventListener('change', handleLanguageChange);
            document.querySelector('#problem-generation-container > h3')?.addEventListener('click', (e) => {
                const container = e.target.parentElement;
                if (container) container.classList.toggle('expanded');
            });

            // Setup for Stellar Forge mode
            setupForgeUI();

            setTimeout(() => { adjustTextareaHeight(); updateStatusBarPosition(); scrollToBottom(); }, 300);

            const closeBtn = document.getElementById('live-preview-close-btn');
            if (closeBtn) closeBtn.addEventListener('click', hideLivePreview);
            const previewContainer = document.getElementById('live-preview-container');
            const previewHeader = document.getElementById('live-preview-header');
            if (previewContainer && previewHeader) makeDraggable(previewContainer, previewHeader);
            
            // --- FULL VOICE RECOGNITION LOGIC ---
            const voiceInputBtn = document.getElementById('voiceInputBtn');
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const voiceOverlay = document.getElementById('voiceOverlay');
            const canvas = document.getElementById('voiceWaveCanvas');
            const canvasCtx = canvas.getContext('2d');
            const cancelVoiceBtn = document.getElementById('cancelVoiceBtn');
            const confirmVoiceBtn = document.getElementById('confirmVoiceBtn');
            const voicePrompt = document.querySelector('.voice-prompt');
            
            let recognition;
            let audioContext, analyser, source, animationFrameId;
            let smoothedDataArray;
            const smoothingFactor = 0.8;
            
            if (SpeechRecognition && voiceInputBtn) {
                recognition = new SpeechRecognition();
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'en-US';

                const resizeCanvas = () => {
                    const dpr = window.devicePixelRatio || 1;
                    canvas.width = window.innerWidth * dpr;
                    canvas.height = window.innerHeight * dpr;
                    canvasCtx.scale(dpr, dpr);
                };

                const draw = () => {
                    if (!analyser) return;
                    animationFrameId = requestAnimationFrame(draw); 
                    const bufferLength = analyser.frequencyBinCount;
                    const dataArray = new Uint8Array(bufferLength);
                    analyser.getByteFrequencyData(dataArray);
                    for (let i = 0; i < bufferLength; i++) {
                        smoothedDataArray[i] = smoothedDataArray[i] * smoothingFactor + dataArray[i] * (1 - smoothingFactor);
                    }
                    canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
                    const colorStart = getComputedStyle(document.documentElement).getPropertyValue('--model-color-start').trim();
                    const colorEnd = getComputedStyle(document.documentElement).getPropertyValue('--model-color-end').trim();
                    const gradient = canvasCtx.createLinearGradient(0, 0, canvas.width, 0);
                    gradient.addColorStop(0.2, colorStart);
                    gradient.addColorStop(0.8, colorEnd);
                    canvasCtx.strokeStyle = gradient;
                    canvasCtx.lineWidth = 4; 
                    const barWidth = 6;
                    const barSpacing = 8;
                    const numBars = Math.floor(bufferLength / 3);
                    const activeBarsData = [];
                    const threshold = 5;
                    for (let i = 0; i < numBars; i++) {
                        if (i < numBars / 2) {
                            const dataIndex = Math.floor((i / (numBars / 2)) * bufferLength);
                            if (smoothedDataArray[dataIndex] > threshold) {
                                const v = smoothedDataArray[dataIndex] / 128.0;
                                const barHeight = v * (canvas.height / 10);
                                activeBarsData.push(barHeight < 2 ? 2 : barHeight);
                            }
                        }
                    }
                    const totalActiveWidth = activeBarsData.length * (barWidth + barSpacing);
                    let x = (canvas.width - totalActiveWidth) / 2;
                    const yPos = (canvas.height / 2);
                    canvasCtx.beginPath();
                    for (const barHeight of activeBarsData) {
                        canvasCtx.moveTo(x, yPos - barHeight);
                        canvasCtx.lineTo(x, yPos + barHeight);
                        x += (barWidth + barSpacing);
                    }
                    canvasCtx.stroke();
                };

                const startListening = async () => {
                    if (isProcessing) {
                        setStatus("Cannot use voice while processing a request.", true);
                        setTimeout(() => setStatus(currentStatusText, false), 3000);
                        return;
                    }
                    if (audioContext) return;
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        analyser = audioContext.createAnalyser();
                        analyser.fftSize = 512;
                        analyser.smoothingTimeConstant = 0.88;
                        smoothedDataArray = new Array(analyser.frequencyBinCount).fill(0);
                        source = audioContext.createMediaStreamSource(stream);
                        source.connect(analyser);
                        resizeCanvas();
                        window.addEventListener('resize', resizeCanvas);
                        voiceOverlay.classList.add('visible');
                        canvas.classList.add('visible');
                        voicePrompt.textContent = "Listening...";
                        recognition.start();
                        draw();
                    } catch (err) {
                        console.error("Microphone access denied:", err);
                        alert("Microphone access was denied. Please allow it in your browser settings.");
                        stopListening(false); 
                    }
                };

                const stopListening = (shouldSend = false) => {
                    if (!audioContext) return;
                    recognition.stop();
                    cancelAnimationFrame(animationFrameId);
                    if (source && source.mediaStream) {
                        source.mediaStream.getTracks().forEach(track => track.stop());
                    }
                    if (audioContext.state !== 'closed') {
                        audioContext.close();
                    }
                    audioContext = null;
                    voiceOverlay.classList.remove('visible');
                    canvas.classList.remove('visible');
                    window.removeEventListener('resize', resizeCanvas);
                    const finalTranscript = chatInput.value.trim();
                    if (shouldSend && finalTranscript) {
                        handleSend();
                    } else {
                        chatInput.value = ''; 
                    }
                };

                recognition.onresult = (event) => {
                    let interim_transcript = '';
                    let final_transcript = '';
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) {
                            final_transcript += event.results[i][0].transcript;
                        } else {
                            interim_transcript += event.results[i][0].transcript;
                        }
                    }
                    chatInput.value = final_transcript; 
                    voicePrompt.textContent = final_transcript + interim_transcript;
                };
                
                recognition.onerror = (event) => {
                    console.error("Speech Recognition Error:", event.error);
                    stopListening(false);
                };
                
                voiceInputBtn.addEventListener('click', startListening);
                cancelVoiceBtn.addEventListener('click', () => stopListening(false));
                confirmVoiceBtn.addEventListener('click', () => stopListening(true));
                
            } else {
                if (voiceInputBtn) voiceInputBtn.style.display = 'none';
            }
        }, { once: true });


document.body.addEventListener('dragenter', (e) => {
    e.preventDefault();
    e.stopPropagation();

    const isModalInput = e.target.closest('#editModalBackdrop, #regenerateModalBackdrop, #profileModal');
    if (!isModalInput && inputContainer) { 
        inputContainer.classList.add('active-drop');
    }
}, false);

document.body.addEventListener('dragover', (e) => {
    e.preventDefault();
    e.stopPropagation();
    const isModalInput = e.target.closest('#editModalBackdrop, #regenerateModalBackdrop, #profileModal');
    if (!isModalInput && inputContainer) {
        if (!inputContainer.classList.contains('active-drop')) {
             inputContainer.classList.add('active-drop');
        }
    } else {
        if (inputContainer) inputContainer.classList.remove('active-drop');
    }
}, false);

document.body.addEventListener('dragleave', (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (inputContainer && (!e.relatedTarget || !inputContainer.contains(e.relatedTarget))) {
        inputContainer.classList.remove('active-drop');
    }
}, false);

document.body.addEventListener('drop', (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (inputContainer) inputContainer.classList.remove('active-drop');

    const isModalInput = e.target.closest('#editModalBackdrop, #regenerateModalBackdrop, #profileModal');
    if (isModalInput) return; 

    const droppedFiles = e.dataTransfer?.files;
    if (droppedFiles && droppedFiles.length > 0) {
        handleFileUpload(droppedFiles); 
    }
}, false);


if (chatInput) { 
    chatInput.addEventListener('paste', async (e) => {
        const pastedFiles = [];
        
        if (e.clipboardData?.files?.length > 0) {
            pastedFiles.push(...e.clipboardData.files);
        }
        
        else if (navigator.clipboard?.read) {
            try {
                const clipboardItems = await navigator.clipboard.read();
                for (const item of clipboardItems) {
                    for (const type of item.types) {
                        if (type.startsWith('image/')) { 
                            const blob = await item.getType(type);
                            const extension = type.split('/')[1] || 'png'; 
                            const fileName = `pasted-image-${Date.now()}.${extension}`;
                            pastedFiles.push(new File([blob], fileName, { type }));
                        }
                    }
                }
            } catch (err) {
                if (err.name === 'NotAllowedError') {
                    
                } else {
                    console.error('Async clipboard read failed:', err);
                }
            }
        }

        if (pastedFiles.length > 0) {
            e.preventDefault(); 
            e.stopPropagation();
            handleFileUpload(pastedFiles); 
        }
        
    });
}

function showLivePreview(url) {
    const container = document.getElementById('live-preview-container');
    const iframe = document.getElementById('live-preview-iframe');
    const title = document.getElementById('live-preview-title');
    const fallback = document.getElementById('live-preview-fallback');
    const fallbackLink = fallback.querySelector('a');

    if (!container || !iframe || !title || !fallback || !fallbackLink) return;

    
    clearTimeout(livePreviewTimer);
    iframe.style.display = 'block';
    fallback.style.display = 'none';

    
    title.textContent = `Scraping: ${url}`;
    fallbackLink.href = url;
    
  
    iframe.src = 'about:blank';
    setTimeout(() => {
        iframe.src = url;
    }, 50);

   
    container.style.display = 'flex';

    
    iframe.onload = () => {
        try {
            
            const x = iframe.contentWindow.document;
        } catch (e) {
            iframe.style.display = 'none';
            fallback.style.display = 'flex';
        }
    };

    
    livePreviewTimer = setTimeout(() => {
        hideLivePreview();
    }, 20000); 
}

function hideLivePreview() {
    const container = document.getElementById('live-preview-container');
    if (container) {
        container.style.display = 'none';
    }
    clearTimeout(livePreviewTimer);
}
function processScrapingQueue() {
    clearTimeout(scrapingTimerId); 
    scrapingTimerId = null; 

    if (scrapingQueue.length > 0) {
        const urlToDisplay = scrapingQueue.shift(); 
        showLivePreview(urlToDisplay); 

       
        scrapingTimerId = setTimeout(() => {
            processScrapingQueue(); 
        }, SCRAPING_DISPLAY_DELAY);
    } else {
        
        hideLivePreview();
    }
}


function makeDraggable(element, handle) {
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    handle.onmousedown = dragMouseDown;

    function dragMouseDown(e) {
        e = e || window.event;
        e.preventDefault();
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        document.onmousemove = elementDrag;
    }

    function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        element.style.top = (element.offsetTop - pos2) + "px";
        element.style.left = (element.offsetLeft - pos1) + "px";
    }

    function closeDragElement() {
        document.onmouseup = null;
        document.onmousemove = null;
    }
}

if (chatSearchInput) {
    let debounceTimer; 

    chatSearchInput.addEventListener('input', () => {
       
        clearTimeout(debounceTimer);

        
        debounceTimer = setTimeout(async () => {
            const searchTerm = chatSearchInput.value.toLowerCase().trim();
            currentSearchTerm = searchTerm;
            const chatItems = document.querySelectorAll('#chatList .chat-item');

            if (searchTerm === "") {
                chatItems.forEach(item => {
                    item.style.display = 'flex';
                    const snippetDiv = item.querySelector('.snippet-preview');
                    if (snippetDiv) {
                        snippetDiv.textContent = '';
                        snippetDiv.style.display = 'none';
                    }
                    delete item.dataset.messageId;
                    delete item.dataset.searchTerm;
                });
                currentSearchTerm = '';
                return;
            }

            try {
                const response = await fetch(`/api/chats/search_messages?search_term=${encodeURIComponent(searchTerm)}`);
                if (!response.ok) {
                    console.error('Failed to fetch search results:', response.statusText);
                    return;
                }
                const data = await response.json();
                const matchingChatResults = data.results || {};

                chatItems.forEach(item => {
                    const chatId = item.dataset.chatId;
                    const chatNameSpan = item.querySelector('.chat-name');
                    const snippetDiv = item.querySelector('.snippet-preview');

                    const chatName = chatNameSpan?.textContent.toLowerCase() || '';
                    const result = matchingChatResults[chatId];

                    if (result) {
                        item.style.display = 'flex';
                        item.dataset.messageId = result.message_id;
                        item.dataset.searchTerm = searchTerm;
                        if (snippetDiv) {
                            if (result.snippet) {
                                snippetDiv.innerHTML = result.snippet.replace(
                                    new RegExp(searchTerm, 'gi'),
                                    match => `<span class="">${match}</span>`
                                );
                                snippetDiv.style.display = 'block';
                            } else {
                                snippetDiv.textContent = '';
                                snippetDiv.style.display = 'none';
                            }
                        }
                    } else if (chatName.includes(searchTerm)) {
                        item.style.display = 'flex';
                        if (snippetDiv) {
                            snippetDiv.textContent = '';
                            snippetDiv.style.display = 'none';
                        }
                        delete item.dataset.messageId;
                        delete item.dataset.searchTerm;
                    } else {
                        item.style.display = 'none';
                        if (snippetDiv) {
                            snippetDiv.textContent = '';
                            snippetDiv.style.display = 'none';
                        }
                        delete item.dataset.messageId;
                        delete item.dataset.searchTerm;
                    }
                });

            } catch (error) {
                console.error('Error during chat search:', error);
                chatItems.forEach(item => {
                    item.style.display = 'flex';
                    const snippetDiv = item.querySelector('.snippet-preview');
                    if (snippetDiv) {
                        snippetDiv.textContent = '';
                        snippetDiv.style.display = 'none';
                    }
                    delete item.dataset.messageId;
                    delete item.dataset.searchTerm;
                });
            }
        }, 300); 
    });
}


function createChatItemHtml(chat) {
    return `
        <div class="chat-item-main-content">
            <span class="chat-name">${escapeHtml(chat.name)}</span>
            <div class="snippet-preview"></div>
            <div class="chat-item-token-counter">
                <span class="token-text"></span>
                <div class="token-bar-track">
                    <div class="token-bar-fill"></div>
                </div>
            </div>
        </div>
        <button class="delete-chat-btn" title="Delete chat">✖</button>
    `;
}

    async function handleStopGeneration() {
        console.log("Stop button clicked.");
        if (!isProcessing) {
            toggleSendStopButtons(false);
            return;
        }

        let idToStop = null;
        let placeholderId = null;
        
        if (nebulaProcess.isActive && nebulaProcess.processId) {
            idToStop = nebulaProcess.processId.toString();
        } else if (currentStreamQueryId) {
            idToStop = currentStreamQueryId;
            placeholderId = document.querySelector('.placeholder-message')?.dataset.id;
        }

        if (!idToStop) {
            console.warn("Stop clicked, but no active process ID found.");
            cleanupStream(true, "Stopped by user.", null); 
            if (nebulaProcess.isActive) {
                cleanupNebulaProcess(true, "Process stopped by user.");
            }
            return;
        }

        setStatus("Stopping...", false);
        if (nebulaProcess.isActive) {
            cleanupNebulaProcess(true, "Process stopped by user.");
        } else {
            cleanupStream(true, "Stopped by user.", placeholderId);
        }
        
        try {
            await fetch('/api/stop_generation', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query_id: idToStop })
            });
            console.log(`Sent stop signal for ID: ${idToStop}`);
        } catch (err) {
            console.error("Failed to send stop signal to backend:", err);
        }
    }
if (stopBtn) stopBtn.addEventListener('click', handleStopGeneration);

 let currentCodeLabProblem = null; // To store the current problem details

               function handleCodeExecution(runType) {
            if (!codeLabEditor) {
                alert("Editor not initialized.");
                return;
            }
            // MODIFIED: Only check for a loaded problem on 'submit'
            if (runType === 'submit' && !currentCodeLabProblem) {
                alert("A problem must be loaded from the database to use the 'Submit' button.");
                return;
            }

            const code = codeLabEditor.getValue();
            const language = document.getElementById('codelabLanguageSelector').value;
            const outputPanel = document.getElementById('codelab-output-panel');
            const runBtn = document.getElementById('codelabRunBtn');
            const submitBtn = document.getElementById('codelabSubmitBtn');

            outputPanel.innerHTML = 'Running...';
            runBtn.disabled = true;
            submitBtn.disabled = true;

            const payload = {
                problem_id: currentCodeLabProblem ? currentCodeLabProblem.id : null,
                code: code,
                language: language,
                run_type: runType
            };

            fetch('/codelab/submit', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => { throw new Error(err.error || 'Server error'); });
                }
                return response.json();
            })
            .then(data => {
                let outputHtml = `<strong>${escapeHtml(data.final_summary || data.status)}</strong><hr style="border-color: var(--input-border); margin: 10px 0;">`;
                
                // Case 1: Test harness results (from Submit or Run with tests)
                if (data.results && data.results.length > 0) {
                    data.results.forEach(res => {
                        const statusClass = res.status === 'passed' ? 'color: var(--nebula-confirm-start);' : 'color: var(--nebula-regenerate-start);';
                        outputHtml += `<div style="margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid var(--input-border);">`;
                        outputHtml += `<p style="${statusClass}">Test Case #${res.id}: <strong>${res.status.toUpperCase()}</strong></p>`;
                        if (res.status !== 'passed') {
                            outputHtml += `<small>Input:</small><pre><code>${escapeHtml(JSON.stringify(res.input))}</code></pre>`;
                            outputHtml += `<small>Expected:</small><pre><code>${escapeHtml(JSON.stringify(res.expected))}</code></pre>`;
                            outputHtml += `<small>Got:</small><pre><code>${escapeHtml(JSON.stringify(res.actual))}</code></pre>`;
                        }
                        if (res.message) {
                            outputHtml += `<p>Error: ${escapeHtml(res.message)}</p>`;
                        }
                        outputHtml += `</div>`;
                    });
                } 
                // Case 2: Raw output (from a simple Run)
                else if (data.raw_output) {
                    outputHtml += `<pre><code>${escapeHtml(data.raw_output)}</code></pre>`;
                }
                // Case 3: Raw error (from a simple Run that failed)
                else if (data.raw_error) {
                    outputHtml += `<pre><code style="color: var(--nebula-regenerate-start);">${escapeHtml(data.raw_error)}</code></pre>`;
                }
                 // Case 4: Import Error from harness
                else if (data.status === 'Import Error' && data.results && data.results[0]?.message) {
                     outputHtml += `<pre><code style="color: var(--nebula-regenerate-start);">${escapeHtml(data.results[0].message)}</code></pre>`;
                }

                outputPanel.innerHTML = outputHtml;
            })
            .catch(error => {
                outputPanel.innerHTML = `<strong style="color: var(--nebula-regenerate-start);">Execution Failed:</strong><br><pre><code>${escapeHtml(error.message)}</code></pre>`;
            })
            .finally(() => {
                runBtn.disabled = false;
                submitBtn.disabled = false;
            });
        }

        function handleAIAssist(assistType) {
            if (!codeLabEditor) { return; }
            const code = codeLabEditor.getValue();
            if (!code.trim()) {
                alert("There is no code to analyze.");
                return;
            }

            const mentorScroller = document.getElementById('mentor-content-scroller');
            const assistContainer = document.getElementById('ai-assist-responses-container');
            const outputPanel = document.getElementById('codelab-output-panel');
            const aiButtons = document.querySelectorAll('.codelab-ai-btn');
            
            aiButtons.forEach(btn => btn.disabled = true);

            const payload = {
                assist_type: assistType,
                code: code,
                problem_context: currentCodeLabProblem ? currentCodeLabProblem.description : "A general coding question.",
                error_message: outputPanel.textContent,
                test_case_context: ''
            };

            const responseContainer = document.createElement('div');
            responseContainer.className = 'ai-mentor-response';
            responseContainer.innerHTML = '<p><em>Stellar is thinking...</em></p>';
            
            // Correctly append to the container INSIDE the scroller
            assistContainer.appendChild(responseContainer);
            mentorScroller.scrollTop = mentorScroller.scrollHeight;

            let fullContent = '';

            fetch('/codelab/assist', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Server error: ${response.statusText}`);
                }
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                function processText({ done, value }) {
                    if (done) {
                        renderFinalAIResponse();
                        return;
                    }
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n\n');
                    buffer = lines.pop();

                    lines.forEach(line => {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.substring(6));
                                if (data.status) {
                                    responseContainer.innerHTML = `<p><em>${escapeHtml(data.status)}</em></p>`;
                                }
                                if (data.content) {
                                    fullContent += data.content;
                                }
                                if (data.error) {
                                    fullContent = `<p style="color: var(--nebula-regenerate-start);">Error: ${escapeHtml(data.error)}</p>`;
                                }
                            } catch (e) {
                                console.error('Error parsing stream data:', e);
                            }
                        }
                    });
                    return reader.read().then(processText);
                }
                return reader.read().then(processText);
            })
            .catch(err => {
                fullContent = `<p style="color: var(--nebula-regenerate-start);">Error: Could not connect to AI assistant. ${err.message}</p>`;
                renderFinalAIResponse();
            });

            function renderFinalAIResponse() {
                let htmlContent = marked.parse(fullContent);
                htmlContent = wrapTables(htmlContent);
                responseContainer.innerHTML = htmlContent;
                processCodeBlocks(responseContainer);
                renderMath(responseContainer);
                mentorScroller.scrollTop = mentorScroller.scrollHeight;
                aiButtons.forEach(btn => btn.disabled = false);
            }
        }

       

        async function loadCodeLabProblem(problemId = null) {
    const mentorPanel = document.getElementById('ai-mentor-panel');
    if (!mentorPanel) return;

    const problemDisplay = document.getElementById('problem-display-container');
    const generationContainer = document.getElementById('problem-generation-container');
    
    problemDisplay.innerHTML = '<p>Loading problem...</p>';
    generationContainer.style.display = 'none'; // Hide form while loading
    
    try {
        const payload = problemId ? { problem_id: problemId } : {};
        const response = await fetch('/codelab/problem', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errData = await response.json();
            throw new Error(errData.error || `Server responded with status ${response.status}`);
        }

        const data = await response.json();
        renderProblem(data.problem, data.test_cases);

    } catch (error) {
        problemDisplay.innerHTML = `<p style="color: var(--nebula-regenerate-start);">Failed to load problem: ${error.message}</p><p>You can generate a new one below.</p>`;
        generationContainer.style.display = 'block'; // Show form on error
        console.error("CodeLab Error:", error);
    }
}

function renderProblem(problem, testCases) {
    currentCodeLabProblem = problem;
    const mentorPanel = document.getElementById('ai-mentor-panel');
    const problemDisplay = document.getElementById('problem-display-container');
    const generationContainer = document.getElementById('problem-generation-container');
    const newProblemBtn = document.getElementById('newProblemBtn');

    if (!mentorPanel || !problemDisplay || !generationContainer || !newProblemBtn) return;

    generationContainer.style.display = 'none';
    newProblemBtn.style.display = 'block';

    const tagsHtml = problem.topic_tags 
        ? `<div class="codelab-topic-tags">Tags: ${escapeHtml(problem.topic_tags)}</div>` 
        : '';

    let descriptionHtml = marked.parse(problem.description || "");

    let testCasesHtml = '<h3>Examples</h3>';
    if (testCases && testCases.length > 0) {
        testCases.forEach((tc, index) => {
            let formattedInput = '';
            // This logic now correctly handles different data types from the server
            if (typeof tc.input_data === 'object' && tc.input_data !== null && !Array.isArray(tc.input_data)) {
                 formattedInput = Object.entries(tc.input_data)
                    .map(([key, value]) => `${key} = ${JSON.stringify(value)}`)
                    .join(', ');
            } else {
                 formattedInput = JSON.stringify(tc.input_data);
            }
            
            // This ensures the output is always displayed as a string
            const formattedOutput = JSON.stringify(tc.expected_output);

            testCasesHtml += `
                <div class="codelab-test-case">
                    <strong>Example ${index + 1}:</strong>
                    <div style="margin-top: 8px; padding-left: 10px;">
                        <p><strong>Input:</strong> <code style="background-color: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px;">${escapeHtml(formattedInput)}</code></p>
                        <p><strong>Output:</strong> <code style="background-color: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px;">${escapeHtml(formattedOutput)}</code></p>
                    </div>
                </div>
            `;
        });
    } else {
        testCasesHtml += '<p>No visible test cases provided.</p>';
    }

    problemDisplay.innerHTML = `
        <div class="codelab-problem-title">${escapeHtml(problem.title)}</div>
        <div class="codelab-problem-meta">
            <span class="codelab-difficulty-tag ${escapeHtml(problem.difficulty)}">${escapeHtml(problem.difficulty)}</span>
            ${tagsHtml}
        </div>
        <div class="codelab-problem-description">
            ${descriptionHtml}
            ${testCasesHtml}
        </div>
    `;
    
    problemDisplay.querySelectorAll('pre code').forEach(block => {
        if (typeof hljs !== 'undefined') {
            hljs.highlightElement(block);
        }
    });
}
let codeLabEditor = null;

                function initializeCodeEditor() {
    const editorContainer = document.getElementById('code-editor-container');
    if (editorContainer && !codeLabEditor) {
        codeLabEditor = CodeMirror(editorContainer, {
            value: "# Welcome to Stellar CodeLab!\n# Select HTML from the dropdown to try the live preview.\n\nprint('Hello, CodeLab!')",
            mode: 'python',
            theme: 'dracula',
            lineNumbers: true,
            indentUnit: 4,
            matchBrackets: true,
            autoCloseBrackets: true
        });

        // --- ADD THIS LINE TO FIX THE LAYOUT BUG ---
        setTimeout(() => { codeLabEditor.refresh(); }, 1);
        // --- END OF FIX ---

        codeLabEditor.on('keyup', () => {
            clearTimeout(renderHtmlDebounceTimer);
            renderHtmlDebounceTimer = setTimeout(renderLivePreview, 300);
        });
    }
}
       async function handleGenerateProblem(event) {
    event.preventDefault();
    const input = document.getElementById('problemRequestInput');
    const userRequest = input.value.trim();
    if (!userRequest) {
        alert("Please describe the kind of problem you want to generate.");
        return;
    }

    const genBtn = document.getElementById('generateProblemBtn');
    const randBtn = document.getElementById('loadRandomProblemBtn');
    const problemDisplay = document.getElementById('problem-display-container');

    genBtn.disabled = true;
    randBtn.disabled = true;
    problemDisplay.innerHTML = '<p><em>Stellar is generating a new problem... this may take a moment.</em></p>';

    try {
        const response = await fetch('/codelab/generate_problem', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ user_request: userRequest })
        });
        const data = await response.json();
        if (!response.ok || !data.success) {
            throw new Error(data.error || 'Failed to generate problem.');
        }
        
        // Now load the newly created problem
        await loadCodeLabProblem(data.new_problem_id);

    } catch (error) {
        problemDisplay.innerHTML = `<p style="color: var(--nebula-regenerate-start);">Error generating problem: ${error.message}</p>`;
    } finally {
        genBtn.disabled = false;
        randBtn.disabled = false;
        input.value = '';
    }
} 

        function showProblemGenerator() {
            document.getElementById('problem-display-container').innerHTML = '';
            document.getElementById('ai-assist-responses-container').innerHTML = ''; // This now correctly clears the container
            document.getElementById('problem-generation-container').style.display = 'block';
            document.getElementById('newProblemBtn').style.display = 'none';
            currentCodeLabProblem = null;
        }
function renderLivePreview() {
    if (currentMode !== 'codelab' || document.getElementById('codelabLanguageSelector').value !== 'html') return;
    
    const iframe = document.getElementById('live-html-preview');
    const code = codeLabEditor.getValue();

    if (iframe) {
        iframe.srcdoc = code;
    }
}
        function handleLanguageChange() {
            const language = document.getElementById('codelabLanguageSelector').value;
            const workspacePanel = document.getElementById('workspace-panel');
            const mentorPanel = document.getElementById('ai-mentor-panel');
            const aiButtons = document.querySelectorAll('#codelabExplainBtn, #codelabDebugBtn, #codelabOptimizeBtn');

            if (language === 'html') {
                workspacePanel.classList.add('html-mode-active');
                mentorPanel.classList.add('html-view-active'); // Add class to shrink generator
                if (codeLabEditor.getOption("mode") !== "htmlmixed") {
                    codeLabEditor.setValue('<!DOCTYPE html>\n<html>\n<head>\n    <title>My Page</title>\n    <style>\n        body { font-family: sans-serif; color: #333; }\n    </style>\n</head>\n<body>\n    <h1>Hello, Stellar!</h1>\n    <p>Start coding to see your changes live.</p>\n</body>\n</html>');
                    codeLabEditor.setOption("mode", "htmlmixed");
                }
                aiButtons.forEach(btn => btn.disabled = false); // **THIS LINE IS THE FIX**
                renderLivePreview();
            } else {
                workspacePanel.classList.remove('html-mode-active');
                mentorPanel.classList.remove('html-view-active'); // Remove class to restore generator size
                if (codeLabEditor.getOption("mode") !== language) {
                   codeLabEditor.setOption("mode", language);
                   if (language === 'python') {
                       codeLabEditor.setValue("# Welcome to Stellar CodeLab!\nprint('Hello, CodeLab!')");
                   } else {
                       codeLabEditor.setValue(`// Start coding in ${language}`);
                   }
                }
                aiButtons.forEach(btn => btn.disabled = false);
            }
        }

    </script>

</body>
</html>











